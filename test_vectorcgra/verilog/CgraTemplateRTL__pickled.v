//-------------------------------------------------------------------------
// CgraTemplateRTL.v
//-------------------------------------------------------------------------
// This file is generated by PyMTL SystemVerilog translation pass.

// PyMTL BitStruct CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 Definition
typedef struct packed {
  logic [31:0] payload;
  logic [0:0] predicate;
  logic [0:0] bypass;
  logic [0:0] delay;
} CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1;

// PyMTL BitStruct CGRAConfig_7_4_2_8_8_3__603a41f5d0e2436f Definition
typedef struct packed {
  logic [6:0] operation;
  logic [3:0][2:0] fu_in;
  logic [11:0][3:0] routing_xbar_outport;
  logic [11:0][1:0] fu_xbar_outport;
  logic [2:0] vector_factor_power;
  logic [0:0] is_last_ctrl;
  logic [3:0][1:0] write_reg_from;
  logic [3:0][3:0] write_reg_idx;
  logic [3:0][0:0] read_reg_from;
  logic [3:0][3:0] read_reg_idx;
} CGRAConfig_7_4_2_8_8_3__603a41f5d0e2436f;

// PyMTL BitStruct MultiCgraPayload_Cmd_Data_DataAddr_Ctrl_CtrlAddr__a0427cd98cfcae6f Definition
typedef struct packed {
  logic [4:0] cmd;
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 data;
  logic [8:0] data_addr;
  CGRAConfig_7_4_2_8_8_3__603a41f5d0e2436f ctrl;
  logic [2:0] ctrl_addr;
} MultiCgraPayload_Cmd_Data_DataAddr_Ctrl_CtrlAddr__a0427cd98cfcae6f;

// PyMTL BitStruct InterCgraPacket_4_4x1_4_8_4_CgraPayload__9d404f857a1e94ff Definition
typedef struct packed {
  logic [1:0] src;
  logic [1:0] dst;
  logic [1:0] src_x;
  logic [0:0] src_y;
  logic [1:0] dst_x;
  logic [0:0] dst_y;
  logic [2:0] src_tile_id;
  logic [2:0] dst_tile_id;
  logic [1:0] remote_src_port;
  logic [7:0] opaque;
  logic [1:0] vc_id;
  MultiCgraPayload_Cmd_Data_DataAddr_Ctrl_CtrlAddr__a0427cd98cfcae6f payload;
} InterCgraPacket_4_4x1_4_8_4_CgraPayload__9d404f857a1e94ff;

// PyMTL BitStruct IntraCgraPacket_4_4x1_4_8_2_CgraPayload__11cd3f8c0d91825c Definition
typedef struct packed {
  logic [2:0] src;
  logic [2:0] dst;
  logic [1:0] src_cgra_id;
  logic [1:0] dst_cgra_id;
  logic [1:0] src_cgra_x;
  logic [0:0] src_cgra_y;
  logic [1:0] dst_cgra_x;
  logic [0:0] dst_cgra_y;
  logic [7:0] opaque;
  logic [0:0] vc_id;
  MultiCgraPayload_Cmd_Data_DataAddr_Ctrl_CtrlAddr__a0427cd98cfcae6f payload;
} IntraCgraPacket_4_4x1_4_8_2_CgraPayload__11cd3f8c0d91825c;

// PyMTL BitStruct ControllerNocXbarPacket_InterCgraPktType__f1a81b7e6c97120c Definition
typedef struct packed {
  logic [0:0] dst;
  InterCgraPacket_4_4x1_4_8_4_CgraPayload__9d404f857a1e94ff inter_cgra_pkt;
} ControllerNocXbarPacket_InterCgraPktType__f1a81b7e6c97120c;

// PyMTL BitStruct MemAccessPacket_4_3_512__e6eb6c33f0815ad1 Definition
typedef struct packed {
  logic [1:0] src;
  logic [1:0] dst;
  logic [8:0] addr;
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 data;
  logic [1:0] src_cgra;
  logic [2:0] src_tile;
  logic [1:0] remote_src_port;
} MemAccessPacket_4_3_512__e6eb6c33f0815ad1;

// PyMTL BitStruct MemAccessPacket_3_4_512__e6eb6c33f0815ad1 Definition
typedef struct packed {
  logic [1:0] src;
  logic [1:0] dst;
  logic [8:0] addr;
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 data;
  logic [1:0] src_cgra;
  logic [2:0] src_tile;
  logic [1:0] remote_src_port;
} MemAccessPacket_3_4_512__e6eb6c33f0815ad1;

// PyMTL Component Mux Definition
// Full name: Mux__Type_InterCgraPacket_4_4x1_4_8_4_CgraPayload__9d404f857a1e94ff__ninputs_2
// At /cgra/venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/arithmetics.py

module Mux__48b29568d81d0de5
(
  input  logic [0:0] clk ,
  input  InterCgraPacket_4_4x1_4_8_4_CgraPayload__9d404f857a1e94ff in_ [0:1],
  output InterCgraPacket_4_4x1_4_8_4_CgraPayload__9d404f857a1e94ff out ,
  input  logic [0:0] reset ,
  input  logic [0:0] sel 
);

  // PyMTL Update Block Source
  // At /cgra/venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/arithmetics.py:13
  // @update
  // def up_mux():
  //   s.out @= s.in_[ s.sel ]
  
  always_comb begin : up_mux
    out = in_[sel];
  end

endmodule


// PyMTL Component BypassQueue1EntryRTL Definition
// Full name: BypassQueue1EntryRTL__EntryType_InterCgraPacket_4_4x1_4_8_4_CgraPayload__9d404f857a1e94ff
// At /cgra/VectorCGRA/lib/basic/val_rdy/queues.py

module BypassQueue1EntryRTL__cacc926f103cc2be
(
  input  logic [0:0] clk ,
  output logic [0:0] count ,
  input  logic [0:0] reset ,
  input InterCgraPacket_4_4x1_4_8_4_CgraPayload__9d404f857a1e94ff recv__msg  ,
  output logic [0:0] recv__rdy  ,
  input logic [0:0] recv__val  ,
  output InterCgraPacket_4_4x1_4_8_4_CgraPayload__9d404f857a1e94ff send__msg  ,
  input logic [0:0] send__rdy  ,
  output logic [0:0] send__val  
);
  InterCgraPacket_4_4x1_4_8_4_CgraPayload__9d404f857a1e94ff entry;
  logic [0:0] full;
  //-------------------------------------------------------------
  // Component bypass_mux
  //-------------------------------------------------------------

  logic [0:0] bypass_mux__clk;
  InterCgraPacket_4_4x1_4_8_4_CgraPayload__9d404f857a1e94ff bypass_mux__in_ [0:1];
  InterCgraPacket_4_4x1_4_8_4_CgraPayload__9d404f857a1e94ff bypass_mux__out;
  logic [0:0] bypass_mux__reset;
  logic [0:0] bypass_mux__sel;

  Mux__48b29568d81d0de5 bypass_mux
  (
    .clk( bypass_mux__clk ),
    .in_( bypass_mux__in_ ),
    .out( bypass_mux__out ),
    .reset( bypass_mux__reset ),
    .sel( bypass_mux__sel )
  );

  //-------------------------------------------------------------
  // End of component bypass_mux
  //-------------------------------------------------------------

  // PyMTL Lambda Block Source
  // At /cgra/VectorCGRA/lib/basic/val_rdy/queues.py:553
  // s.recv.rdy //= lambda: ~s.full
  
  always_comb begin : _lambda__s_dut_bypass_queue_q_recv_rdy
    recv__rdy = ~full;
  end

  // PyMTL Lambda Block Source
  // At /cgra/VectorCGRA/lib/basic/val_rdy/queues.py:552
  // s.send.val //= lambda: s.full | s.recv.val
  
  always_comb begin : _lambda__s_dut_bypass_queue_q_send_val
    send__val = full | recv__val;
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/lib/basic/val_rdy/queues.py:555
  // @update_ff
  // def ff_bypass1():
  //   if s.reset:
  //     s.full <<= 0
  //   else:
  //     s.full <<= ~s.send.rdy & (s.full | s.recv.val)
  // 
  //   # buffer the incoming message if we cannot directly send it out
  //   if ~s.send.rdy & ~s.full & s.recv.val:
  //     s.entry <<= s.recv.msg
  
  always_ff @(posedge clk) begin : ff_bypass1
    if ( reset ) begin
      full <= 1'd0;
    end
    else
      full <= ( ~send__rdy ) & ( full | recv__val );
    if ( ( ( ~send__rdy ) & ( ~full ) ) & recv__val ) begin
      entry <= recv__msg;
    end
  end

  assign bypass_mux__clk = clk;
  assign bypass_mux__reset = reset;
  assign bypass_mux__in_[0] = recv__msg;
  assign bypass_mux__in_[1] = entry;
  assign send__msg = bypass_mux__out;
  assign bypass_mux__sel = full;
  assign count = full;

endmodule


// PyMTL Component BypassQueueRTL Definition
// Full name: BypassQueueRTL__EntryType_InterCgraPacket_4_4x1_4_8_4_CgraPayload__9d404f857a1e94ff__num_entries_1
// At /cgra/VectorCGRA/lib/basic/val_rdy/queues.py

module BypassQueueRTL__525283e7a6a59a35
(
  input  logic [0:0] clk ,
  output logic [0:0] count ,
  input  logic [0:0] reset ,
  input InterCgraPacket_4_4x1_4_8_4_CgraPayload__9d404f857a1e94ff recv__msg  ,
  output logic [0:0] recv__rdy  ,
  input logic [0:0] recv__val  ,
  output InterCgraPacket_4_4x1_4_8_4_CgraPayload__9d404f857a1e94ff send__msg  ,
  input logic [0:0] send__rdy  ,
  output logic [0:0] send__val  
);
  //-------------------------------------------------------------
  // Component q
  //-------------------------------------------------------------

  logic [0:0] q__clk;
  logic [0:0] q__count;
  logic [0:0] q__reset;
  InterCgraPacket_4_4x1_4_8_4_CgraPayload__9d404f857a1e94ff q__recv__msg;
  logic [0:0] q__recv__rdy;
  logic [0:0] q__recv__val;
  InterCgraPacket_4_4x1_4_8_4_CgraPayload__9d404f857a1e94ff q__send__msg;
  logic [0:0] q__send__rdy;
  logic [0:0] q__send__val;

  BypassQueue1EntryRTL__cacc926f103cc2be q
  (
    .clk( q__clk ),
    .count( q__count ),
    .reset( q__reset ),
    .recv__msg( q__recv__msg ),
    .recv__rdy( q__recv__rdy ),
    .recv__val( q__recv__val ),
    .send__msg( q__send__msg ),
    .send__rdy( q__send__rdy ),
    .send__val( q__send__val )
  );

  //-------------------------------------------------------------
  // End of component q
  //-------------------------------------------------------------

  assign q__clk = clk;
  assign q__reset = reset;
  assign q__recv__msg = recv__msg;
  assign recv__rdy = q__recv__rdy;
  assign q__recv__val = recv__val;
  assign send__msg = q__send__msg;
  assign q__send__rdy = send__rdy;
  assign send__val = q__send__val;
  assign count = q__count;

endmodule


// PyMTL Component NormalQueueCtrlRTL Definition
// At /cgra/VectorCGRA/lib/basic/val_rdy/queues.py

module NormalQueueCtrlRTL__num_entries_2
(
  input  logic [0:0] clk ,
  output logic [1:0] count ,
  output logic [0:0] raddr ,
  output logic [0:0] recv_rdy ,
  input  logic [0:0] recv_val ,
  input  logic [0:0] reset ,
  input  logic [0:0] send_rdy ,
  output logic [0:0] send_val ,
  output logic [0:0] waddr ,
  output logic [0:0] wen 
);
  localparam logic [1:0] __const__num_entries_at__lambda__s_dut_controller_crossbar_input_units_0__queue_ctrl_recv_rdy  = 2'd2;
  localparam logic [1:0] __const__num_entries_at_up_reg  = 2'd2;
  logic [0:0] head;
  logic [0:0] recv_xfer;
  logic [0:0] send_xfer;
  logic [0:0] tail;

  // PyMTL Lambda Block Source
  // At /cgra/VectorCGRA/lib/basic/val_rdy/queues.py:121
  // s.recv_rdy  //= lambda: s.count < num_entries
  
  always_comb begin : _lambda__s_dut_controller_crossbar_input_units_0__queue_ctrl_recv_rdy
    recv_rdy = count < 2'( __const__num_entries_at__lambda__s_dut_controller_crossbar_input_units_0__queue_ctrl_recv_rdy );
  end

  // PyMTL Lambda Block Source
  // At /cgra/VectorCGRA/lib/basic/val_rdy/queues.py:124
  // s.recv_xfer //= lambda: s.recv_val & s.recv_rdy
  
  always_comb begin : _lambda__s_dut_controller_crossbar_input_units_0__queue_ctrl_recv_xfer
    recv_xfer = recv_val & recv_rdy;
  end

  // PyMTL Lambda Block Source
  // At /cgra/VectorCGRA/lib/basic/val_rdy/queues.py:122
  // s.send_val  //= lambda: s.count > 0
  
  always_comb begin : _lambda__s_dut_controller_crossbar_input_units_0__queue_ctrl_send_val
    send_val = count > 2'd0;
  end

  // PyMTL Lambda Block Source
  // At /cgra/VectorCGRA/lib/basic/val_rdy/queues.py:125
  // s.send_xfer //= lambda: s.send_val & s.send_rdy
  
  always_comb begin : _lambda__s_dut_controller_crossbar_input_units_0__queue_ctrl_send_xfer
    send_xfer = send_val & send_rdy;
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/lib/basic/val_rdy/queues.py:127
  // @update_ff
  // def up_reg():
  // 
  //   if s.reset:
  //     s.head  <<= 0
  //     s.tail  <<= 0
  //     s.count <<= 0
  // 
  //   else:
  //     if s.recv_xfer:
  //       s.tail <<= s.tail + 1 if ( s.tail < num_entries - 1 ) else 0
  // 
  //     if s.send_xfer:
  //       s.head <<= s.head + 1 if ( s.head < num_entries -1 ) else 0
  // 
  //     if s.recv_xfer & ~s.send_xfer:
  //       s.count <<= s.count + 1
  //     elif ~s.recv_xfer & s.send_xfer:
  //       s.count <<= s.count - 1
  
  always_ff @(posedge clk) begin : up_reg
    if ( reset ) begin
      head <= 1'd0;
      tail <= 1'd0;
      count <= 2'd0;
    end
    else begin
      if ( recv_xfer ) begin
        tail <= ( tail < ( 1'( __const__num_entries_at_up_reg ) - 1'd1 ) ) ? tail + 1'd1 : 1'd0;
      end
      if ( send_xfer ) begin
        head <= ( head < ( 1'( __const__num_entries_at_up_reg ) - 1'd1 ) ) ? head + 1'd1 : 1'd0;
      end
      if ( recv_xfer & ( ~send_xfer ) ) begin
        count <= count + 2'd1;
      end
      else if ( ( ~recv_xfer ) & send_xfer ) begin
        count <= count - 2'd1;
      end
    end
  end

  assign wen = recv_xfer;
  assign waddr = tail;
  assign raddr = head;

endmodule


// PyMTL Component RegisterFile Definition
// Full name: RegisterFile__Type_ControllerNocXbarPacket_InterCgraPktType__f1a81b7e6c97120c__nregs_2__rd_ports_1__wr_ports_1__const_zero_False
// At /cgra/venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/register_files.py

module RegisterFile__9540bc60de8fbc35
(
  input  logic [0:0] clk ,
  input  logic [0:0] raddr [0:0],
  output ControllerNocXbarPacket_InterCgraPktType__f1a81b7e6c97120c rdata [0:0],
  input  logic [0:0] reset ,
  input  logic [0:0] waddr [0:0],
  input  ControllerNocXbarPacket_InterCgraPktType__f1a81b7e6c97120c wdata [0:0],
  input  logic [0:0] wen [0:0]
);
  localparam logic [0:0] __const__rd_ports_at_up_rf_read  = 1'd1;
  localparam logic [0:0] __const__wr_ports_at_up_rf_write  = 1'd1;
  ControllerNocXbarPacket_InterCgraPktType__f1a81b7e6c97120c regs [0:1];

  // PyMTL Update Block Source
  // At /cgra/venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/register_files.py:20
  // @update
  // def up_rf_read():
  //   for i in range( rd_ports ):
  //     s.rdata[i] @= s.regs[ s.raddr[i] ]
  
  always_comb begin : up_rf_read
    for ( int unsigned i = 1'd0; i < 1'( __const__rd_ports_at_up_rf_read ); i += 1'd1 )
      rdata[1'(i)] = regs[raddr[1'(i)]];
  end

  // PyMTL Update Block Source
  // At /cgra/venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/register_files.py:32
  // @update_ff
  // def up_rf_write():
  //   for i in range( wr_ports ):
  //     if s.wen[i]:
  //       s.regs[ s.waddr[i] ] <<= s.wdata[i]
  
  always_ff @(posedge clk) begin : up_rf_write
    for ( int unsigned i = 1'd0; i < 1'( __const__wr_ports_at_up_rf_write ); i += 1'd1 )
      if ( wen[1'(i)] ) begin
        regs[waddr[1'(i)]] <= wdata[1'(i)];
      end
  end

endmodule


// PyMTL Component NormalQueueDpathRTL Definition
// Full name: NormalQueueDpathRTL__EntryType_ControllerNocXbarPacket_InterCgraPktType__f1a81b7e6c97120c__num_entries_2
// At /cgra/VectorCGRA/lib/basic/val_rdy/queues.py

module NormalQueueDpathRTL__704206ac7c36e308
(
  input  logic [0:0] clk ,
  input  logic [0:0] raddr ,
  input  ControllerNocXbarPacket_InterCgraPktType__f1a81b7e6c97120c recv_msg ,
  input  logic [0:0] reset ,
  output ControllerNocXbarPacket_InterCgraPktType__f1a81b7e6c97120c send_msg ,
  input  logic [0:0] waddr ,
  input  logic [0:0] wen 
);
  //-------------------------------------------------------------
  // Component rf
  //-------------------------------------------------------------

  logic [0:0] rf__clk;
  logic [0:0] rf__raddr [0:0];
  ControllerNocXbarPacket_InterCgraPktType__f1a81b7e6c97120c rf__rdata [0:0];
  logic [0:0] rf__reset;
  logic [0:0] rf__waddr [0:0];
  ControllerNocXbarPacket_InterCgraPktType__f1a81b7e6c97120c rf__wdata [0:0];
  logic [0:0] rf__wen [0:0];

  RegisterFile__9540bc60de8fbc35 rf
  (
    .clk( rf__clk ),
    .raddr( rf__raddr ),
    .rdata( rf__rdata ),
    .reset( rf__reset ),
    .waddr( rf__waddr ),
    .wdata( rf__wdata ),
    .wen( rf__wen )
  );

  //-------------------------------------------------------------
  // End of component rf
  //-------------------------------------------------------------

  assign rf__clk = clk;
  assign rf__reset = reset;
  assign rf__raddr[0] = raddr;
  assign send_msg = rf__rdata[0];
  assign rf__wen[0] = wen;
  assign rf__waddr[0] = waddr;
  assign rf__wdata[0] = recv_msg;

endmodule


// PyMTL Component NormalQueueRTL Definition
// Full name: NormalQueueRTL__EntryType_ControllerNocXbarPacket_InterCgraPktType__f1a81b7e6c97120c__num_entries_2
// At /cgra/VectorCGRA/lib/basic/val_rdy/queues.py

module NormalQueueRTL__704206ac7c36e308
(
  input  logic [0:0] clk ,
  output logic [1:0] count ,
  input  logic [0:0] reset ,
  input ControllerNocXbarPacket_InterCgraPktType__f1a81b7e6c97120c recv__msg  ,
  output logic [0:0] recv__rdy  ,
  input logic [0:0] recv__val  ,
  output ControllerNocXbarPacket_InterCgraPktType__f1a81b7e6c97120c send__msg  ,
  input logic [0:0] send__rdy  ,
  output logic [0:0] send__val  
);
  //-------------------------------------------------------------
  // Component ctrl
  //-------------------------------------------------------------

  logic [0:0] ctrl__clk;
  logic [1:0] ctrl__count;
  logic [0:0] ctrl__raddr;
  logic [0:0] ctrl__recv_rdy;
  logic [0:0] ctrl__recv_val;
  logic [0:0] ctrl__reset;
  logic [0:0] ctrl__send_rdy;
  logic [0:0] ctrl__send_val;
  logic [0:0] ctrl__waddr;
  logic [0:0] ctrl__wen;

  NormalQueueCtrlRTL__num_entries_2 ctrl
  (
    .clk( ctrl__clk ),
    .count( ctrl__count ),
    .raddr( ctrl__raddr ),
    .recv_rdy( ctrl__recv_rdy ),
    .recv_val( ctrl__recv_val ),
    .reset( ctrl__reset ),
    .send_rdy( ctrl__send_rdy ),
    .send_val( ctrl__send_val ),
    .waddr( ctrl__waddr ),
    .wen( ctrl__wen )
  );

  //-------------------------------------------------------------
  // End of component ctrl
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component dpath
  //-------------------------------------------------------------

  logic [0:0] dpath__clk;
  logic [0:0] dpath__raddr;
  ControllerNocXbarPacket_InterCgraPktType__f1a81b7e6c97120c dpath__recv_msg;
  logic [0:0] dpath__reset;
  ControllerNocXbarPacket_InterCgraPktType__f1a81b7e6c97120c dpath__send_msg;
  logic [0:0] dpath__waddr;
  logic [0:0] dpath__wen;

  NormalQueueDpathRTL__704206ac7c36e308 dpath
  (
    .clk( dpath__clk ),
    .raddr( dpath__raddr ),
    .recv_msg( dpath__recv_msg ),
    .reset( dpath__reset ),
    .send_msg( dpath__send_msg ),
    .waddr( dpath__waddr ),
    .wen( dpath__wen )
  );

  //-------------------------------------------------------------
  // End of component dpath
  //-------------------------------------------------------------

  assign ctrl__clk = clk;
  assign ctrl__reset = reset;
  assign dpath__clk = clk;
  assign dpath__reset = reset;
  assign dpath__wen = ctrl__wen;
  assign dpath__waddr = ctrl__waddr;
  assign dpath__raddr = ctrl__raddr;
  assign ctrl__recv_val = recv__val;
  assign recv__rdy = ctrl__recv_rdy;
  assign dpath__recv_msg = recv__msg;
  assign send__val = ctrl__send_val;
  assign ctrl__send_rdy = send__rdy;
  assign send__msg = dpath__send_msg;
  assign count = ctrl__count;

endmodule


// PyMTL Component InputUnitRTL Definition
// Full name: InputUnitRTL__PacketType_ControllerNocXbarPacket_InterCgraPktType__f1a81b7e6c97120c__QueueType_NormalQueueRTL
// At /cgra/VectorCGRA/noc/PyOCN/pymtl3_net/router/InputUnitRTL.py

module InputUnitRTL__cc02cdef134123ae
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input ControllerNocXbarPacket_InterCgraPktType__f1a81b7e6c97120c recv__msg  ,
  output logic [0:0] recv__rdy  ,
  input logic [0:0] recv__val  ,
  output ControllerNocXbarPacket_InterCgraPktType__f1a81b7e6c97120c send__msg  ,
  input logic [0:0] send__rdy  ,
  output logic [0:0] send__val  
);
  //-------------------------------------------------------------
  // Component queue
  //-------------------------------------------------------------

  logic [0:0] queue__clk;
  logic [1:0] queue__count;
  logic [0:0] queue__reset;
  ControllerNocXbarPacket_InterCgraPktType__f1a81b7e6c97120c queue__recv__msg;
  logic [0:0] queue__recv__rdy;
  logic [0:0] queue__recv__val;
  ControllerNocXbarPacket_InterCgraPktType__f1a81b7e6c97120c queue__send__msg;
  logic [0:0] queue__send__rdy;
  logic [0:0] queue__send__val;

  NormalQueueRTL__704206ac7c36e308 queue
  (
    .clk( queue__clk ),
    .count( queue__count ),
    .reset( queue__reset ),
    .recv__msg( queue__recv__msg ),
    .recv__rdy( queue__recv__rdy ),
    .recv__val( queue__recv__val ),
    .send__msg( queue__send__msg ),
    .send__rdy( queue__send__rdy ),
    .send__val( queue__send__val )
  );

  //-------------------------------------------------------------
  // End of component queue
  //-------------------------------------------------------------

  assign queue__clk = clk;
  assign queue__reset = reset;
  assign queue__recv__msg = recv__msg;
  assign recv__rdy = queue__recv__rdy;
  assign queue__recv__val = recv__val;
  assign send__msg = queue__send__msg;
  assign queue__send__rdy = send__rdy;
  assign send__val = queue__send__val;

endmodule


// PyMTL Component OutputUnitRTL Definition
// Full name: OutputUnitRTL__PacketType_ControllerNocXbarPacket_InterCgraPktType__f1a81b7e6c97120c__QueueType_None
// At /cgra/VectorCGRA/noc/PyOCN/pymtl3_net/router/OutputUnitRTL.py

module OutputUnitRTL__a9946f5ad8907102
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input ControllerNocXbarPacket_InterCgraPktType__f1a81b7e6c97120c recv__msg  ,
  output logic [0:0] recv__rdy  ,
  input logic [0:0] recv__val  ,
  output ControllerNocXbarPacket_InterCgraPktType__f1a81b7e6c97120c send__msg  ,
  input logic [0:0] send__rdy  ,
  output logic [0:0] send__val  
);

  assign send__msg = recv__msg;
  assign recv__rdy = send__rdy;
  assign send__val = recv__val;

endmodule


// PyMTL Component XbarRouteUnitRTL Definition
// Full name: XbarRouteUnitRTL__PacketType_ControllerNocXbarPacket_InterCgraPktType__f1a81b7e6c97120c__num_outports_1
// At /cgra/VectorCGRA/noc/PyOCN/pymtl3_net/xbar/XbarRouteUnitRTL.py

module XbarRouteUnitRTL__b4ff6020003d1be0
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input ControllerNocXbarPacket_InterCgraPktType__f1a81b7e6c97120c recv__msg  ,
  output logic [0:0] recv__rdy  ,
  input logic [0:0] recv__val  ,
  output ControllerNocXbarPacket_InterCgraPktType__f1a81b7e6c97120c send__msg [0:0] ,
  input logic [0:0] send__rdy [0:0] ,
  output logic [0:0] send__val [0:0] 
);
  localparam logic [0:0] __const__num_outports_at_up_ru_routing  = 1'd1;
  logic [0:0] out_dir;
  logic [0:0] send_val;

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/noc/PyOCN/pymtl3_net/xbar/XbarRouteUnitRTL.py:51
  // @update
  // def up_ru_recv_rdy():
  //   s.recv.rdy @= s.send[ s.out_dir ].rdy > 0
  
  always_comb begin : up_ru_recv_rdy
    recv__rdy = send__rdy[out_dir] > 1'd0;
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/noc/PyOCN/pymtl3_net/xbar/XbarRouteUnitRTL.py:41
  // @update
  // def up_ru_routing():
  //   s.out_dir @= trunc( s.recv.msg.dst, dir_nbits )
  // 
  //   for i in range( num_outports ):
  //     s.send[i].val @= b1(0)
  // 
  //   if s.recv.val:
  //     s.send[ s.out_dir ].val @= b1(1)
  
  always_comb begin : up_ru_routing
    out_dir = recv__msg.dst;
    for ( int unsigned i = 1'd0; i < 1'( __const__num_outports_at_up_ru_routing ); i += 1'd1 )
      send__val[1'(i)] = 1'd0;
    if ( recv__val ) begin
      send__val[out_dir] = 1'd1;
    end
  end

  assign send__msg[0] = recv__msg;
  assign send_val[0:0] = send__val[0];

endmodule


// PyMTL Component RegEnRst Definition
// At /cgra/venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/registers.py

module RegEnRst__Type_Bits6__reset_value_1
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  input  logic [5:0] in_ ,
  output logic [5:0] out ,
  input  logic [0:0] reset 
);
  localparam logic [0:0] __const__reset_value_at_up_regenrst  = 1'd1;

  // PyMTL Update Block Source
  // At /cgra/venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/registers.py:55
  // @update_ff
  // def up_regenrst():
  //   if s.reset: s.out <<= reset_value
  //   elif s.en:  s.out <<= s.in_
  
  always_ff @(posedge clk) begin : up_regenrst
    if ( reset ) begin
      out <= 6'( __const__reset_value_at_up_regenrst );
    end
    else if ( en ) begin
      out <= in_;
    end
  end

endmodule


// PyMTL Component RoundRobinArbiterEn Definition
// At /cgra/venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/arbiters.py

module RoundRobinArbiterEn__nreqs_6
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  output logic [5:0] grants ,
  input  logic [5:0] reqs ,
  input  logic [0:0] reset 
);
  localparam logic [2:0] __const__nreqs_at_comb_reqs_int  = 3'd6;
  localparam logic [3:0] __const__nreqsX2_at_comb_reqs_int  = 4'd12;
  localparam logic [2:0] __const__nreqs_at_comb_grants  = 3'd6;
  localparam logic [2:0] __const__nreqs_at_comb_priority_int  = 3'd6;
  localparam logic [3:0] __const__nreqsX2_at_comb_priority_int  = 4'd12;
  localparam logic [3:0] __const__nreqsX2_at_comb_kills  = 4'd12;
  localparam logic [3:0] __const__nreqsX2_at_comb_grants_int  = 4'd12;
  logic [11:0] grants_int;
  logic [12:0] kills;
  logic [0:0] priority_en;
  logic [11:0] priority_int;
  logic [11:0] reqs_int;
  //-------------------------------------------------------------
  // Component priority_reg
  //-------------------------------------------------------------

  logic [0:0] priority_reg__clk;
  logic [0:0] priority_reg__en;
  logic [5:0] priority_reg__in_;
  logic [5:0] priority_reg__out;
  logic [0:0] priority_reg__reset;

  RegEnRst__Type_Bits6__reset_value_1 priority_reg
  (
    .clk( priority_reg__clk ),
    .en( priority_reg__en ),
    .in_( priority_reg__in_ ),
    .out( priority_reg__out ),
    .reset( priority_reg__reset )
  );

  //-------------------------------------------------------------
  // End of component priority_reg
  //-------------------------------------------------------------

  // PyMTL Update Block Source
  // At /cgra/venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/arbiters.py:118
  // @update
  // def comb_grants():
  //   for i in range( nreqs ):
  //     s.grants[i] @= s.grants_int[i] | s.grants_int[nreqs+i]
  
  always_comb begin : comb_grants
    for ( int unsigned i = 1'd0; i < 3'( __const__nreqs_at_comb_grants ); i += 1'd1 )
      grants[3'(i)] = grants_int[4'(i)] | grants_int[4'( __const__nreqs_at_comb_grants ) + 4'(i)];
  end

  // PyMTL Update Block Source
  // At /cgra/venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/arbiters.py:141
  // @update
  // def comb_grants_int():
  //   for i in range( nreqsX2 ):
  //     if s.priority_int[i]:
  //       s.grants_int[i] @= s.reqs_int[i]
  //     else:
  //       s.grants_int[i] @= ~s.kills[i] & s.reqs_int[i]
  
  always_comb begin : comb_grants_int
    for ( int unsigned i = 1'd0; i < 4'( __const__nreqsX2_at_comb_grants_int ); i += 1'd1 )
      if ( priority_int[4'(i)] ) begin
        grants_int[4'(i)] = reqs_int[4'(i)];
      end
      else
        grants_int[4'(i)] = ( ~kills[4'(i)] ) & reqs_int[4'(i)];
  end

  // PyMTL Update Block Source
  // At /cgra/venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/arbiters.py:132
  // @update
  // def comb_kills():
  //   s.kills[0] @= 1
  //   for i in range( nreqsX2 ):
  //     if s.priority_int[i]:
  //       s.kills[i+1] @= s.reqs_int[i]
  //     else:
  //       s.kills[i+1] @= s.kills[i] | ( ~s.kills[i] & s.reqs_int[i] )
  
  always_comb begin : comb_kills
    kills[4'd0] = 1'd1;
    for ( int unsigned i = 1'd0; i < 4'( __const__nreqsX2_at_comb_kills ); i += 1'd1 )
      if ( priority_int[4'(i)] ) begin
        kills[4'(i) + 4'd1] = reqs_int[4'(i)];
      end
      else
        kills[4'(i) + 4'd1] = kills[4'(i)] | ( ( ~kills[4'(i)] ) & reqs_int[4'(i)] );
  end

  // PyMTL Update Block Source
  // At /cgra/venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/arbiters.py:123
  // @update
  // def comb_priority_en():
  //   s.priority_en @= ( s.grants != 0 ) & s.en
  
  always_comb begin : comb_priority_en
    priority_en = ( grants != 6'd0 ) & en;
  end

  // PyMTL Update Block Source
  // At /cgra/venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/arbiters.py:127
  // @update
  // def comb_priority_int():
  //   s.priority_int[    0:nreqs  ] @= s.priority_reg.out
  //   s.priority_int[nreqs:nreqsX2] @= 0
  
  always_comb begin : comb_priority_int
    priority_int[4'd5:4'd0] = priority_reg__out;
    priority_int[4'd11:4'( __const__nreqs_at_comb_priority_int )] = 6'd0;
  end

  // PyMTL Update Block Source
  // At /cgra/venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/arbiters.py:113
  // @update
  // def comb_reqs_int():
  //   s.reqs_int [    0:nreqs  ] @= s.reqs
  //   s.reqs_int [nreqs:nreqsX2] @= s.reqs
  
  always_comb begin : comb_reqs_int
    reqs_int[4'd5:4'd0] = reqs;
    reqs_int[4'd11:4'( __const__nreqs_at_comb_reqs_int )] = reqs;
  end

  assign priority_reg__clk = clk;
  assign priority_reg__reset = reset;
  assign priority_reg__en = priority_en;
  assign priority_reg__in_[5:1] = grants[4:0];
  assign priority_reg__in_[0:0] = grants[5:5];

endmodule


// PyMTL Component Encoder Definition
// At /cgra/venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/encoders.py

module Encoder__in_nbits_6__out_nbits_3
(
  input  logic [0:0] clk ,
  input  logic [5:0] in_ ,
  output logic [2:0] out ,
  input  logic [0:0] reset 
);

  // PyMTL Update Block Source
  // At /cgra/venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/encoders.py:28
  // @update
  // def encode():
  //   s.out @= 0
  //   for i in range( s.in_nbits ):
  //     if s.in_[i]:
  //       s.out @= i
  
  always_comb begin : encode
    out = 3'd0;
    for ( int unsigned i = 1'd0; i < 3'd6; i += 1'd1 )
      if ( in_[3'(i)] ) begin
        out = 3'(i);
      end
  end

endmodule


// PyMTL Component Mux Definition
// Full name: Mux__Type_ControllerNocXbarPacket_InterCgraPktType__f1a81b7e6c97120c__ninputs_6
// At /cgra/venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/arithmetics.py

module Mux__231db74928a9d294
(
  input  logic [0:0] clk ,
  input  ControllerNocXbarPacket_InterCgraPktType__f1a81b7e6c97120c in_ [0:5],
  output ControllerNocXbarPacket_InterCgraPktType__f1a81b7e6c97120c out ,
  input  logic [0:0] reset ,
  input  logic [2:0] sel 
);

  // PyMTL Update Block Source
  // At /cgra/venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/arithmetics.py:13
  // @update
  // def up_mux():
  //   s.out @= s.in_[ s.sel ]
  
  always_comb begin : up_mux
    out = in_[sel];
  end

endmodule


// PyMTL Component SwitchUnitRTL Definition
// Full name: SwitchUnitRTL__PacketType_ControllerNocXbarPacket_InterCgraPktType__f1a81b7e6c97120c__num_inports_6
// At /cgra/VectorCGRA/noc/PyOCN/pymtl3_net/router/SwitchUnitRTL.py

module SwitchUnitRTL__80ba1a3063bf34da
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input ControllerNocXbarPacket_InterCgraPktType__f1a81b7e6c97120c recv__msg [0:5] ,
  output logic [0:0] recv__rdy [0:5] ,
  input logic [0:0] recv__val [0:5] ,
  output ControllerNocXbarPacket_InterCgraPktType__f1a81b7e6c97120c send__msg  ,
  input logic [0:0] send__rdy  ,
  output logic [0:0] send__val  
);
  localparam logic [2:0] __const__num_inports_at_up_get_en  = 3'd6;
  //-------------------------------------------------------------
  // Component arbiter
  //-------------------------------------------------------------

  logic [0:0] arbiter__clk;
  logic [0:0] arbiter__en;
  logic [5:0] arbiter__grants;
  logic [5:0] arbiter__reqs;
  logic [0:0] arbiter__reset;

  RoundRobinArbiterEn__nreqs_6 arbiter
  (
    .clk( arbiter__clk ),
    .en( arbiter__en ),
    .grants( arbiter__grants ),
    .reqs( arbiter__reqs ),
    .reset( arbiter__reset )
  );

  //-------------------------------------------------------------
  // End of component arbiter
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component encoder
  //-------------------------------------------------------------

  logic [0:0] encoder__clk;
  logic [5:0] encoder__in_;
  logic [2:0] encoder__out;
  logic [0:0] encoder__reset;

  Encoder__in_nbits_6__out_nbits_3 encoder
  (
    .clk( encoder__clk ),
    .in_( encoder__in_ ),
    .out( encoder__out ),
    .reset( encoder__reset )
  );

  //-------------------------------------------------------------
  // End of component encoder
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component mux
  //-------------------------------------------------------------

  logic [0:0] mux__clk;
  ControllerNocXbarPacket_InterCgraPktType__f1a81b7e6c97120c mux__in_ [0:5];
  ControllerNocXbarPacket_InterCgraPktType__f1a81b7e6c97120c mux__out;
  logic [0:0] mux__reset;
  logic [2:0] mux__sel;

  Mux__231db74928a9d294 mux
  (
    .clk( mux__clk ),
    .in_( mux__in_ ),
    .out( mux__out ),
    .reset( mux__reset ),
    .sel( mux__sel )
  );

  //-------------------------------------------------------------
  // End of component mux
  //-------------------------------------------------------------

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/noc/PyOCN/pymtl3_net/router/SwitchUnitRTL.py:56
  // @update
  // def up_get_en():
  //   for i in range( num_inports ):
  //     s.recv[i].rdy @= s.send.rdy & ( s.mux.sel == i )
  
  always_comb begin : up_get_en
    for ( int unsigned i = 1'd0; i < 3'( __const__num_inports_at_up_get_en ); i += 1'd1 )
      recv__rdy[3'(i)] = send__rdy & ( mux__sel == 3'(i) );
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/noc/PyOCN/pymtl3_net/router/SwitchUnitRTL.py:51
  // @update
  // def up_send_val():
  //   s.send.val @= s.arbiter.grants > 0
  
  always_comb begin : up_send_val
    send__val = arbiter__grants > 6'd0;
  end

  assign arbiter__clk = clk;
  assign arbiter__reset = reset;
  assign arbiter__en = 1'd1;
  assign mux__clk = clk;
  assign mux__reset = reset;
  assign send__msg = mux__out;
  assign encoder__clk = clk;
  assign encoder__reset = reset;
  assign encoder__in_ = arbiter__grants;
  assign mux__sel = encoder__out;
  assign arbiter__reqs[0:0] = recv__val[0];
  assign mux__in_[0] = recv__msg[0];
  assign arbiter__reqs[1:1] = recv__val[1];
  assign mux__in_[1] = recv__msg[1];
  assign arbiter__reqs[2:2] = recv__val[2];
  assign mux__in_[2] = recv__msg[2];
  assign arbiter__reqs[3:3] = recv__val[3];
  assign mux__in_[3] = recv__msg[3];
  assign arbiter__reqs[4:4] = recv__val[4];
  assign mux__in_[4] = recv__msg[4];
  assign arbiter__reqs[5:5] = recv__val[5];
  assign mux__in_[5] = recv__msg[5];

endmodule


// PyMTL Component XbarRTL Definition
// Full name: XbarRTL__PacketType_ControllerNocXbarPacket_InterCgraPktType__f1a81b7e6c97120c__num_inports_6__num_outports_1__InputUnitType_InputUnitRTL__RouteUnitType_XbarRouteUnitRTL__SwitchUnitType_SwitchUnitRTL__OutputUnitType_OutputUnitRTL
// At /cgra/VectorCGRA/noc/PyOCN/pymtl3_net/xbar/XbarRTL.py

module XbarRTL__40ca80b1d76a0751
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input ControllerNocXbarPacket_InterCgraPktType__f1a81b7e6c97120c recv__msg [0:5] ,
  output logic [0:0] recv__rdy [0:5] ,
  input logic [0:0] recv__val [0:5] ,
  output ControllerNocXbarPacket_InterCgraPktType__f1a81b7e6c97120c send__msg [0:0] ,
  input logic [0:0] send__rdy [0:0] ,
  output logic [0:0] send__val [0:0] 
);
  //-------------------------------------------------------------
  // Component input_units[0:5]
  //-------------------------------------------------------------

  logic [0:0] input_units__clk [0:5];
  logic [0:0] input_units__reset [0:5];
  ControllerNocXbarPacket_InterCgraPktType__f1a81b7e6c97120c input_units__recv__msg [0:5];
  logic [0:0] input_units__recv__rdy [0:5];
  logic [0:0] input_units__recv__val [0:5];
  ControllerNocXbarPacket_InterCgraPktType__f1a81b7e6c97120c input_units__send__msg [0:5];
  logic [0:0] input_units__send__rdy [0:5];
  logic [0:0] input_units__send__val [0:5];

  InputUnitRTL__cc02cdef134123ae input_units__0
  (
    .clk( input_units__clk[0] ),
    .reset( input_units__reset[0] ),
    .recv__msg( input_units__recv__msg[0] ),
    .recv__rdy( input_units__recv__rdy[0] ),
    .recv__val( input_units__recv__val[0] ),
    .send__msg( input_units__send__msg[0] ),
    .send__rdy( input_units__send__rdy[0] ),
    .send__val( input_units__send__val[0] )
  );

  InputUnitRTL__cc02cdef134123ae input_units__1
  (
    .clk( input_units__clk[1] ),
    .reset( input_units__reset[1] ),
    .recv__msg( input_units__recv__msg[1] ),
    .recv__rdy( input_units__recv__rdy[1] ),
    .recv__val( input_units__recv__val[1] ),
    .send__msg( input_units__send__msg[1] ),
    .send__rdy( input_units__send__rdy[1] ),
    .send__val( input_units__send__val[1] )
  );

  InputUnitRTL__cc02cdef134123ae input_units__2
  (
    .clk( input_units__clk[2] ),
    .reset( input_units__reset[2] ),
    .recv__msg( input_units__recv__msg[2] ),
    .recv__rdy( input_units__recv__rdy[2] ),
    .recv__val( input_units__recv__val[2] ),
    .send__msg( input_units__send__msg[2] ),
    .send__rdy( input_units__send__rdy[2] ),
    .send__val( input_units__send__val[2] )
  );

  InputUnitRTL__cc02cdef134123ae input_units__3
  (
    .clk( input_units__clk[3] ),
    .reset( input_units__reset[3] ),
    .recv__msg( input_units__recv__msg[3] ),
    .recv__rdy( input_units__recv__rdy[3] ),
    .recv__val( input_units__recv__val[3] ),
    .send__msg( input_units__send__msg[3] ),
    .send__rdy( input_units__send__rdy[3] ),
    .send__val( input_units__send__val[3] )
  );

  InputUnitRTL__cc02cdef134123ae input_units__4
  (
    .clk( input_units__clk[4] ),
    .reset( input_units__reset[4] ),
    .recv__msg( input_units__recv__msg[4] ),
    .recv__rdy( input_units__recv__rdy[4] ),
    .recv__val( input_units__recv__val[4] ),
    .send__msg( input_units__send__msg[4] ),
    .send__rdy( input_units__send__rdy[4] ),
    .send__val( input_units__send__val[4] )
  );

  InputUnitRTL__cc02cdef134123ae input_units__5
  (
    .clk( input_units__clk[5] ),
    .reset( input_units__reset[5] ),
    .recv__msg( input_units__recv__msg[5] ),
    .recv__rdy( input_units__recv__rdy[5] ),
    .recv__val( input_units__recv__val[5] ),
    .send__msg( input_units__send__msg[5] ),
    .send__rdy( input_units__send__rdy[5] ),
    .send__val( input_units__send__val[5] )
  );

  //-------------------------------------------------------------
  // End of component input_units[0:5]
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component output_units[0:0]
  //-------------------------------------------------------------

  logic [0:0] output_units__clk [0:0];
  logic [0:0] output_units__reset [0:0];
  ControllerNocXbarPacket_InterCgraPktType__f1a81b7e6c97120c output_units__recv__msg [0:0];
  logic [0:0] output_units__recv__rdy [0:0];
  logic [0:0] output_units__recv__val [0:0];
  ControllerNocXbarPacket_InterCgraPktType__f1a81b7e6c97120c output_units__send__msg [0:0];
  logic [0:0] output_units__send__rdy [0:0];
  logic [0:0] output_units__send__val [0:0];

  OutputUnitRTL__a9946f5ad8907102 output_units__0
  (
    .clk( output_units__clk[0] ),
    .reset( output_units__reset[0] ),
    .recv__msg( output_units__recv__msg[0] ),
    .recv__rdy( output_units__recv__rdy[0] ),
    .recv__val( output_units__recv__val[0] ),
    .send__msg( output_units__send__msg[0] ),
    .send__rdy( output_units__send__rdy[0] ),
    .send__val( output_units__send__val[0] )
  );

  //-------------------------------------------------------------
  // End of component output_units[0:0]
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component route_units[0:5]
  //-------------------------------------------------------------

  logic [0:0] route_units__clk [0:5];
  logic [0:0] route_units__reset [0:5];
  ControllerNocXbarPacket_InterCgraPktType__f1a81b7e6c97120c route_units__recv__msg [0:5];
  logic [0:0] route_units__recv__rdy [0:5];
  logic [0:0] route_units__recv__val [0:5];
  ControllerNocXbarPacket_InterCgraPktType__f1a81b7e6c97120c route_units__send__msg [0:5][0:0];
  logic [0:0] route_units__send__rdy [0:5][0:0];
  logic [0:0] route_units__send__val [0:5][0:0];

  XbarRouteUnitRTL__b4ff6020003d1be0 route_units__0
  (
    .clk( route_units__clk[0] ),
    .reset( route_units__reset[0] ),
    .recv__msg( route_units__recv__msg[0] ),
    .recv__rdy( route_units__recv__rdy[0] ),
    .recv__val( route_units__recv__val[0] ),
    .send__msg( route_units__send__msg[0] ),
    .send__rdy( route_units__send__rdy[0] ),
    .send__val( route_units__send__val[0] )
  );

  XbarRouteUnitRTL__b4ff6020003d1be0 route_units__1
  (
    .clk( route_units__clk[1] ),
    .reset( route_units__reset[1] ),
    .recv__msg( route_units__recv__msg[1] ),
    .recv__rdy( route_units__recv__rdy[1] ),
    .recv__val( route_units__recv__val[1] ),
    .send__msg( route_units__send__msg[1] ),
    .send__rdy( route_units__send__rdy[1] ),
    .send__val( route_units__send__val[1] )
  );

  XbarRouteUnitRTL__b4ff6020003d1be0 route_units__2
  (
    .clk( route_units__clk[2] ),
    .reset( route_units__reset[2] ),
    .recv__msg( route_units__recv__msg[2] ),
    .recv__rdy( route_units__recv__rdy[2] ),
    .recv__val( route_units__recv__val[2] ),
    .send__msg( route_units__send__msg[2] ),
    .send__rdy( route_units__send__rdy[2] ),
    .send__val( route_units__send__val[2] )
  );

  XbarRouteUnitRTL__b4ff6020003d1be0 route_units__3
  (
    .clk( route_units__clk[3] ),
    .reset( route_units__reset[3] ),
    .recv__msg( route_units__recv__msg[3] ),
    .recv__rdy( route_units__recv__rdy[3] ),
    .recv__val( route_units__recv__val[3] ),
    .send__msg( route_units__send__msg[3] ),
    .send__rdy( route_units__send__rdy[3] ),
    .send__val( route_units__send__val[3] )
  );

  XbarRouteUnitRTL__b4ff6020003d1be0 route_units__4
  (
    .clk( route_units__clk[4] ),
    .reset( route_units__reset[4] ),
    .recv__msg( route_units__recv__msg[4] ),
    .recv__rdy( route_units__recv__rdy[4] ),
    .recv__val( route_units__recv__val[4] ),
    .send__msg( route_units__send__msg[4] ),
    .send__rdy( route_units__send__rdy[4] ),
    .send__val( route_units__send__val[4] )
  );

  XbarRouteUnitRTL__b4ff6020003d1be0 route_units__5
  (
    .clk( route_units__clk[5] ),
    .reset( route_units__reset[5] ),
    .recv__msg( route_units__recv__msg[5] ),
    .recv__rdy( route_units__recv__rdy[5] ),
    .recv__val( route_units__recv__val[5] ),
    .send__msg( route_units__send__msg[5] ),
    .send__rdy( route_units__send__rdy[5] ),
    .send__val( route_units__send__val[5] )
  );

  //-------------------------------------------------------------
  // End of component route_units[0:5]
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component switch_units[0:0]
  //-------------------------------------------------------------

  logic [0:0] switch_units__clk [0:0];
  logic [0:0] switch_units__reset [0:0];
  ControllerNocXbarPacket_InterCgraPktType__f1a81b7e6c97120c switch_units__recv__msg [0:0][0:5];
  logic [0:0] switch_units__recv__rdy [0:0][0:5];
  logic [0:0] switch_units__recv__val [0:0][0:5];
  ControllerNocXbarPacket_InterCgraPktType__f1a81b7e6c97120c switch_units__send__msg [0:0];
  logic [0:0] switch_units__send__rdy [0:0];
  logic [0:0] switch_units__send__val [0:0];

  SwitchUnitRTL__80ba1a3063bf34da switch_units__0
  (
    .clk( switch_units__clk[0] ),
    .reset( switch_units__reset[0] ),
    .recv__msg( switch_units__recv__msg[0] ),
    .recv__rdy( switch_units__recv__rdy[0] ),
    .recv__val( switch_units__recv__val[0] ),
    .send__msg( switch_units__send__msg[0] ),
    .send__rdy( switch_units__send__rdy[0] ),
    .send__val( switch_units__send__val[0] )
  );

  //-------------------------------------------------------------
  // End of component switch_units[0:0]
  //-------------------------------------------------------------

  assign input_units__clk[0] = clk;
  assign input_units__reset[0] = reset;
  assign input_units__clk[1] = clk;
  assign input_units__reset[1] = reset;
  assign input_units__clk[2] = clk;
  assign input_units__reset[2] = reset;
  assign input_units__clk[3] = clk;
  assign input_units__reset[3] = reset;
  assign input_units__clk[4] = clk;
  assign input_units__reset[4] = reset;
  assign input_units__clk[5] = clk;
  assign input_units__reset[5] = reset;
  assign route_units__clk[0] = clk;
  assign route_units__reset[0] = reset;
  assign route_units__clk[1] = clk;
  assign route_units__reset[1] = reset;
  assign route_units__clk[2] = clk;
  assign route_units__reset[2] = reset;
  assign route_units__clk[3] = clk;
  assign route_units__reset[3] = reset;
  assign route_units__clk[4] = clk;
  assign route_units__reset[4] = reset;
  assign route_units__clk[5] = clk;
  assign route_units__reset[5] = reset;
  assign switch_units__clk[0] = clk;
  assign switch_units__reset[0] = reset;
  assign output_units__clk[0] = clk;
  assign output_units__reset[0] = reset;
  assign input_units__recv__msg[0] = recv__msg[0];
  assign recv__rdy[0] = input_units__recv__rdy[0];
  assign input_units__recv__val[0] = recv__val[0];
  assign route_units__recv__msg[0] = input_units__send__msg[0];
  assign input_units__send__rdy[0] = route_units__recv__rdy[0];
  assign route_units__recv__val[0] = input_units__send__val[0];
  assign input_units__recv__msg[1] = recv__msg[1];
  assign recv__rdy[1] = input_units__recv__rdy[1];
  assign input_units__recv__val[1] = recv__val[1];
  assign route_units__recv__msg[1] = input_units__send__msg[1];
  assign input_units__send__rdy[1] = route_units__recv__rdy[1];
  assign route_units__recv__val[1] = input_units__send__val[1];
  assign input_units__recv__msg[2] = recv__msg[2];
  assign recv__rdy[2] = input_units__recv__rdy[2];
  assign input_units__recv__val[2] = recv__val[2];
  assign route_units__recv__msg[2] = input_units__send__msg[2];
  assign input_units__send__rdy[2] = route_units__recv__rdy[2];
  assign route_units__recv__val[2] = input_units__send__val[2];
  assign input_units__recv__msg[3] = recv__msg[3];
  assign recv__rdy[3] = input_units__recv__rdy[3];
  assign input_units__recv__val[3] = recv__val[3];
  assign route_units__recv__msg[3] = input_units__send__msg[3];
  assign input_units__send__rdy[3] = route_units__recv__rdy[3];
  assign route_units__recv__val[3] = input_units__send__val[3];
  assign input_units__recv__msg[4] = recv__msg[4];
  assign recv__rdy[4] = input_units__recv__rdy[4];
  assign input_units__recv__val[4] = recv__val[4];
  assign route_units__recv__msg[4] = input_units__send__msg[4];
  assign input_units__send__rdy[4] = route_units__recv__rdy[4];
  assign route_units__recv__val[4] = input_units__send__val[4];
  assign input_units__recv__msg[5] = recv__msg[5];
  assign recv__rdy[5] = input_units__recv__rdy[5];
  assign input_units__recv__val[5] = recv__val[5];
  assign route_units__recv__msg[5] = input_units__send__msg[5];
  assign input_units__send__rdy[5] = route_units__recv__rdy[5];
  assign route_units__recv__val[5] = input_units__send__val[5];
  assign switch_units__recv__msg[0][0] = route_units__send__msg[0][0];
  assign route_units__send__rdy[0][0] = switch_units__recv__rdy[0][0];
  assign switch_units__recv__val[0][0] = route_units__send__val[0][0];
  assign switch_units__recv__msg[0][1] = route_units__send__msg[1][0];
  assign route_units__send__rdy[1][0] = switch_units__recv__rdy[0][1];
  assign switch_units__recv__val[0][1] = route_units__send__val[1][0];
  assign switch_units__recv__msg[0][2] = route_units__send__msg[2][0];
  assign route_units__send__rdy[2][0] = switch_units__recv__rdy[0][2];
  assign switch_units__recv__val[0][2] = route_units__send__val[2][0];
  assign switch_units__recv__msg[0][3] = route_units__send__msg[3][0];
  assign route_units__send__rdy[3][0] = switch_units__recv__rdy[0][3];
  assign switch_units__recv__val[0][3] = route_units__send__val[3][0];
  assign switch_units__recv__msg[0][4] = route_units__send__msg[4][0];
  assign route_units__send__rdy[4][0] = switch_units__recv__rdy[0][4];
  assign switch_units__recv__val[0][4] = route_units__send__val[4][0];
  assign switch_units__recv__msg[0][5] = route_units__send__msg[5][0];
  assign route_units__send__rdy[5][0] = switch_units__recv__rdy[0][5];
  assign switch_units__recv__val[0][5] = route_units__send__val[5][0];
  assign output_units__recv__msg[0] = switch_units__send__msg[0];
  assign switch_units__send__rdy[0] = output_units__recv__rdy[0];
  assign output_units__recv__val[0] = switch_units__send__val[0];
  assign send__msg[0] = output_units__send__msg[0];
  assign output_units__send__rdy[0] = send__rdy[0];
  assign send__val[0] = output_units__send__val[0];

endmodule


// PyMTL Component NormalQueueCtrlRTL Definition
// At /cgra/VectorCGRA/lib/basic/val_rdy/queues.py

module NormalQueueCtrlRTL__num_entries_16
(
  input  logic [0:0] clk ,
  output logic [4:0] count ,
  output logic [3:0] raddr ,
  output logic [0:0] recv_rdy ,
  input  logic [0:0] recv_val ,
  input  logic [0:0] reset ,
  input  logic [0:0] send_rdy ,
  output logic [0:0] send_val ,
  output logic [3:0] waddr ,
  output logic [0:0] wen 
);
  localparam logic [4:0] __const__num_entries_at__lambda__s_dut_controller_global_reduce_unit_queue_ctrl_recv_rdy  = 5'd16;
  localparam logic [4:0] __const__num_entries_at_up_reg  = 5'd16;
  logic [3:0] head;
  logic [0:0] recv_xfer;
  logic [0:0] send_xfer;
  logic [3:0] tail;

  // PyMTL Lambda Block Source
  // At /cgra/VectorCGRA/lib/basic/val_rdy/queues.py:121
  // s.recv_rdy  //= lambda: s.count < num_entries
  
  always_comb begin : _lambda__s_dut_controller_global_reduce_unit_queue_ctrl_recv_rdy
    recv_rdy = count < 5'( __const__num_entries_at__lambda__s_dut_controller_global_reduce_unit_queue_ctrl_recv_rdy );
  end

  // PyMTL Lambda Block Source
  // At /cgra/VectorCGRA/lib/basic/val_rdy/queues.py:124
  // s.recv_xfer //= lambda: s.recv_val & s.recv_rdy
  
  always_comb begin : _lambda__s_dut_controller_global_reduce_unit_queue_ctrl_recv_xfer
    recv_xfer = recv_val & recv_rdy;
  end

  // PyMTL Lambda Block Source
  // At /cgra/VectorCGRA/lib/basic/val_rdy/queues.py:122
  // s.send_val  //= lambda: s.count > 0
  
  always_comb begin : _lambda__s_dut_controller_global_reduce_unit_queue_ctrl_send_val
    send_val = count > 5'd0;
  end

  // PyMTL Lambda Block Source
  // At /cgra/VectorCGRA/lib/basic/val_rdy/queues.py:125
  // s.send_xfer //= lambda: s.send_val & s.send_rdy
  
  always_comb begin : _lambda__s_dut_controller_global_reduce_unit_queue_ctrl_send_xfer
    send_xfer = send_val & send_rdy;
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/lib/basic/val_rdy/queues.py:127
  // @update_ff
  // def up_reg():
  // 
  //   if s.reset:
  //     s.head  <<= 0
  //     s.tail  <<= 0
  //     s.count <<= 0
  // 
  //   else:
  //     if s.recv_xfer:
  //       s.tail <<= s.tail + 1 if ( s.tail < num_entries - 1 ) else 0
  // 
  //     if s.send_xfer:
  //       s.head <<= s.head + 1 if ( s.head < num_entries -1 ) else 0
  // 
  //     if s.recv_xfer & ~s.send_xfer:
  //       s.count <<= s.count + 1
  //     elif ~s.recv_xfer & s.send_xfer:
  //       s.count <<= s.count - 1
  
  always_ff @(posedge clk) begin : up_reg
    if ( reset ) begin
      head <= 4'd0;
      tail <= 4'd0;
      count <= 5'd0;
    end
    else begin
      if ( recv_xfer ) begin
        tail <= ( tail < ( 4'( __const__num_entries_at_up_reg ) - 4'd1 ) ) ? tail + 4'd1 : 4'd0;
      end
      if ( send_xfer ) begin
        head <= ( head < ( 4'( __const__num_entries_at_up_reg ) - 4'd1 ) ) ? head + 4'd1 : 4'd0;
      end
      if ( recv_xfer & ( ~send_xfer ) ) begin
        count <= count + 5'd1;
      end
      else if ( ( ~recv_xfer ) & send_xfer ) begin
        count <= count - 5'd1;
      end
    end
  end

  assign wen = recv_xfer;
  assign waddr = tail;
  assign raddr = head;

endmodule


// PyMTL Component RegisterFile Definition
// Full name: RegisterFile__Type_InterCgraPacket_4_4x1_4_8_4_CgraPayload__9d404f857a1e94ff__nregs_16__rd_ports_1__wr_ports_1__const_zero_False
// At /cgra/venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/register_files.py

module RegisterFile__660559ed7d54723d
(
  input  logic [0:0] clk ,
  input  logic [3:0] raddr [0:0],
  output InterCgraPacket_4_4x1_4_8_4_CgraPayload__9d404f857a1e94ff rdata [0:0],
  input  logic [0:0] reset ,
  input  logic [3:0] waddr [0:0],
  input  InterCgraPacket_4_4x1_4_8_4_CgraPayload__9d404f857a1e94ff wdata [0:0],
  input  logic [0:0] wen [0:0]
);
  localparam logic [0:0] __const__rd_ports_at_up_rf_read  = 1'd1;
  localparam logic [0:0] __const__wr_ports_at_up_rf_write  = 1'd1;
  InterCgraPacket_4_4x1_4_8_4_CgraPayload__9d404f857a1e94ff regs [0:15];

  // PyMTL Update Block Source
  // At /cgra/venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/register_files.py:20
  // @update
  // def up_rf_read():
  //   for i in range( rd_ports ):
  //     s.rdata[i] @= s.regs[ s.raddr[i] ]
  
  always_comb begin : up_rf_read
    for ( int unsigned i = 1'd0; i < 1'( __const__rd_ports_at_up_rf_read ); i += 1'd1 )
      rdata[1'(i)] = regs[raddr[1'(i)]];
  end

  // PyMTL Update Block Source
  // At /cgra/venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/register_files.py:32
  // @update_ff
  // def up_rf_write():
  //   for i in range( wr_ports ):
  //     if s.wen[i]:
  //       s.regs[ s.waddr[i] ] <<= s.wdata[i]
  
  always_ff @(posedge clk) begin : up_rf_write
    for ( int unsigned i = 1'd0; i < 1'( __const__wr_ports_at_up_rf_write ); i += 1'd1 )
      if ( wen[1'(i)] ) begin
        regs[waddr[1'(i)]] <= wdata[1'(i)];
      end
  end

endmodule


// PyMTL Component NormalQueueDpathRTL Definition
// Full name: NormalQueueDpathRTL__EntryType_InterCgraPacket_4_4x1_4_8_4_CgraPayload__9d404f857a1e94ff__num_entries_16
// At /cgra/VectorCGRA/lib/basic/val_rdy/queues.py

module NormalQueueDpathRTL__9de49ef9972cf984
(
  input  logic [0:0] clk ,
  input  logic [3:0] raddr ,
  input  InterCgraPacket_4_4x1_4_8_4_CgraPayload__9d404f857a1e94ff recv_msg ,
  input  logic [0:0] reset ,
  output InterCgraPacket_4_4x1_4_8_4_CgraPayload__9d404f857a1e94ff send_msg ,
  input  logic [3:0] waddr ,
  input  logic [0:0] wen 
);
  //-------------------------------------------------------------
  // Component rf
  //-------------------------------------------------------------

  logic [0:0] rf__clk;
  logic [3:0] rf__raddr [0:0];
  InterCgraPacket_4_4x1_4_8_4_CgraPayload__9d404f857a1e94ff rf__rdata [0:0];
  logic [0:0] rf__reset;
  logic [3:0] rf__waddr [0:0];
  InterCgraPacket_4_4x1_4_8_4_CgraPayload__9d404f857a1e94ff rf__wdata [0:0];
  logic [0:0] rf__wen [0:0];

  RegisterFile__660559ed7d54723d rf
  (
    .clk( rf__clk ),
    .raddr( rf__raddr ),
    .rdata( rf__rdata ),
    .reset( rf__reset ),
    .waddr( rf__waddr ),
    .wdata( rf__wdata ),
    .wen( rf__wen )
  );

  //-------------------------------------------------------------
  // End of component rf
  //-------------------------------------------------------------

  assign rf__clk = clk;
  assign rf__reset = reset;
  assign rf__raddr[0] = raddr;
  assign send_msg = rf__rdata[0];
  assign rf__wen[0] = wen;
  assign rf__waddr[0] = waddr;
  assign rf__wdata[0] = recv_msg;

endmodule


// PyMTL Component NormalQueueRTL Definition
// Full name: NormalQueueRTL__EntryType_InterCgraPacket_4_4x1_4_8_4_CgraPayload__9d404f857a1e94ff__num_entries_16
// At /cgra/VectorCGRA/lib/basic/val_rdy/queues.py

module NormalQueueRTL__9de49ef9972cf984
(
  input  logic [0:0] clk ,
  output logic [4:0] count ,
  input  logic [0:0] reset ,
  input InterCgraPacket_4_4x1_4_8_4_CgraPayload__9d404f857a1e94ff recv__msg  ,
  output logic [0:0] recv__rdy  ,
  input logic [0:0] recv__val  ,
  output InterCgraPacket_4_4x1_4_8_4_CgraPayload__9d404f857a1e94ff send__msg  ,
  input logic [0:0] send__rdy  ,
  output logic [0:0] send__val  
);
  //-------------------------------------------------------------
  // Component ctrl
  //-------------------------------------------------------------

  logic [0:0] ctrl__clk;
  logic [4:0] ctrl__count;
  logic [3:0] ctrl__raddr;
  logic [0:0] ctrl__recv_rdy;
  logic [0:0] ctrl__recv_val;
  logic [0:0] ctrl__reset;
  logic [0:0] ctrl__send_rdy;
  logic [0:0] ctrl__send_val;
  logic [3:0] ctrl__waddr;
  logic [0:0] ctrl__wen;

  NormalQueueCtrlRTL__num_entries_16 ctrl
  (
    .clk( ctrl__clk ),
    .count( ctrl__count ),
    .raddr( ctrl__raddr ),
    .recv_rdy( ctrl__recv_rdy ),
    .recv_val( ctrl__recv_val ),
    .reset( ctrl__reset ),
    .send_rdy( ctrl__send_rdy ),
    .send_val( ctrl__send_val ),
    .waddr( ctrl__waddr ),
    .wen( ctrl__wen )
  );

  //-------------------------------------------------------------
  // End of component ctrl
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component dpath
  //-------------------------------------------------------------

  logic [0:0] dpath__clk;
  logic [3:0] dpath__raddr;
  InterCgraPacket_4_4x1_4_8_4_CgraPayload__9d404f857a1e94ff dpath__recv_msg;
  logic [0:0] dpath__reset;
  InterCgraPacket_4_4x1_4_8_4_CgraPayload__9d404f857a1e94ff dpath__send_msg;
  logic [3:0] dpath__waddr;
  logic [0:0] dpath__wen;

  NormalQueueDpathRTL__9de49ef9972cf984 dpath
  (
    .clk( dpath__clk ),
    .raddr( dpath__raddr ),
    .recv_msg( dpath__recv_msg ),
    .reset( dpath__reset ),
    .send_msg( dpath__send_msg ),
    .waddr( dpath__waddr ),
    .wen( dpath__wen )
  );

  //-------------------------------------------------------------
  // End of component dpath
  //-------------------------------------------------------------

  assign ctrl__clk = clk;
  assign ctrl__reset = reset;
  assign dpath__clk = clk;
  assign dpath__reset = reset;
  assign dpath__wen = ctrl__wen;
  assign dpath__waddr = ctrl__waddr;
  assign dpath__raddr = ctrl__raddr;
  assign ctrl__recv_val = recv__val;
  assign recv__rdy = ctrl__recv_rdy;
  assign dpath__recv_msg = recv__msg;
  assign send__val = ctrl__send_val;
  assign ctrl__send_rdy = send__rdy;
  assign send__msg = dpath__send_msg;
  assign count = ctrl__count;

endmodule


// PyMTL Component GlobalReduceUnitRTL Definition
// Full name: GlobalReduceUnitRTL__InterCgraPktType_InterCgraPacket_4_4x1_4_8_4_CgraPayload__9d404f857a1e94ff
// At /cgra/VectorCGRA/controller/GlobalReduceUnitRTL.py

module GlobalReduceUnitRTL__a68241ebe958efcc
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input InterCgraPacket_4_4x1_4_8_4_CgraPayload__9d404f857a1e94ff recv_count__msg  ,
  output logic [0:0] recv_count__rdy  ,
  input logic [0:0] recv_count__val  ,
  input InterCgraPacket_4_4x1_4_8_4_CgraPayload__9d404f857a1e94ff recv_data__msg  ,
  output logic [0:0] recv_data__rdy  ,
  input logic [0:0] recv_data__val  ,
  output ControllerNocXbarPacket_InterCgraPktType__f1a81b7e6c97120c send__msg  ,
  input logic [0:0] send__rdy  ,
  output logic [0:0] send__val  
);
  localparam logic [4:0] __const__CMD_GLOBAL_REDUCE_ADD  = 5'd18;
  localparam logic [4:0] __const__CMD_GLOBAL_REDUCE_ADD_RESPONSE  = 5'd20;
  localparam logic [4:0] __const__CMD_GLOBAL_REDUCE_MUL  = 5'd19;
  localparam logic [4:0] __const__CMD_GLOBAL_REDUCE_MUL_RESPONSE  = 5'd21;
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 receiving_count;
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 reduce_add_value;
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 reduce_mul_value;
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 sending_count;
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 target_count;
  //-------------------------------------------------------------
  // Component queue
  //-------------------------------------------------------------

  logic [0:0] queue__clk;
  logic [4:0] queue__count;
  logic [0:0] queue__reset;
  InterCgraPacket_4_4x1_4_8_4_CgraPayload__9d404f857a1e94ff queue__recv__msg;
  logic [0:0] queue__recv__rdy;
  logic [0:0] queue__recv__val;
  InterCgraPacket_4_4x1_4_8_4_CgraPayload__9d404f857a1e94ff queue__send__msg;
  logic [0:0] queue__send__rdy;
  logic [0:0] queue__send__val;

  NormalQueueRTL__9de49ef9972cf984 queue
  (
    .clk( queue__clk ),
    .count( queue__count ),
    .reset( queue__reset ),
    .recv__msg( queue__recv__msg ),
    .recv__rdy( queue__recv__rdy ),
    .recv__val( queue__recv__val ),
    .send__msg( queue__send__msg ),
    .send__rdy( queue__send__rdy ),
    .send__val( queue__send__val )
  );

  //-------------------------------------------------------------
  // End of component queue
  //-------------------------------------------------------------

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/controller/GlobalReduceUnitRTL.py:45
  // @update
  // def set_recv_rdy():
  //   s.recv_data.rdy @= 0
  //   s.queue.recv.val @= 0
  //   s.queue.recv.msg @= InterCgraPktType(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
  //   if s.target_count.payload > s.receiving_count.payload:
  //     s.recv_data.rdy @= s.queue.recv.rdy
  //     s.queue.recv.msg @= s.recv_data.msg
  //     s.queue.recv.val @= s.recv_data.val
  
  always_comb begin : set_recv_rdy
    recv_data__rdy = 1'd0;
    queue__recv__val = 1'd0;
    queue__recv__msg = { 2'd0, 2'd0, 2'd0, 1'd0, 2'd0, 1'd0, 3'd0, 3'd0, 2'd0, 8'd0, 2'd0, 191'd0 };
    if ( target_count.payload > receiving_count.payload ) begin
      recv_data__rdy = queue__recv__rdy;
      queue__recv__msg = recv_data__msg;
      queue__recv__val = recv_data__val;
    end
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/controller/GlobalReduceUnitRTL.py:74
  // @update
  // def update_send():
  //   s.send.msg @= ControllerXbarPktType(0, 0)
  //   s.send.val @= 0
  //   s.queue.send.rdy @= 0
  //   if (s.target_count.payload > 0) & (s.receiving_count.payload == s.target_count.payload):
  //     # Updates the cmd type, result value, and src/dst.
  //     if s.queue.send.msg.payload.cmd == CMD_GLOBAL_REDUCE_ADD:
  //       s.send.msg.inter_cgra_pkt.payload.cmd @= CMD_GLOBAL_REDUCE_ADD_RESPONSE
  //       s.send.msg.inter_cgra_pkt.payload.data @= s.reduce_add_value
  //     elif s.queue.send.msg.payload.cmd == CMD_GLOBAL_REDUCE_MUL:
  //       s.send.msg.inter_cgra_pkt.payload.cmd @= CMD_GLOBAL_REDUCE_MUL_RESPONSE
  //       s.send.msg.inter_cgra_pkt.payload.data @= s.reduce_mul_value
  //     s.send.msg.inter_cgra_pkt.src @= s.queue.send.msg.dst
  //     s.send.msg.inter_cgra_pkt.dst @= s.queue.send.msg.src
  //     s.send.msg.inter_cgra_pkt.src_x @= s.queue.send.msg.dst_x
  //     s.send.msg.inter_cgra_pkt.src_y @= s.queue.send.msg.dst_y
  //     s.send.msg.inter_cgra_pkt.dst_x @= s.queue.send.msg.src_x
  //     s.send.msg.inter_cgra_pkt.dst_y @= s.queue.send.msg.src_y
  //     s.send.msg.inter_cgra_pkt.src_tile_id @= s.queue.send.msg.dst_tile_id
  //     s.send.msg.inter_cgra_pkt.dst_tile_id @= s.queue.send.msg.src_tile_id
  //     s.queue.send.rdy @= s.send.rdy
  //     s.send.val @= s.queue.send.val
  
  always_comb begin : update_send
    send__msg = { 1'd0, 219'd0 };
    send__val = 1'd0;
    queue__send__rdy = 1'd0;
    if ( ( target_count.payload > 32'd0 ) & ( receiving_count.payload == target_count.payload ) ) begin
      if ( queue__send__msg.payload.cmd == 5'( __const__CMD_GLOBAL_REDUCE_ADD ) ) begin
        send__msg.inter_cgra_pkt.payload.cmd = 5'( __const__CMD_GLOBAL_REDUCE_ADD_RESPONSE );
        send__msg.inter_cgra_pkt.payload.data = reduce_add_value;
      end
      else if ( queue__send__msg.payload.cmd == 5'( __const__CMD_GLOBAL_REDUCE_MUL ) ) begin
        send__msg.inter_cgra_pkt.payload.cmd = 5'( __const__CMD_GLOBAL_REDUCE_MUL_RESPONSE );
        send__msg.inter_cgra_pkt.payload.data = reduce_mul_value;
      end
      send__msg.inter_cgra_pkt.src = queue__send__msg.dst;
      send__msg.inter_cgra_pkt.dst = queue__send__msg.src;
      send__msg.inter_cgra_pkt.src_x = queue__send__msg.dst_x;
      send__msg.inter_cgra_pkt.src_y = queue__send__msg.dst_y;
      send__msg.inter_cgra_pkt.dst_x = queue__send__msg.src_x;
      send__msg.inter_cgra_pkt.dst_y = queue__send__msg.src_y;
      send__msg.inter_cgra_pkt.src_tile_id = queue__send__msg.dst_tile_id;
      send__msg.inter_cgra_pkt.dst_tile_id = queue__send__msg.src_tile_id;
      queue__send__rdy = send__rdy;
      send__val = queue__send__val;
    end
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/controller/GlobalReduceUnitRTL.py:98
  // @update_ff
  // def accumulate_value():
  //   if s.reset | (s.sending_count == s.target_count):
  //     s.reduce_add_value <<= DataType(0, 0, 0, 0)
  //     s.reduce_mul_value <<= DataType(1, 0, 0, 0)
  //   else:
  //     if s.recv_data.val & \
  //        s.recv_data.rdy:
  //       if s.recv_data.msg.payload.cmd == CMD_GLOBAL_REDUCE_ADD:
  //         s.reduce_add_value <<= DataType(s.reduce_add_value.payload + s.recv_data.msg.payload.data.payload,
  //                                         s.recv_data.msg.payload.data.predicate,
  //                                         0,
  //                                         0)
  //       elif s.recv_data.msg.payload.cmd == CMD_GLOBAL_REDUCE_MUL:
  //         s.reduce_mul_value <<= DataType(s.reduce_mul_value.payload * s.recv_data.msg.payload.data.payload,
  //                                         s.recv_data.msg.payload.data.predicate,
  //                                         0,
  //                                         0)
  
  always_ff @(posedge clk) begin : accumulate_value
    if ( reset | ( sending_count == target_count ) ) begin
      reduce_add_value <= { 32'd0, 1'd0, 1'd0, 1'd0 };
      reduce_mul_value <= { 32'd1, 1'd0, 1'd0, 1'd0 };
    end
    else if ( recv_data__val & recv_data__rdy ) begin
      if ( recv_data__msg.payload.cmd == 5'( __const__CMD_GLOBAL_REDUCE_ADD ) ) begin
        reduce_add_value <= { reduce_add_value.payload + recv_data__msg.payload.data.payload, recv_data__msg.payload.data.predicate, 1'd0, 1'd0 };
      end
      else if ( recv_data__msg.payload.cmd == 5'( __const__CMD_GLOBAL_REDUCE_MUL ) ) begin
        reduce_mul_value <= { reduce_mul_value.payload * recv_data__msg.payload.data.payload, recv_data__msg.payload.data.predicate, 1'd0, 1'd0 };
      end
    end
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/controller/GlobalReduceUnitRTL.py:55
  // @update_ff
  // def update_count():
  //   if s.reset:
  //     s.target_count <<= DataType(0, 0, 0, 0)
  //     s.receiving_count <<= DataType(0, 0, 0, 0)
  //     s.sending_count <<= DataType(0, 0, 0, 0)
  //   else:
  //     if s.recv_count.val & s.recv_count.rdy:
  //       s.target_count <<= DataType(s.recv_count.msg.payload.data.payload, 0, 0, 0)
  //     if s.recv_data.val & s.recv_data.rdy:
  //       s.receiving_count <<= DataType(s.receiving_count.payload + 1, 0, 0, 0)
  //     if s.send.rdy & s.send.val:
  //       s.sending_count <<= DataType(s.sending_count.payload + 1, 0, 0, 0)
  //     elif (s.sending_count == s.receiving_count) & \
  //          (s.sending_count == s.target_count) & \
  //          (s.target_count.payload > 0):
  //       s.sending_count <<= DataType(0, 0, 0, 0)
  //       s.receiving_count <<= DataType(0, 0, 0, 0)
  
  always_ff @(posedge clk) begin : update_count
    if ( reset ) begin
      target_count <= { 32'd0, 1'd0, 1'd0, 1'd0 };
      receiving_count <= { 32'd0, 1'd0, 1'd0, 1'd0 };
      sending_count <= { 32'd0, 1'd0, 1'd0, 1'd0 };
    end
    else begin
      if ( recv_count__val & recv_count__rdy ) begin
        target_count <= { recv_count__msg.payload.data.payload, 1'd0, 1'd0, 1'd0 };
      end
      if ( recv_data__val & recv_data__rdy ) begin
        receiving_count <= { receiving_count.payload + 32'd1, 1'd0, 1'd0, 1'd0 };
      end
      if ( send__rdy & send__val ) begin
        sending_count <= { sending_count.payload + 32'd1, 1'd0, 1'd0, 1'd0 };
      end
      else if ( ( ( sending_count == receiving_count ) & ( sending_count == target_count ) ) & ( target_count.payload > 32'd0 ) ) begin
        sending_count <= { 32'd0, 1'd0, 1'd0, 1'd0 };
        receiving_count <= { 32'd0, 1'd0, 1'd0, 1'd0 };
      end
    end
  end

  assign queue__clk = clk;
  assign queue__reset = reset;
  assign recv_count__rdy = 1'd1;

endmodule


// PyMTL Component RegisterFile Definition
// Full name: RegisterFile__Type_IntraCgraPacket_4_4x1_4_8_2_CgraPayload__11cd3f8c0d91825c__nregs_2__rd_ports_1__wr_ports_1__const_zero_False
// At /cgra/venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/register_files.py

module RegisterFile__c97a00dce3981e0a
(
  input  logic [0:0] clk ,
  input  logic [0:0] raddr [0:0],
  output IntraCgraPacket_4_4x1_4_8_2_CgraPayload__11cd3f8c0d91825c rdata [0:0],
  input  logic [0:0] reset ,
  input  logic [0:0] waddr [0:0],
  input  IntraCgraPacket_4_4x1_4_8_2_CgraPayload__11cd3f8c0d91825c wdata [0:0],
  input  logic [0:0] wen [0:0]
);
  localparam logic [0:0] __const__rd_ports_at_up_rf_read  = 1'd1;
  localparam logic [0:0] __const__wr_ports_at_up_rf_write  = 1'd1;
  IntraCgraPacket_4_4x1_4_8_2_CgraPayload__11cd3f8c0d91825c regs [0:1];

  // PyMTL Update Block Source
  // At /cgra/venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/register_files.py:20
  // @update
  // def up_rf_read():
  //   for i in range( rd_ports ):
  //     s.rdata[i] @= s.regs[ s.raddr[i] ]
  
  always_comb begin : up_rf_read
    for ( int unsigned i = 1'd0; i < 1'( __const__rd_ports_at_up_rf_read ); i += 1'd1 )
      rdata[1'(i)] = regs[raddr[1'(i)]];
  end

  // PyMTL Update Block Source
  // At /cgra/venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/register_files.py:32
  // @update_ff
  // def up_rf_write():
  //   for i in range( wr_ports ):
  //     if s.wen[i]:
  //       s.regs[ s.waddr[i] ] <<= s.wdata[i]
  
  always_ff @(posedge clk) begin : up_rf_write
    for ( int unsigned i = 1'd0; i < 1'( __const__wr_ports_at_up_rf_write ); i += 1'd1 )
      if ( wen[1'(i)] ) begin
        regs[waddr[1'(i)]] <= wdata[1'(i)];
      end
  end

endmodule


// PyMTL Component NormalQueueDpathRTL Definition
// Full name: NormalQueueDpathRTL__EntryType_IntraCgraPacket_4_4x1_4_8_2_CgraPayload__11cd3f8c0d91825c__num_entries_2
// At /cgra/VectorCGRA/lib/basic/val_rdy/queues.py

module NormalQueueDpathRTL__4d91d5ee0229de22
(
  input  logic [0:0] clk ,
  input  logic [0:0] raddr ,
  input  IntraCgraPacket_4_4x1_4_8_2_CgraPayload__11cd3f8c0d91825c recv_msg ,
  input  logic [0:0] reset ,
  output IntraCgraPacket_4_4x1_4_8_2_CgraPayload__11cd3f8c0d91825c send_msg ,
  input  logic [0:0] waddr ,
  input  logic [0:0] wen 
);
  //-------------------------------------------------------------
  // Component rf
  //-------------------------------------------------------------

  logic [0:0] rf__clk;
  logic [0:0] rf__raddr [0:0];
  IntraCgraPacket_4_4x1_4_8_2_CgraPayload__11cd3f8c0d91825c rf__rdata [0:0];
  logic [0:0] rf__reset;
  logic [0:0] rf__waddr [0:0];
  IntraCgraPacket_4_4x1_4_8_2_CgraPayload__11cd3f8c0d91825c rf__wdata [0:0];
  logic [0:0] rf__wen [0:0];

  RegisterFile__c97a00dce3981e0a rf
  (
    .clk( rf__clk ),
    .raddr( rf__raddr ),
    .rdata( rf__rdata ),
    .reset( rf__reset ),
    .waddr( rf__waddr ),
    .wdata( rf__wdata ),
    .wen( rf__wen )
  );

  //-------------------------------------------------------------
  // End of component rf
  //-------------------------------------------------------------

  assign rf__clk = clk;
  assign rf__reset = reset;
  assign rf__raddr[0] = raddr;
  assign send_msg = rf__rdata[0];
  assign rf__wen[0] = wen;
  assign rf__waddr[0] = waddr;
  assign rf__wdata[0] = recv_msg;

endmodule


// PyMTL Component NormalQueueRTL Definition
// Full name: NormalQueueRTL__EntryType_IntraCgraPacket_4_4x1_4_8_2_CgraPayload__11cd3f8c0d91825c__num_entries_2
// At /cgra/VectorCGRA/lib/basic/val_rdy/queues.py

module NormalQueueRTL__4d91d5ee0229de22
(
  input  logic [0:0] clk ,
  output logic [1:0] count ,
  input  logic [0:0] reset ,
  input IntraCgraPacket_4_4x1_4_8_2_CgraPayload__11cd3f8c0d91825c recv__msg  ,
  output logic [0:0] recv__rdy  ,
  input logic [0:0] recv__val  ,
  output IntraCgraPacket_4_4x1_4_8_2_CgraPayload__11cd3f8c0d91825c send__msg  ,
  input logic [0:0] send__rdy  ,
  output logic [0:0] send__val  
);
  //-------------------------------------------------------------
  // Component ctrl
  //-------------------------------------------------------------

  logic [0:0] ctrl__clk;
  logic [1:0] ctrl__count;
  logic [0:0] ctrl__raddr;
  logic [0:0] ctrl__recv_rdy;
  logic [0:0] ctrl__recv_val;
  logic [0:0] ctrl__reset;
  logic [0:0] ctrl__send_rdy;
  logic [0:0] ctrl__send_val;
  logic [0:0] ctrl__waddr;
  logic [0:0] ctrl__wen;

  NormalQueueCtrlRTL__num_entries_2 ctrl
  (
    .clk( ctrl__clk ),
    .count( ctrl__count ),
    .raddr( ctrl__raddr ),
    .recv_rdy( ctrl__recv_rdy ),
    .recv_val( ctrl__recv_val ),
    .reset( ctrl__reset ),
    .send_rdy( ctrl__send_rdy ),
    .send_val( ctrl__send_val ),
    .waddr( ctrl__waddr ),
    .wen( ctrl__wen )
  );

  //-------------------------------------------------------------
  // End of component ctrl
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component dpath
  //-------------------------------------------------------------

  logic [0:0] dpath__clk;
  logic [0:0] dpath__raddr;
  IntraCgraPacket_4_4x1_4_8_2_CgraPayload__11cd3f8c0d91825c dpath__recv_msg;
  logic [0:0] dpath__reset;
  IntraCgraPacket_4_4x1_4_8_2_CgraPayload__11cd3f8c0d91825c dpath__send_msg;
  logic [0:0] dpath__waddr;
  logic [0:0] dpath__wen;

  NormalQueueDpathRTL__4d91d5ee0229de22 dpath
  (
    .clk( dpath__clk ),
    .raddr( dpath__raddr ),
    .recv_msg( dpath__recv_msg ),
    .reset( dpath__reset ),
    .send_msg( dpath__send_msg ),
    .waddr( dpath__waddr ),
    .wen( dpath__wen )
  );

  //-------------------------------------------------------------
  // End of component dpath
  //-------------------------------------------------------------

  assign ctrl__clk = clk;
  assign ctrl__reset = reset;
  assign dpath__clk = clk;
  assign dpath__reset = reset;
  assign dpath__wen = ctrl__wen;
  assign dpath__waddr = ctrl__waddr;
  assign dpath__raddr = ctrl__raddr;
  assign ctrl__recv_val = recv__val;
  assign recv__rdy = ctrl__recv_rdy;
  assign dpath__recv_msg = recv__msg;
  assign send__val = ctrl__send_val;
  assign ctrl__send_rdy = send__rdy;
  assign send__msg = dpath__send_msg;
  assign count = ctrl__count;

endmodule


// PyMTL Component RegisterFile Definition
// Full name: RegisterFile__Type_InterCgraPacket_4_4x1_4_8_4_CgraPayload__9d404f857a1e94ff__nregs_2__rd_ports_1__wr_ports_1__const_zero_False
// At /cgra/venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/register_files.py

module RegisterFile__88cee4889c541961
(
  input  logic [0:0] clk ,
  input  logic [0:0] raddr [0:0],
  output InterCgraPacket_4_4x1_4_8_4_CgraPayload__9d404f857a1e94ff rdata [0:0],
  input  logic [0:0] reset ,
  input  logic [0:0] waddr [0:0],
  input  InterCgraPacket_4_4x1_4_8_4_CgraPayload__9d404f857a1e94ff wdata [0:0],
  input  logic [0:0] wen [0:0]
);
  localparam logic [0:0] __const__rd_ports_at_up_rf_read  = 1'd1;
  localparam logic [0:0] __const__wr_ports_at_up_rf_write  = 1'd1;
  InterCgraPacket_4_4x1_4_8_4_CgraPayload__9d404f857a1e94ff regs [0:1];

  // PyMTL Update Block Source
  // At /cgra/venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/register_files.py:20
  // @update
  // def up_rf_read():
  //   for i in range( rd_ports ):
  //     s.rdata[i] @= s.regs[ s.raddr[i] ]
  
  always_comb begin : up_rf_read
    for ( int unsigned i = 1'd0; i < 1'( __const__rd_ports_at_up_rf_read ); i += 1'd1 )
      rdata[1'(i)] = regs[raddr[1'(i)]];
  end

  // PyMTL Update Block Source
  // At /cgra/venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/register_files.py:32
  // @update_ff
  // def up_rf_write():
  //   for i in range( wr_ports ):
  //     if s.wen[i]:
  //       s.regs[ s.waddr[i] ] <<= s.wdata[i]
  
  always_ff @(posedge clk) begin : up_rf_write
    for ( int unsigned i = 1'd0; i < 1'( __const__wr_ports_at_up_rf_write ); i += 1'd1 )
      if ( wen[1'(i)] ) begin
        regs[waddr[1'(i)]] <= wdata[1'(i)];
      end
  end

endmodule


// PyMTL Component NormalQueueDpathRTL Definition
// Full name: NormalQueueDpathRTL__EntryType_InterCgraPacket_4_4x1_4_8_4_CgraPayload__9d404f857a1e94ff__num_entries_2
// At /cgra/VectorCGRA/lib/basic/val_rdy/queues.py

module NormalQueueDpathRTL__dc5976e92cb1cf9d
(
  input  logic [0:0] clk ,
  input  logic [0:0] raddr ,
  input  InterCgraPacket_4_4x1_4_8_4_CgraPayload__9d404f857a1e94ff recv_msg ,
  input  logic [0:0] reset ,
  output InterCgraPacket_4_4x1_4_8_4_CgraPayload__9d404f857a1e94ff send_msg ,
  input  logic [0:0] waddr ,
  input  logic [0:0] wen 
);
  //-------------------------------------------------------------
  // Component rf
  //-------------------------------------------------------------

  logic [0:0] rf__clk;
  logic [0:0] rf__raddr [0:0];
  InterCgraPacket_4_4x1_4_8_4_CgraPayload__9d404f857a1e94ff rf__rdata [0:0];
  logic [0:0] rf__reset;
  logic [0:0] rf__waddr [0:0];
  InterCgraPacket_4_4x1_4_8_4_CgraPayload__9d404f857a1e94ff rf__wdata [0:0];
  logic [0:0] rf__wen [0:0];

  RegisterFile__88cee4889c541961 rf
  (
    .clk( rf__clk ),
    .raddr( rf__raddr ),
    .rdata( rf__rdata ),
    .reset( rf__reset ),
    .waddr( rf__waddr ),
    .wdata( rf__wdata ),
    .wen( rf__wen )
  );

  //-------------------------------------------------------------
  // End of component rf
  //-------------------------------------------------------------

  assign rf__clk = clk;
  assign rf__reset = reset;
  assign rf__raddr[0] = raddr;
  assign send_msg = rf__rdata[0];
  assign rf__wen[0] = wen;
  assign rf__waddr[0] = waddr;
  assign rf__wdata[0] = recv_msg;

endmodule


// PyMTL Component NormalQueueRTL Definition
// Full name: NormalQueueRTL__EntryType_InterCgraPacket_4_4x1_4_8_4_CgraPayload__9d404f857a1e94ff__num_entries_2
// At /cgra/VectorCGRA/lib/basic/val_rdy/queues.py

module NormalQueueRTL__dc5976e92cb1cf9d
(
  input  logic [0:0] clk ,
  output logic [1:0] count ,
  input  logic [0:0] reset ,
  input InterCgraPacket_4_4x1_4_8_4_CgraPayload__9d404f857a1e94ff recv__msg  ,
  output logic [0:0] recv__rdy  ,
  input logic [0:0] recv__val  ,
  output InterCgraPacket_4_4x1_4_8_4_CgraPayload__9d404f857a1e94ff send__msg  ,
  input logic [0:0] send__rdy  ,
  output logic [0:0] send__val  
);
  //-------------------------------------------------------------
  // Component ctrl
  //-------------------------------------------------------------

  logic [0:0] ctrl__clk;
  logic [1:0] ctrl__count;
  logic [0:0] ctrl__raddr;
  logic [0:0] ctrl__recv_rdy;
  logic [0:0] ctrl__recv_val;
  logic [0:0] ctrl__reset;
  logic [0:0] ctrl__send_rdy;
  logic [0:0] ctrl__send_val;
  logic [0:0] ctrl__waddr;
  logic [0:0] ctrl__wen;

  NormalQueueCtrlRTL__num_entries_2 ctrl
  (
    .clk( ctrl__clk ),
    .count( ctrl__count ),
    .raddr( ctrl__raddr ),
    .recv_rdy( ctrl__recv_rdy ),
    .recv_val( ctrl__recv_val ),
    .reset( ctrl__reset ),
    .send_rdy( ctrl__send_rdy ),
    .send_val( ctrl__send_val ),
    .waddr( ctrl__waddr ),
    .wen( ctrl__wen )
  );

  //-------------------------------------------------------------
  // End of component ctrl
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component dpath
  //-------------------------------------------------------------

  logic [0:0] dpath__clk;
  logic [0:0] dpath__raddr;
  InterCgraPacket_4_4x1_4_8_4_CgraPayload__9d404f857a1e94ff dpath__recv_msg;
  logic [0:0] dpath__reset;
  InterCgraPacket_4_4x1_4_8_4_CgraPayload__9d404f857a1e94ff dpath__send_msg;
  logic [0:0] dpath__waddr;
  logic [0:0] dpath__wen;

  NormalQueueDpathRTL__dc5976e92cb1cf9d dpath
  (
    .clk( dpath__clk ),
    .raddr( dpath__raddr ),
    .recv_msg( dpath__recv_msg ),
    .reset( dpath__reset ),
    .send_msg( dpath__send_msg ),
    .waddr( dpath__waddr ),
    .wen( dpath__wen )
  );

  //-------------------------------------------------------------
  // End of component dpath
  //-------------------------------------------------------------

  assign ctrl__clk = clk;
  assign ctrl__reset = reset;
  assign dpath__clk = clk;
  assign dpath__reset = reset;
  assign dpath__wen = ctrl__wen;
  assign dpath__waddr = ctrl__waddr;
  assign dpath__raddr = ctrl__raddr;
  assign ctrl__recv_val = recv__val;
  assign recv__rdy = ctrl__recv_rdy;
  assign dpath__recv_msg = recv__msg;
  assign send__val = ctrl__send_val;
  assign ctrl__send_rdy = send__rdy;
  assign send__msg = dpath__send_msg;
  assign count = ctrl__count;

endmodule


// PyMTL Component ChannelRTL Definition
// Full name: ChannelRTL__PacketType_InterCgraPacket_4_4x1_4_8_4_CgraPayload__9d404f857a1e94ff__QueueType_NormalQueueRTL__latency_1
// At /cgra/VectorCGRA/noc/PyOCN/pymtl3_net/channel/ChannelRTL.py

module ChannelRTL__1970d1f511171c70
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input InterCgraPacket_4_4x1_4_8_4_CgraPayload__9d404f857a1e94ff recv__msg  ,
  output logic [0:0] recv__rdy  ,
  input logic [0:0] recv__val  ,
  output InterCgraPacket_4_4x1_4_8_4_CgraPayload__9d404f857a1e94ff send__msg  ,
  input logic [0:0] send__rdy  ,
  output logic [0:0] send__val  
);
  //-------------------------------------------------------------
  // Component queues[0:0]
  //-------------------------------------------------------------

  logic [0:0] queues__clk [0:0];
  logic [1:0] queues__count [0:0];
  logic [0:0] queues__reset [0:0];
  InterCgraPacket_4_4x1_4_8_4_CgraPayload__9d404f857a1e94ff queues__recv__msg [0:0];
  logic [0:0] queues__recv__rdy [0:0];
  logic [0:0] queues__recv__val [0:0];
  InterCgraPacket_4_4x1_4_8_4_CgraPayload__9d404f857a1e94ff queues__send__msg [0:0];
  logic [0:0] queues__send__rdy [0:0];
  logic [0:0] queues__send__val [0:0];

  NormalQueueRTL__dc5976e92cb1cf9d queues__0
  (
    .clk( queues__clk[0] ),
    .count( queues__count[0] ),
    .reset( queues__reset[0] ),
    .recv__msg( queues__recv__msg[0] ),
    .recv__rdy( queues__recv__rdy[0] ),
    .recv__val( queues__recv__val[0] ),
    .send__msg( queues__send__msg[0] ),
    .send__rdy( queues__send__rdy[0] ),
    .send__val( queues__send__val[0] )
  );

  //-------------------------------------------------------------
  // End of component queues[0:0]
  //-------------------------------------------------------------

  assign queues__clk[0] = clk;
  assign queues__reset[0] = reset;
  assign queues__recv__msg[0] = recv__msg;
  assign recv__rdy = queues__recv__rdy[0];
  assign queues__recv__val[0] = recv__val;
  assign send__msg = queues__send__msg[0];
  assign queues__send__rdy[0] = send__rdy;
  assign send__val = queues__send__val[0];

endmodule


// PyMTL Component ControllerRTL Definition
// Full name: ControllerRTL__InterCgraPktType_InterCgraPacket_4_4x1_4_8_4_CgraPayload__9d404f857a1e94ff__multi_cgra_rows_1__multi_cgra_columns_4__num_tiles_4__controller2addr_map_{0: [0, 3], 1: [4, 7], 2: [8, 11], 3: [12, 15]}__idTo2d_map_{0: [0, 0], 1: [1, 0], 2: [2, 0], 3: [3, 0]}
// At /cgra/VectorCGRA/controller/ControllerRTL.py

module ControllerRTL__fa3c5e20158080fd
(
  input  logic [1:0] cgra_id ,
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input IntraCgraPacket_4_4x1_4_8_2_CgraPayload__11cd3f8c0d91825c recv_from_cpu_pkt__msg  ,
  output logic [0:0] recv_from_cpu_pkt__rdy  ,
  input logic [0:0] recv_from_cpu_pkt__val  ,
  input IntraCgraPacket_4_4x1_4_8_2_CgraPayload__11cd3f8c0d91825c recv_from_ctrl_ring_pkt__msg  ,
  output logic [0:0] recv_from_ctrl_ring_pkt__rdy  ,
  input logic [0:0] recv_from_ctrl_ring_pkt__val  ,
  input InterCgraPacket_4_4x1_4_8_4_CgraPayload__9d404f857a1e94ff recv_from_inter_cgra_noc__msg  ,
  output logic [0:0] recv_from_inter_cgra_noc__rdy  ,
  input logic [0:0] recv_from_inter_cgra_noc__val  ,
  input InterCgraPacket_4_4x1_4_8_4_CgraPayload__9d404f857a1e94ff recv_from_tile_load_request_pkt__msg  ,
  output logic [0:0] recv_from_tile_load_request_pkt__rdy  ,
  input logic [0:0] recv_from_tile_load_request_pkt__val  ,
  input InterCgraPacket_4_4x1_4_8_4_CgraPayload__9d404f857a1e94ff recv_from_tile_load_response_pkt__msg  ,
  output logic [0:0] recv_from_tile_load_response_pkt__rdy  ,
  input logic [0:0] recv_from_tile_load_response_pkt__val  ,
  input InterCgraPacket_4_4x1_4_8_4_CgraPayload__9d404f857a1e94ff recv_from_tile_store_request_pkt__msg  ,
  output logic [0:0] recv_from_tile_store_request_pkt__rdy  ,
  input logic [0:0] recv_from_tile_store_request_pkt__val  ,
  output IntraCgraPacket_4_4x1_4_8_2_CgraPayload__11cd3f8c0d91825c send_to_cpu_pkt__msg  ,
  input logic [0:0] send_to_cpu_pkt__rdy  ,
  output logic [0:0] send_to_cpu_pkt__val  ,
  output IntraCgraPacket_4_4x1_4_8_2_CgraPayload__11cd3f8c0d91825c send_to_ctrl_ring_pkt__msg  ,
  input logic [0:0] send_to_ctrl_ring_pkt__rdy  ,
  output logic [0:0] send_to_ctrl_ring_pkt__val  ,
  output InterCgraPacket_4_4x1_4_8_4_CgraPayload__9d404f857a1e94ff send_to_inter_cgra_noc__msg  ,
  input logic [0:0] send_to_inter_cgra_noc__rdy  ,
  output logic [0:0] send_to_inter_cgra_noc__val  ,
  output InterCgraPacket_4_4x1_4_8_4_CgraPayload__9d404f857a1e94ff send_to_mem_load_request__msg  ,
  input logic [0:0] send_to_mem_load_request__rdy  ,
  output logic [0:0] send_to_mem_load_request__val  ,
  output InterCgraPacket_4_4x1_4_8_4_CgraPayload__9d404f857a1e94ff send_to_mem_store_request__msg  ,
  input logic [0:0] send_to_mem_store_request__rdy  ,
  output logic [0:0] send_to_mem_store_request__val  ,
  output InterCgraPacket_4_4x1_4_8_4_CgraPayload__9d404f857a1e94ff send_to_tile_load_response__msg  ,
  input logic [0:0] send_to_tile_load_response__rdy  ,
  output logic [0:0] send_to_tile_load_response__val  
);
  localparam logic [2:0] __const__CONTROLLER_CROSSBAR_INPORTS  = 3'd6;
  localparam logic [2:0] __const__num_tiles_at_update_received_msg  = 3'd4;
  localparam logic [3:0] __const__CMD_LOAD_REQUEST  = 4'd10;
  localparam logic [3:0] __const__CMD_STORE_REQUEST  = 4'd12;
  localparam logic [3:0] __const__CMD_LOAD_RESPONSE  = 4'd11;
  localparam logic [3:0] __const__CMD_COMPLETE  = 4'd14;
  localparam logic [4:0] __const__CMD_LEAF_COUNTER_COMPLETE  = 5'd31;
  localparam logic [4:0] __const__CMD_GLOBAL_REDUCE_ADD  = 5'd18;
  localparam logic [4:0] __const__CMD_GLOBAL_REDUCE_COUNT  = 5'd17;
  localparam logic [1:0] __const__CMD_CONFIG  = 2'd3;
  localparam logic [2:0] __const__CMD_CONFIG_PROLOGUE_FU  = 3'd4;
  localparam logic [2:0] __const__CMD_CONFIG_PROLOGUE_FU_CROSSBAR  = 3'd5;
  localparam logic [2:0] __const__CMD_CONFIG_PROLOGUE_ROUTING_CROSSBAR  = 3'd6;
  localparam logic [2:0] __const__CMD_CONFIG_TOTAL_CTRL_COUNT  = 3'd7;
  localparam logic [3:0] __const__CMD_CONFIG_COUNT_PER_ITER  = 4'd8;
  localparam logic [3:0] __const__CMD_CONFIG_CTRL_LOWER_BOUND  = 4'd9;
  localparam logic [3:0] __const__CMD_CONST  = 4'd13;
  localparam logic [4:0] __const__CMD_GLOBAL_REDUCE_ADD_RESPONSE  = 5'd20;
  localparam logic [4:0] __const__CMD_GLOBAL_REDUCE_MUL_RESPONSE  = 5'd21;
  localparam logic [4:0] __const__CMD_CONFIG_STREAMING_LD_START_ADDR  = 5'd23;
  localparam logic [4:0] __const__CMD_CONFIG_STREAMING_LD_STRIDE  = 5'd24;
  localparam logic [4:0] __const__CMD_CONFIG_STREAMING_LD_END_ADDR  = 5'd25;
  localparam logic [0:0] __const__CMD_PAUSE  = 1'd1;
  localparam logic [4:0] __const__CMD_PRESERVE  = 5'd22;
  localparam logic [3:0] __const__CMD_RESUME  = 4'd15;
  localparam logic [4:0] __const__CMD_RECORD_PHI_ADDR  = 5'd16;
  localparam logic [1:0] __const__CMD_TERMINATE  = 2'd2;
  localparam logic [0:0] __const__CMD_LAUNCH  = 1'd0;
  localparam logic [4:0] __const__CMD_CONFIG_LOOP_LOWER  = 5'd28;
  localparam logic [4:0] __const__CMD_CONFIG_LOOP_UPPER  = 5'd29;
  localparam logic [4:0] __const__CMD_CONFIG_LOOP_STEP  = 5'd30;
  localparam logic [1:0] __const__addr_offset_nbits_at_capture_addr_dst_id  = 2'd2;
  logic [1:0] addr2controller_lut [0:3];
  logic [1:0] addr_dst_id;
  logic [1:0] idTo2d_x_lut [0:3];
  logic [0:0] idTo2d_y_lut [0:3];
  //-------------------------------------------------------------
  // Component crossbar
  //-------------------------------------------------------------

  logic [0:0] crossbar__clk;
  logic [0:0] crossbar__reset;
  ControllerNocXbarPacket_InterCgraPktType__f1a81b7e6c97120c crossbar__recv__msg [0:5];
  logic [0:0] crossbar__recv__rdy [0:5];
  logic [0:0] crossbar__recv__val [0:5];
  ControllerNocXbarPacket_InterCgraPktType__f1a81b7e6c97120c crossbar__send__msg [0:0];
  logic [0:0] crossbar__send__rdy [0:0];
  logic [0:0] crossbar__send__val [0:0];

  XbarRTL__40ca80b1d76a0751 crossbar
  (
    .clk( crossbar__clk ),
    .reset( crossbar__reset ),
    .recv__msg( crossbar__recv__msg ),
    .recv__rdy( crossbar__recv__rdy ),
    .recv__val( crossbar__recv__val ),
    .send__msg( crossbar__send__msg ),
    .send__rdy( crossbar__send__rdy ),
    .send__val( crossbar__send__val )
  );

  //-------------------------------------------------------------
  // End of component crossbar
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component global_reduce_unit
  //-------------------------------------------------------------

  logic [0:0] global_reduce_unit__clk;
  logic [0:0] global_reduce_unit__reset;
  InterCgraPacket_4_4x1_4_8_4_CgraPayload__9d404f857a1e94ff global_reduce_unit__recv_count__msg;
  logic [0:0] global_reduce_unit__recv_count__rdy;
  logic [0:0] global_reduce_unit__recv_count__val;
  InterCgraPacket_4_4x1_4_8_4_CgraPayload__9d404f857a1e94ff global_reduce_unit__recv_data__msg;
  logic [0:0] global_reduce_unit__recv_data__rdy;
  logic [0:0] global_reduce_unit__recv_data__val;
  ControllerNocXbarPacket_InterCgraPktType__f1a81b7e6c97120c global_reduce_unit__send__msg;
  logic [0:0] global_reduce_unit__send__rdy;
  logic [0:0] global_reduce_unit__send__val;

  GlobalReduceUnitRTL__a68241ebe958efcc global_reduce_unit
  (
    .clk( global_reduce_unit__clk ),
    .reset( global_reduce_unit__reset ),
    .recv_count__msg( global_reduce_unit__recv_count__msg ),
    .recv_count__rdy( global_reduce_unit__recv_count__rdy ),
    .recv_count__val( global_reduce_unit__recv_count__val ),
    .recv_data__msg( global_reduce_unit__recv_data__msg ),
    .recv_data__rdy( global_reduce_unit__recv_data__rdy ),
    .recv_data__val( global_reduce_unit__recv_data__val ),
    .send__msg( global_reduce_unit__send__msg ),
    .send__rdy( global_reduce_unit__send__rdy ),
    .send__val( global_reduce_unit__send__val )
  );

  //-------------------------------------------------------------
  // End of component global_reduce_unit
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component recv_from_cpu_pkt_queue
  //-------------------------------------------------------------

  logic [0:0] recv_from_cpu_pkt_queue__clk;
  logic [1:0] recv_from_cpu_pkt_queue__count;
  logic [0:0] recv_from_cpu_pkt_queue__reset;
  IntraCgraPacket_4_4x1_4_8_2_CgraPayload__11cd3f8c0d91825c recv_from_cpu_pkt_queue__recv__msg;
  logic [0:0] recv_from_cpu_pkt_queue__recv__rdy;
  logic [0:0] recv_from_cpu_pkt_queue__recv__val;
  IntraCgraPacket_4_4x1_4_8_2_CgraPayload__11cd3f8c0d91825c recv_from_cpu_pkt_queue__send__msg;
  logic [0:0] recv_from_cpu_pkt_queue__send__rdy;
  logic [0:0] recv_from_cpu_pkt_queue__send__val;

  NormalQueueRTL__4d91d5ee0229de22 recv_from_cpu_pkt_queue
  (
    .clk( recv_from_cpu_pkt_queue__clk ),
    .count( recv_from_cpu_pkt_queue__count ),
    .reset( recv_from_cpu_pkt_queue__reset ),
    .recv__msg( recv_from_cpu_pkt_queue__recv__msg ),
    .recv__rdy( recv_from_cpu_pkt_queue__recv__rdy ),
    .recv__val( recv_from_cpu_pkt_queue__recv__val ),
    .send__msg( recv_from_cpu_pkt_queue__send__msg ),
    .send__rdy( recv_from_cpu_pkt_queue__send__rdy ),
    .send__val( recv_from_cpu_pkt_queue__send__val )
  );

  //-------------------------------------------------------------
  // End of component recv_from_cpu_pkt_queue
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component recv_from_tile_load_request_pkt_queue
  //-------------------------------------------------------------

  logic [0:0] recv_from_tile_load_request_pkt_queue__clk;
  logic [0:0] recv_from_tile_load_request_pkt_queue__reset;
  InterCgraPacket_4_4x1_4_8_4_CgraPayload__9d404f857a1e94ff recv_from_tile_load_request_pkt_queue__recv__msg;
  logic [0:0] recv_from_tile_load_request_pkt_queue__recv__rdy;
  logic [0:0] recv_from_tile_load_request_pkt_queue__recv__val;
  InterCgraPacket_4_4x1_4_8_4_CgraPayload__9d404f857a1e94ff recv_from_tile_load_request_pkt_queue__send__msg;
  logic [0:0] recv_from_tile_load_request_pkt_queue__send__rdy;
  logic [0:0] recv_from_tile_load_request_pkt_queue__send__val;

  ChannelRTL__1970d1f511171c70 recv_from_tile_load_request_pkt_queue
  (
    .clk( recv_from_tile_load_request_pkt_queue__clk ),
    .reset( recv_from_tile_load_request_pkt_queue__reset ),
    .recv__msg( recv_from_tile_load_request_pkt_queue__recv__msg ),
    .recv__rdy( recv_from_tile_load_request_pkt_queue__recv__rdy ),
    .recv__val( recv_from_tile_load_request_pkt_queue__recv__val ),
    .send__msg( recv_from_tile_load_request_pkt_queue__send__msg ),
    .send__rdy( recv_from_tile_load_request_pkt_queue__send__rdy ),
    .send__val( recv_from_tile_load_request_pkt_queue__send__val )
  );

  //-------------------------------------------------------------
  // End of component recv_from_tile_load_request_pkt_queue
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component recv_from_tile_load_response_pkt_queue
  //-------------------------------------------------------------

  logic [0:0] recv_from_tile_load_response_pkt_queue__clk;
  logic [0:0] recv_from_tile_load_response_pkt_queue__reset;
  InterCgraPacket_4_4x1_4_8_4_CgraPayload__9d404f857a1e94ff recv_from_tile_load_response_pkt_queue__recv__msg;
  logic [0:0] recv_from_tile_load_response_pkt_queue__recv__rdy;
  logic [0:0] recv_from_tile_load_response_pkt_queue__recv__val;
  InterCgraPacket_4_4x1_4_8_4_CgraPayload__9d404f857a1e94ff recv_from_tile_load_response_pkt_queue__send__msg;
  logic [0:0] recv_from_tile_load_response_pkt_queue__send__rdy;
  logic [0:0] recv_from_tile_load_response_pkt_queue__send__val;

  ChannelRTL__1970d1f511171c70 recv_from_tile_load_response_pkt_queue
  (
    .clk( recv_from_tile_load_response_pkt_queue__clk ),
    .reset( recv_from_tile_load_response_pkt_queue__reset ),
    .recv__msg( recv_from_tile_load_response_pkt_queue__recv__msg ),
    .recv__rdy( recv_from_tile_load_response_pkt_queue__recv__rdy ),
    .recv__val( recv_from_tile_load_response_pkt_queue__recv__val ),
    .send__msg( recv_from_tile_load_response_pkt_queue__send__msg ),
    .send__rdy( recv_from_tile_load_response_pkt_queue__send__rdy ),
    .send__val( recv_from_tile_load_response_pkt_queue__send__val )
  );

  //-------------------------------------------------------------
  // End of component recv_from_tile_load_response_pkt_queue
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component recv_from_tile_store_request_pkt_queue
  //-------------------------------------------------------------

  logic [0:0] recv_from_tile_store_request_pkt_queue__clk;
  logic [0:0] recv_from_tile_store_request_pkt_queue__reset;
  InterCgraPacket_4_4x1_4_8_4_CgraPayload__9d404f857a1e94ff recv_from_tile_store_request_pkt_queue__recv__msg;
  logic [0:0] recv_from_tile_store_request_pkt_queue__recv__rdy;
  logic [0:0] recv_from_tile_store_request_pkt_queue__recv__val;
  InterCgraPacket_4_4x1_4_8_4_CgraPayload__9d404f857a1e94ff recv_from_tile_store_request_pkt_queue__send__msg;
  logic [0:0] recv_from_tile_store_request_pkt_queue__send__rdy;
  logic [0:0] recv_from_tile_store_request_pkt_queue__send__val;

  ChannelRTL__1970d1f511171c70 recv_from_tile_store_request_pkt_queue
  (
    .clk( recv_from_tile_store_request_pkt_queue__clk ),
    .reset( recv_from_tile_store_request_pkt_queue__reset ),
    .recv__msg( recv_from_tile_store_request_pkt_queue__recv__msg ),
    .recv__rdy( recv_from_tile_store_request_pkt_queue__recv__rdy ),
    .recv__val( recv_from_tile_store_request_pkt_queue__recv__val ),
    .send__msg( recv_from_tile_store_request_pkt_queue__send__msg ),
    .send__rdy( recv_from_tile_store_request_pkt_queue__send__rdy ),
    .send__val( recv_from_tile_store_request_pkt_queue__send__val )
  );

  //-------------------------------------------------------------
  // End of component recv_from_tile_store_request_pkt_queue
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component send_to_cpu_pkt_queue
  //-------------------------------------------------------------

  logic [0:0] send_to_cpu_pkt_queue__clk;
  logic [1:0] send_to_cpu_pkt_queue__count;
  logic [0:0] send_to_cpu_pkt_queue__reset;
  IntraCgraPacket_4_4x1_4_8_2_CgraPayload__11cd3f8c0d91825c send_to_cpu_pkt_queue__recv__msg;
  logic [0:0] send_to_cpu_pkt_queue__recv__rdy;
  logic [0:0] send_to_cpu_pkt_queue__recv__val;
  IntraCgraPacket_4_4x1_4_8_2_CgraPayload__11cd3f8c0d91825c send_to_cpu_pkt_queue__send__msg;
  logic [0:0] send_to_cpu_pkt_queue__send__rdy;
  logic [0:0] send_to_cpu_pkt_queue__send__val;

  NormalQueueRTL__4d91d5ee0229de22 send_to_cpu_pkt_queue
  (
    .clk( send_to_cpu_pkt_queue__clk ),
    .count( send_to_cpu_pkt_queue__count ),
    .reset( send_to_cpu_pkt_queue__reset ),
    .recv__msg( send_to_cpu_pkt_queue__recv__msg ),
    .recv__rdy( send_to_cpu_pkt_queue__recv__rdy ),
    .recv__val( send_to_cpu_pkt_queue__recv__val ),
    .send__msg( send_to_cpu_pkt_queue__send__msg ),
    .send__rdy( send_to_cpu_pkt_queue__send__rdy ),
    .send__val( send_to_cpu_pkt_queue__send__val )
  );

  //-------------------------------------------------------------
  // End of component send_to_cpu_pkt_queue
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component send_to_mem_load_request_queue
  //-------------------------------------------------------------

  logic [0:0] send_to_mem_load_request_queue__clk;
  logic [0:0] send_to_mem_load_request_queue__reset;
  InterCgraPacket_4_4x1_4_8_4_CgraPayload__9d404f857a1e94ff send_to_mem_load_request_queue__recv__msg;
  logic [0:0] send_to_mem_load_request_queue__recv__rdy;
  logic [0:0] send_to_mem_load_request_queue__recv__val;
  InterCgraPacket_4_4x1_4_8_4_CgraPayload__9d404f857a1e94ff send_to_mem_load_request_queue__send__msg;
  logic [0:0] send_to_mem_load_request_queue__send__rdy;
  logic [0:0] send_to_mem_load_request_queue__send__val;

  ChannelRTL__1970d1f511171c70 send_to_mem_load_request_queue
  (
    .clk( send_to_mem_load_request_queue__clk ),
    .reset( send_to_mem_load_request_queue__reset ),
    .recv__msg( send_to_mem_load_request_queue__recv__msg ),
    .recv__rdy( send_to_mem_load_request_queue__recv__rdy ),
    .recv__val( send_to_mem_load_request_queue__recv__val ),
    .send__msg( send_to_mem_load_request_queue__send__msg ),
    .send__rdy( send_to_mem_load_request_queue__send__rdy ),
    .send__val( send_to_mem_load_request_queue__send__val )
  );

  //-------------------------------------------------------------
  // End of component send_to_mem_load_request_queue
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component send_to_mem_store_request_queue
  //-------------------------------------------------------------

  logic [0:0] send_to_mem_store_request_queue__clk;
  logic [0:0] send_to_mem_store_request_queue__reset;
  InterCgraPacket_4_4x1_4_8_4_CgraPayload__9d404f857a1e94ff send_to_mem_store_request_queue__recv__msg;
  logic [0:0] send_to_mem_store_request_queue__recv__rdy;
  logic [0:0] send_to_mem_store_request_queue__recv__val;
  InterCgraPacket_4_4x1_4_8_4_CgraPayload__9d404f857a1e94ff send_to_mem_store_request_queue__send__msg;
  logic [0:0] send_to_mem_store_request_queue__send__rdy;
  logic [0:0] send_to_mem_store_request_queue__send__val;

  ChannelRTL__1970d1f511171c70 send_to_mem_store_request_queue
  (
    .clk( send_to_mem_store_request_queue__clk ),
    .reset( send_to_mem_store_request_queue__reset ),
    .recv__msg( send_to_mem_store_request_queue__recv__msg ),
    .recv__rdy( send_to_mem_store_request_queue__recv__rdy ),
    .recv__val( send_to_mem_store_request_queue__recv__val ),
    .send__msg( send_to_mem_store_request_queue__send__msg ),
    .send__rdy( send_to_mem_store_request_queue__send__rdy ),
    .send__val( send_to_mem_store_request_queue__send__val )
  );

  //-------------------------------------------------------------
  // End of component send_to_mem_store_request_queue
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component send_to_tile_load_response_queue
  //-------------------------------------------------------------

  logic [0:0] send_to_tile_load_response_queue__clk;
  logic [0:0] send_to_tile_load_response_queue__reset;
  InterCgraPacket_4_4x1_4_8_4_CgraPayload__9d404f857a1e94ff send_to_tile_load_response_queue__recv__msg;
  logic [0:0] send_to_tile_load_response_queue__recv__rdy;
  logic [0:0] send_to_tile_load_response_queue__recv__val;
  InterCgraPacket_4_4x1_4_8_4_CgraPayload__9d404f857a1e94ff send_to_tile_load_response_queue__send__msg;
  logic [0:0] send_to_tile_load_response_queue__send__rdy;
  logic [0:0] send_to_tile_load_response_queue__send__val;

  ChannelRTL__1970d1f511171c70 send_to_tile_load_response_queue
  (
    .clk( send_to_tile_load_response_queue__clk ),
    .reset( send_to_tile_load_response_queue__reset ),
    .recv__msg( send_to_tile_load_response_queue__recv__msg ),
    .recv__rdy( send_to_tile_load_response_queue__recv__rdy ),
    .recv__val( send_to_tile_load_response_queue__recv__val ),
    .send__msg( send_to_tile_load_response_queue__send__msg ),
    .send__rdy( send_to_tile_load_response_queue__send__rdy ),
    .send__val( send_to_tile_load_response_queue__send__val )
  );

  //-------------------------------------------------------------
  // End of component send_to_tile_load_response_queue
  //-------------------------------------------------------------
  logic [0:0] __tmpvar__update_received_msg_kLoadRequestInportIdx;
  logic [0:0] __tmpvar__update_received_msg_kLoadResponseInportIdx;
  logic [1:0] __tmpvar__update_received_msg_kStoreRequestInportIdx;
  logic [1:0] __tmpvar__update_received_msg_kFromCpuCtrlAndDataIdx;
  logic [2:0] __tmpvar__update_received_msg_kFromInterTileRingIdx;
  logic [2:0] __tmpvar__update_received_msg_kFromReduceUnitIdx;
  InterCgraPacket_4_4x1_4_8_4_CgraPayload__9d404f857a1e94ff __tmpvar__update_received_msg_received_pkt;

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/controller/ControllerRTL.py:373
  // @update
  // def capture_addr_dst_id():
  //   s.addr_dst_id @= s.addr2controller_lut[trunc(s.crossbar.send[0].msg.inter_cgra_pkt.payload.data_addr >> addr_offset_nbits, CgraIdType)]
  
  always_comb begin : capture_addr_dst_id
    addr_dst_id = addr2controller_lut[2'(crossbar__send__msg[1'd0].inter_cgra_pkt.payload.data_addr >> 2'( __const__addr_offset_nbits_at_capture_addr_dst_id ))];
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/controller/ControllerRTL.py:141
  // @update
  // def update_received_msg():
  //   kLoadRequestInportIdx = 0
  //   kLoadResponseInportIdx = 1
  //   kStoreRequestInportIdx = 2
  //   kFromCpuCtrlAndDataIdx = 3
  //   kFromInterTileRingIdx = 4
  //   kFromReduceUnitIdx = 5
  // 
  //   s.send_to_cpu_pkt_queue.recv.val @= 0
  //   s.send_to_cpu_pkt_queue.recv.msg @= IntraCgraPktType(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
  //   s.recv_from_ctrl_ring_pkt.rdy @= 0
  // 
  //   for i in range(CONTROLLER_CROSSBAR_INPORTS):
  //     s.crossbar.recv[i].val @= 0
  //     s.crossbar.recv[i].msg @= ControllerXbarPktType(0, 0)
  // 
  //   # For the command signal from inter-tile/intra-cgra control ring.
  //   s.crossbar.recv[kFromInterTileRingIdx].val @= s.recv_from_ctrl_ring_pkt.val
  //   s.recv_from_ctrl_ring_pkt.rdy @= s.crossbar.recv[kFromInterTileRingIdx].rdy
  //   s.crossbar.recv[kFromInterTileRingIdx].msg @= \
  //       ControllerXbarPktType(0, # dst (always 0 to align with the single outport of the crossbar, i.e., NoC)
  //                             InterCgraPktType(s.cgra_id,
  //                                              s.recv_from_ctrl_ring_pkt.msg.dst_cgra_id,
  //                                              s.idTo2d_x_lut[s.cgra_id], # src_x
  //                                              s.idTo2d_y_lut[s.cgra_id], # src_y
  //                                              s.recv_from_ctrl_ring_pkt.msg.dst_cgra_x, # dst_x
  //                                              s.recv_from_ctrl_ring_pkt.msg.dst_cgra_y, # dst_y
  //                                              s.recv_from_ctrl_ring_pkt.msg.src, # src_tile_id
  //                                              s.recv_from_ctrl_ring_pkt.msg.dst, # dst_tile_id
  //                                              0, # remote_src_port, only used for inter-cgra remote load request/response.
  //                                              0, # opaque
  //                                              0, # vc_id. No need to specify vc_id for self produce-consume pkt thanks to the additional VC buffer.
  //                                              s.recv_from_ctrl_ring_pkt.msg.payload))
  // 
  //   # For the load request from local tiles.
  //   s.crossbar.recv[kLoadRequestInportIdx].val @= s.recv_from_tile_load_request_pkt_queue.send.val
  //   s.recv_from_tile_load_request_pkt_queue.send.rdy @= s.crossbar.recv[kLoadRequestInportIdx].rdy
  //   s.crossbar.recv[kLoadRequestInportIdx].msg @= \
  //       ControllerXbarPktType(0, # dst (always 0 to align with the single outport of the crossbar, i.e., NoC)
  //                             s.recv_from_tile_load_request_pkt_queue.send.msg)
  // 
  //   # For the store request from local tiles.
  //   s.crossbar.recv[kStoreRequestInportIdx].val @= s.recv_from_tile_store_request_pkt_queue.send.val
  //   s.recv_from_tile_store_request_pkt_queue.send.rdy @= s.crossbar.recv[kStoreRequestInportIdx].rdy
  //   s.crossbar.recv[kStoreRequestInportIdx].msg @= \
  //       ControllerXbarPktType(0, # dst (always 0 to align with the single outport of the crossbar, i.e., NoC)
  //                             s.recv_from_tile_store_request_pkt_queue.send.msg)
  // 
  //   # For the load response (i.e., the data towards other) from local memory.
  //   s.crossbar.recv[kLoadResponseInportIdx].val @= \
  //       s.recv_from_tile_load_response_pkt_queue.send.val
  //   s.recv_from_tile_load_response_pkt_queue.send.rdy @= s.crossbar.recv[kLoadResponseInportIdx].rdy
  //   s.crossbar.recv[kLoadResponseInportIdx].msg @= \
  //       ControllerXbarPktType(0, # dst (always 0 to align with the single outport of the crossbar, i.e., NoC)
  //                             s.recv_from_tile_load_response_pkt_queue.send.msg)
  // 
  //   # For the load response (i.e., the data towards other) from local memory.
  //   s.crossbar.recv[kFromReduceUnitIdx].val @= \
  //       s.global_reduce_unit.send.val
  //   s.global_reduce_unit.send.rdy @= s.crossbar.recv[kFromReduceUnitIdx].rdy
  //   s.crossbar.recv[kFromReduceUnitIdx].msg @= s.global_reduce_unit.send.msg
  // 
  //   # For the ctrl and data preloading.
  //   s.crossbar.recv[kFromCpuCtrlAndDataIdx].val @= \
  //       s.recv_from_cpu_pkt_queue.send.val
  //   s.recv_from_cpu_pkt_queue.send.rdy @= s.crossbar.recv[kFromCpuCtrlAndDataIdx].rdy
  //   s.crossbar.recv[kFromCpuCtrlAndDataIdx].msg @= \
  //       ControllerXbarPktType(0, # dst (always 0 to align with the single outport of the crossbar, i.e., NoC)
  //                             InterCgraPktType(s.cgra_id, # src
  //                                              s.recv_from_cpu_pkt_queue.send.msg.dst_cgra_id, # dst
  //                                              0, # src_x
  //                                              0, # src_y
  //                                              s.idTo2d_x_lut[s.recv_from_cpu_pkt_queue.send.msg.dst_cgra_id], # dst_x
  //                                              s.idTo2d_y_lut[s.recv_from_cpu_pkt_queue.send.msg.dst_cgra_id], # dst_y
  //                                              num_tiles, # src_tile_id, num_tiles is used to indicate the request is from CPU, so the LOAD response can come back.
  //                                              s.recv_from_cpu_pkt_queue.send.msg.dst, # dst_tile_id
  //                                              0, # remote_src_port, only used for inter-cgra remote load request/response.
  //                                              0, # opaque
  //                                              0, # vc_id
  //                                              s.recv_from_cpu_pkt_queue.send.msg.payload))
  // 
  //   # TODO: For the other cmd types.
  // 
  // 
  // # @update
  // # def update_received_msg_from_noc():
  // 
  //   # Initiates the signals.
  //   s.send_to_mem_load_request_queue.recv.val @= 0
  //   s.send_to_mem_store_request_queue.recv.val @= 0
  //   s.send_to_tile_load_response_queue.recv.val @= 0
  // 
  //   s.send_to_mem_load_request_queue.recv.msg @= InterCgraPktType(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
  //   s.send_to_mem_store_request_queue.recv.msg @= InterCgraPktType(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
  //   s.send_to_tile_load_response_queue.recv.msg @= InterCgraPktType(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
  // 
  //   s.recv_from_inter_cgra_noc.rdy @= 0
  //   s.send_to_ctrl_ring_pkt.val @= 0
  //   s.send_to_ctrl_ring_pkt.msg @= IntraCgraPktType(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
  //   s.global_reduce_unit.recv_count.val @= 0
  //   s.global_reduce_unit.recv_count.msg @= InterCgraPktType(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
  //   s.global_reduce_unit.recv_data.val @= 0
  //   s.global_reduce_unit.recv_data.msg @= InterCgraPktType(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
  // 
  //   # For the load request from NoC.
  //   received_pkt = s.recv_from_inter_cgra_noc.msg
  //   if s.recv_from_inter_cgra_noc.val:
  //     if s.recv_from_inter_cgra_noc.msg.payload.cmd == CMD_LOAD_REQUEST:
  //       s.send_to_mem_load_request_queue.recv.val @= 1
  // 
  //       if s.send_to_mem_load_request_queue.recv.rdy:
  //         s.recv_from_inter_cgra_noc.rdy @= 1
  //         s.send_to_mem_load_request_queue.recv.msg @= received_pkt
  // 
  //     elif s.recv_from_inter_cgra_noc.msg.payload.cmd == CMD_STORE_REQUEST:
  //       s.send_to_mem_store_request_queue.recv.msg @= received_pkt
  //       s.send_to_mem_store_request_queue.recv.val @= 1
  // 
  //       if s.send_to_mem_store_request_queue.recv.rdy:
  //         s.recv_from_inter_cgra_noc.rdy @= 1
  // 
  //     elif s.recv_from_inter_cgra_noc.msg.payload.cmd == CMD_LOAD_RESPONSE:
  //       # FIXME: This condition needs to check whether this controller is the
  //       # one connecting to CPU, and with the help from additional field indicating
  //       # whether the packet is originally from CPU.
  //       # https://github.com/tancheng/VectorCGRA/issues/116.
  //       if s.recv_from_inter_cgra_noc.msg.dst_tile_id == num_tiles:
  //         s.recv_from_inter_cgra_noc.rdy @= s.send_to_cpu_pkt_queue.recv.rdy
  //         s.send_to_cpu_pkt_queue.recv.val @= 1
  //         s.send_to_cpu_pkt_queue.recv.msg @= \
  //             IntraCgraPktType(s.recv_from_inter_cgra_noc.msg.src_tile_id, # src
  //                              s.recv_from_inter_cgra_noc.msg.dst_tile_id, # dst
  //                              s.recv_from_inter_cgra_noc.msg.src, # src_cgra_id
  //                              s.recv_from_inter_cgra_noc.msg.dst, # src_cgra_id
  //                              s.recv_from_inter_cgra_noc.msg.src_x, # src_cgra_x
  //                              s.recv_from_inter_cgra_noc.msg.src_y, # src_cgra_y
  //                              s.recv_from_inter_cgra_noc.msg.dst_x, # dst_cgra_x
  //                              s.recv_from_inter_cgra_noc.msg.dst_y, # dst_cgra_y
  //                              0, # opaque
  //                              0, # vc_id
  //                              s.recv_from_inter_cgra_noc.msg.payload)
  // 
  //       else:
  //         s.recv_from_inter_cgra_noc.rdy @= s.send_to_tile_load_response_queue.recv.rdy
  //         s.send_to_tile_load_response_queue.recv.msg @= received_pkt
  //         s.send_to_tile_load_response_queue.recv.val @= 1
  // 
  //     elif s.recv_from_inter_cgra_noc.msg.payload.cmd == CMD_COMPLETE:
  //       s.recv_from_inter_cgra_noc.rdy @= s.send_to_cpu_pkt_queue.recv.rdy
  //       s.send_to_cpu_pkt_queue.recv.val @= 1
  //       s.send_to_cpu_pkt_queue.recv.msg @= \
  //           IntraCgraPktType(s.recv_from_inter_cgra_noc.msg.src_tile_id, # src
  //                            s.recv_from_inter_cgra_noc.msg.dst_tile_id, # dst
  //                            s.recv_from_inter_cgra_noc.msg.src, # src_cgra_id
  //                            s.recv_from_inter_cgra_noc.msg.dst, # src_cgra_id
  //                            s.recv_from_inter_cgra_noc.msg.src_x, # src_cgra_x
  //                            s.recv_from_inter_cgra_noc.msg.src_y, # src_cgra_y
  //                            s.recv_from_inter_cgra_noc.msg.dst_x, # dst_cgra_x
  //                            s.recv_from_inter_cgra_noc.msg.dst_y, # dst_cgra_y
  //                            0, # opaque
  //                            0, # vc_id
  //                            s.recv_from_inter_cgra_noc.msg.payload)
  // 
  //     # Consume and discard the leaf counter complete signal (loop termination
  //     # notification from LoopCounter FU) to avoid blocking the NoC.
  //     elif s.recv_from_inter_cgra_noc.msg.payload.cmd == CMD_LEAF_COUNTER_COMPLETE:
  //       s.recv_from_inter_cgra_noc.rdy @= 1
  // 
  //     elif s.recv_from_inter_cgra_noc.msg.payload.cmd == CMD_GLOBAL_REDUCE_ADD:
  //       s.recv_from_inter_cgra_noc.rdy @= s.global_reduce_unit.recv_data.rdy
  //       s.global_reduce_unit.recv_data.val @= 1
  //       s.global_reduce_unit.recv_data.msg @= s.recv_from_inter_cgra_noc.msg
  // 
  //     elif s.recv_from_inter_cgra_noc.msg.payload.cmd == CMD_GLOBAL_REDUCE_COUNT:
  //       s.recv_from_inter_cgra_noc.rdy @= s.global_reduce_unit.recv_count.rdy
  //       s.global_reduce_unit.recv_count.val @= 1
  //       s.global_reduce_unit.recv_count.msg @= s.recv_from_inter_cgra_noc.msg
  // 
  //     elif (s.recv_from_inter_cgra_noc.msg.payload.cmd == CMD_CONFIG) | \
  //          (s.recv_from_inter_cgra_noc.msg.payload.cmd == CMD_CONFIG_PROLOGUE_FU) | \
  //          (s.recv_from_inter_cgra_noc.msg.payload.cmd == CMD_CONFIG_PROLOGUE_FU_CROSSBAR) | \
  //          (s.recv_from_inter_cgra_noc.msg.payload.cmd == CMD_CONFIG_PROLOGUE_ROUTING_CROSSBAR) | \
  //          (s.recv_from_inter_cgra_noc.msg.payload.cmd == CMD_CONFIG_TOTAL_CTRL_COUNT) | \
  //          (s.recv_from_inter_cgra_noc.msg.payload.cmd == CMD_CONFIG_COUNT_PER_ITER) | \
  //          (s.recv_from_inter_cgra_noc.msg.payload.cmd == CMD_CONFIG_CTRL_LOWER_BOUND) | \
  //          (s.recv_from_inter_cgra_noc.msg.payload.cmd == CMD_CONST) | \
  //          (s.recv_from_inter_cgra_noc.msg.payload.cmd == CMD_GLOBAL_REDUCE_ADD_RESPONSE) | \
  //          (s.recv_from_inter_cgra_noc.msg.payload.cmd == CMD_GLOBAL_REDUCE_MUL_RESPONSE) | \
  //          (s.recv_from_inter_cgra_noc.msg.payload.cmd == CMD_CONFIG_STREAMING_LD_START_ADDR) | \
  //          (s.recv_from_inter_cgra_noc.msg.payload.cmd == CMD_CONFIG_STREAMING_LD_STRIDE) | \
  //          (s.recv_from_inter_cgra_noc.msg.payload.cmd == CMD_CONFIG_STREAMING_LD_END_ADDR) | \
  //          (s.recv_from_inter_cgra_noc.msg.payload.cmd == CMD_PAUSE) | \
  //          (s.recv_from_inter_cgra_noc.msg.payload.cmd == CMD_PRESERVE) | \
  //          (s.recv_from_inter_cgra_noc.msg.payload.cmd == CMD_RESUME) | \
  //          (s.recv_from_inter_cgra_noc.msg.payload.cmd == CMD_RECORD_PHI_ADDR) | \
  //          (s.recv_from_inter_cgra_noc.msg.payload.cmd == CMD_TERMINATE) | \
  //          (s.recv_from_inter_cgra_noc.msg.payload.cmd == CMD_LAUNCH) | \
  //          (s.recv_from_inter_cgra_noc.msg.payload.cmd == CMD_CONFIG_LOOP_LOWER) | \
  //          (s.recv_from_inter_cgra_noc.msg.payload.cmd == CMD_CONFIG_LOOP_UPPER) | \
  //          (s.recv_from_inter_cgra_noc.msg.payload.cmd == CMD_CONFIG_LOOP_STEP) :
  //       s.recv_from_inter_cgra_noc.rdy @= s.send_to_ctrl_ring_pkt.rdy
  //       s.send_to_ctrl_ring_pkt.val @= s.recv_from_inter_cgra_noc.val
  //       s.send_to_ctrl_ring_pkt.msg @= \
  //           IntraCgraPktType(s.recv_from_inter_cgra_noc.msg.src_tile_id, # src
  //                            s.recv_from_inter_cgra_noc.msg.dst_tile_id, # dst
  //                            s.recv_from_inter_cgra_noc.msg.src, # src_cgra_id
  //                            s.recv_from_inter_cgra_noc.msg.dst, # src_cgra_id
  //                            s.recv_from_inter_cgra_noc.msg.src_x, # src_cgra_x
  //                            s.recv_from_inter_cgra_noc.msg.src_y, # src_cgra_y
  //                            s.recv_from_inter_cgra_noc.msg.dst_x, # dst_cgra_x
  //                            s.recv_from_inter_cgra_noc.msg.dst_y, # dst_cgra_y
  //                            0, # opaque
  //                            0, # vc_id
  //                            s.recv_from_inter_cgra_noc.msg.payload)
  // 
  //     # else:
  //     #   # TODO: Handle other cmd types.
  //     #   assert(False)
  
  always_comb begin : update_received_msg
    __tmpvar__update_received_msg_kLoadRequestInportIdx = 1'd0;
    __tmpvar__update_received_msg_kLoadResponseInportIdx = 1'd1;
    __tmpvar__update_received_msg_kStoreRequestInportIdx = 2'd2;
    __tmpvar__update_received_msg_kFromCpuCtrlAndDataIdx = 2'd3;
    __tmpvar__update_received_msg_kFromInterTileRingIdx = 3'd4;
    __tmpvar__update_received_msg_kFromReduceUnitIdx = 3'd5;
    send_to_cpu_pkt_queue__recv__val = 1'd0;
    send_to_cpu_pkt_queue__recv__msg = { 3'd0, 3'd0, 2'd0, 2'd0, 2'd0, 1'd0, 2'd0, 1'd0, 8'd0, 1'd0, 191'd0 };
    recv_from_ctrl_ring_pkt__rdy = 1'd0;
    for ( int unsigned i = 1'd0; i < 3'( __const__CONTROLLER_CROSSBAR_INPORTS ); i += 1'd1 ) begin
      crossbar__recv__val[3'(i)] = 1'd0;
      crossbar__recv__msg[3'(i)] = { 1'd0, 219'd0 };
    end
    crossbar__recv__val[__tmpvar__update_received_msg_kFromInterTileRingIdx] = recv_from_ctrl_ring_pkt__val;
    recv_from_ctrl_ring_pkt__rdy = crossbar__recv__rdy[3'(__tmpvar__update_received_msg_kFromInterTileRingIdx)];
    crossbar__recv__msg[__tmpvar__update_received_msg_kFromInterTileRingIdx] = { 1'd0, { cgra_id, recv_from_ctrl_ring_pkt__msg.dst_cgra_id, idTo2d_x_lut[cgra_id], idTo2d_y_lut[cgra_id], recv_from_ctrl_ring_pkt__msg.dst_cgra_x, recv_from_ctrl_ring_pkt__msg.dst_cgra_y, recv_from_ctrl_ring_pkt__msg.src, recv_from_ctrl_ring_pkt__msg.dst, 2'd0, 8'd0, 2'd0, recv_from_ctrl_ring_pkt__msg.payload } };
    crossbar__recv__val[__tmpvar__update_received_msg_kLoadRequestInportIdx] = recv_from_tile_load_request_pkt_queue__send__val;
    recv_from_tile_load_request_pkt_queue__send__rdy = crossbar__recv__rdy[3'(__tmpvar__update_received_msg_kLoadRequestInportIdx)];
    crossbar__recv__msg[__tmpvar__update_received_msg_kLoadRequestInportIdx] = { 1'd0, recv_from_tile_load_request_pkt_queue__send__msg };
    crossbar__recv__val[__tmpvar__update_received_msg_kStoreRequestInportIdx] = recv_from_tile_store_request_pkt_queue__send__val;
    recv_from_tile_store_request_pkt_queue__send__rdy = crossbar__recv__rdy[3'(__tmpvar__update_received_msg_kStoreRequestInportIdx)];
    crossbar__recv__msg[__tmpvar__update_received_msg_kStoreRequestInportIdx] = { 1'd0, recv_from_tile_store_request_pkt_queue__send__msg };
    crossbar__recv__val[__tmpvar__update_received_msg_kLoadResponseInportIdx] = recv_from_tile_load_response_pkt_queue__send__val;
    recv_from_tile_load_response_pkt_queue__send__rdy = crossbar__recv__rdy[3'(__tmpvar__update_received_msg_kLoadResponseInportIdx)];
    crossbar__recv__msg[__tmpvar__update_received_msg_kLoadResponseInportIdx] = { 1'd0, recv_from_tile_load_response_pkt_queue__send__msg };
    crossbar__recv__val[__tmpvar__update_received_msg_kFromReduceUnitIdx] = global_reduce_unit__send__val;
    global_reduce_unit__send__rdy = crossbar__recv__rdy[3'(__tmpvar__update_received_msg_kFromReduceUnitIdx)];
    crossbar__recv__msg[__tmpvar__update_received_msg_kFromReduceUnitIdx] = global_reduce_unit__send__msg;
    crossbar__recv__val[__tmpvar__update_received_msg_kFromCpuCtrlAndDataIdx] = recv_from_cpu_pkt_queue__send__val;
    recv_from_cpu_pkt_queue__send__rdy = crossbar__recv__rdy[3'(__tmpvar__update_received_msg_kFromCpuCtrlAndDataIdx)];
    crossbar__recv__msg[__tmpvar__update_received_msg_kFromCpuCtrlAndDataIdx] = { 1'd0, { cgra_id, recv_from_cpu_pkt_queue__send__msg.dst_cgra_id, 2'd0, 1'd0, idTo2d_x_lut[recv_from_cpu_pkt_queue__send__msg.dst_cgra_id], idTo2d_y_lut[recv_from_cpu_pkt_queue__send__msg.dst_cgra_id], 3'( __const__num_tiles_at_update_received_msg ), recv_from_cpu_pkt_queue__send__msg.dst, 2'd0, 8'd0, 2'd0, recv_from_cpu_pkt_queue__send__msg.payload } };
    send_to_mem_load_request_queue__recv__val = 1'd0;
    send_to_mem_store_request_queue__recv__val = 1'd0;
    send_to_tile_load_response_queue__recv__val = 1'd0;
    send_to_mem_load_request_queue__recv__msg = { 2'd0, 2'd0, 2'd0, 1'd0, 2'd0, 1'd0, 3'd0, 3'd0, 2'd0, 8'd0, 2'd0, 191'd0 };
    send_to_mem_store_request_queue__recv__msg = { 2'd0, 2'd0, 2'd0, 1'd0, 2'd0, 1'd0, 3'd0, 3'd0, 2'd0, 8'd0, 2'd0, 191'd0 };
    send_to_tile_load_response_queue__recv__msg = { 2'd0, 2'd0, 2'd0, 1'd0, 2'd0, 1'd0, 3'd0, 3'd0, 2'd0, 8'd0, 2'd0, 191'd0 };
    recv_from_inter_cgra_noc__rdy = 1'd0;
    send_to_ctrl_ring_pkt__val = 1'd0;
    send_to_ctrl_ring_pkt__msg = { 3'd0, 3'd0, 2'd0, 2'd0, 2'd0, 1'd0, 2'd0, 1'd0, 8'd0, 1'd0, 191'd0 };
    global_reduce_unit__recv_count__val = 1'd0;
    global_reduce_unit__recv_count__msg = { 2'd0, 2'd0, 2'd0, 1'd0, 2'd0, 1'd0, 3'd0, 3'd0, 2'd0, 8'd0, 2'd0, 191'd0 };
    global_reduce_unit__recv_data__val = 1'd0;
    global_reduce_unit__recv_data__msg = { 2'd0, 2'd0, 2'd0, 1'd0, 2'd0, 1'd0, 3'd0, 3'd0, 2'd0, 8'd0, 2'd0, 191'd0 };
    __tmpvar__update_received_msg_received_pkt = recv_from_inter_cgra_noc__msg;
    if ( recv_from_inter_cgra_noc__val ) begin
      if ( recv_from_inter_cgra_noc__msg.payload.cmd == 5'( __const__CMD_LOAD_REQUEST ) ) begin
        send_to_mem_load_request_queue__recv__val = 1'd1;
        if ( send_to_mem_load_request_queue__recv__rdy ) begin
          recv_from_inter_cgra_noc__rdy = 1'd1;
          send_to_mem_load_request_queue__recv__msg = __tmpvar__update_received_msg_received_pkt;
        end
      end
      else if ( recv_from_inter_cgra_noc__msg.payload.cmd == 5'( __const__CMD_STORE_REQUEST ) ) begin
        send_to_mem_store_request_queue__recv__msg = __tmpvar__update_received_msg_received_pkt;
        send_to_mem_store_request_queue__recv__val = 1'd1;
        if ( send_to_mem_store_request_queue__recv__rdy ) begin
          recv_from_inter_cgra_noc__rdy = 1'd1;
        end
      end
      else if ( recv_from_inter_cgra_noc__msg.payload.cmd == 5'( __const__CMD_LOAD_RESPONSE ) ) begin
        if ( recv_from_inter_cgra_noc__msg.dst_tile_id == 3'( __const__num_tiles_at_update_received_msg ) ) begin
          recv_from_inter_cgra_noc__rdy = send_to_cpu_pkt_queue__recv__rdy;
          send_to_cpu_pkt_queue__recv__val = 1'd1;
          send_to_cpu_pkt_queue__recv__msg = { recv_from_inter_cgra_noc__msg.src_tile_id, recv_from_inter_cgra_noc__msg.dst_tile_id, recv_from_inter_cgra_noc__msg.src, recv_from_inter_cgra_noc__msg.dst, recv_from_inter_cgra_noc__msg.src_x, recv_from_inter_cgra_noc__msg.src_y, recv_from_inter_cgra_noc__msg.dst_x, recv_from_inter_cgra_noc__msg.dst_y, 8'd0, 1'd0, recv_from_inter_cgra_noc__msg.payload };
        end
        else begin
          recv_from_inter_cgra_noc__rdy = send_to_tile_load_response_queue__recv__rdy;
          send_to_tile_load_response_queue__recv__msg = __tmpvar__update_received_msg_received_pkt;
          send_to_tile_load_response_queue__recv__val = 1'd1;
        end
      end
      else if ( recv_from_inter_cgra_noc__msg.payload.cmd == 5'( __const__CMD_COMPLETE ) ) begin
        recv_from_inter_cgra_noc__rdy = send_to_cpu_pkt_queue__recv__rdy;
        send_to_cpu_pkt_queue__recv__val = 1'd1;
        send_to_cpu_pkt_queue__recv__msg = { recv_from_inter_cgra_noc__msg.src_tile_id, recv_from_inter_cgra_noc__msg.dst_tile_id, recv_from_inter_cgra_noc__msg.src, recv_from_inter_cgra_noc__msg.dst, recv_from_inter_cgra_noc__msg.src_x, recv_from_inter_cgra_noc__msg.src_y, recv_from_inter_cgra_noc__msg.dst_x, recv_from_inter_cgra_noc__msg.dst_y, 8'd0, 1'd0, recv_from_inter_cgra_noc__msg.payload };
      end
      else if ( recv_from_inter_cgra_noc__msg.payload.cmd == 5'( __const__CMD_LEAF_COUNTER_COMPLETE ) ) begin
        recv_from_inter_cgra_noc__rdy = 1'd1;
      end
      else if ( recv_from_inter_cgra_noc__msg.payload.cmd == 5'( __const__CMD_GLOBAL_REDUCE_ADD ) ) begin
        recv_from_inter_cgra_noc__rdy = global_reduce_unit__recv_data__rdy;
        global_reduce_unit__recv_data__val = 1'd1;
        global_reduce_unit__recv_data__msg = recv_from_inter_cgra_noc__msg;
      end
      else if ( recv_from_inter_cgra_noc__msg.payload.cmd == 5'( __const__CMD_GLOBAL_REDUCE_COUNT ) ) begin
        recv_from_inter_cgra_noc__rdy = global_reduce_unit__recv_count__rdy;
        global_reduce_unit__recv_count__val = 1'd1;
        global_reduce_unit__recv_count__msg = recv_from_inter_cgra_noc__msg;
      end
      else if ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( recv_from_inter_cgra_noc__msg.payload.cmd == 5'( __const__CMD_CONFIG ) ) | ( recv_from_inter_cgra_noc__msg.payload.cmd == 5'( __const__CMD_CONFIG_PROLOGUE_FU ) ) ) | ( recv_from_inter_cgra_noc__msg.payload.cmd == 5'( __const__CMD_CONFIG_PROLOGUE_FU_CROSSBAR ) ) ) | ( recv_from_inter_cgra_noc__msg.payload.cmd == 5'( __const__CMD_CONFIG_PROLOGUE_ROUTING_CROSSBAR ) ) ) | ( recv_from_inter_cgra_noc__msg.payload.cmd == 5'( __const__CMD_CONFIG_TOTAL_CTRL_COUNT ) ) ) | ( recv_from_inter_cgra_noc__msg.payload.cmd == 5'( __const__CMD_CONFIG_COUNT_PER_ITER ) ) ) | ( recv_from_inter_cgra_noc__msg.payload.cmd == 5'( __const__CMD_CONFIG_CTRL_LOWER_BOUND ) ) ) | ( recv_from_inter_cgra_noc__msg.payload.cmd == 5'( __const__CMD_CONST ) ) ) | ( recv_from_inter_cgra_noc__msg.payload.cmd == 5'( __const__CMD_GLOBAL_REDUCE_ADD_RESPONSE ) ) ) | ( recv_from_inter_cgra_noc__msg.payload.cmd == 5'( __const__CMD_GLOBAL_REDUCE_MUL_RESPONSE ) ) ) | ( recv_from_inter_cgra_noc__msg.payload.cmd == 5'( __const__CMD_CONFIG_STREAMING_LD_START_ADDR ) ) ) | ( recv_from_inter_cgra_noc__msg.payload.cmd == 5'( __const__CMD_CONFIG_STREAMING_LD_STRIDE ) ) ) | ( recv_from_inter_cgra_noc__msg.payload.cmd == 5'( __const__CMD_CONFIG_STREAMING_LD_END_ADDR ) ) ) | ( recv_from_inter_cgra_noc__msg.payload.cmd == 5'( __const__CMD_PAUSE ) ) ) | ( recv_from_inter_cgra_noc__msg.payload.cmd == 5'( __const__CMD_PRESERVE ) ) ) | ( recv_from_inter_cgra_noc__msg.payload.cmd == 5'( __const__CMD_RESUME ) ) ) | ( recv_from_inter_cgra_noc__msg.payload.cmd == 5'( __const__CMD_RECORD_PHI_ADDR ) ) ) | ( recv_from_inter_cgra_noc__msg.payload.cmd == 5'( __const__CMD_TERMINATE ) ) ) | ( recv_from_inter_cgra_noc__msg.payload.cmd == 5'( __const__CMD_LAUNCH ) ) ) | ( recv_from_inter_cgra_noc__msg.payload.cmd == 5'( __const__CMD_CONFIG_LOOP_LOWER ) ) ) | ( recv_from_inter_cgra_noc__msg.payload.cmd == 5'( __const__CMD_CONFIG_LOOP_UPPER ) ) ) | ( recv_from_inter_cgra_noc__msg.payload.cmd == 5'( __const__CMD_CONFIG_LOOP_STEP ) ) ) begin
        recv_from_inter_cgra_noc__rdy = send_to_ctrl_ring_pkt__rdy;
        send_to_ctrl_ring_pkt__val = recv_from_inter_cgra_noc__val;
        send_to_ctrl_ring_pkt__msg = { recv_from_inter_cgra_noc__msg.src_tile_id, recv_from_inter_cgra_noc__msg.dst_tile_id, recv_from_inter_cgra_noc__msg.src, recv_from_inter_cgra_noc__msg.dst, recv_from_inter_cgra_noc__msg.src_x, recv_from_inter_cgra_noc__msg.src_y, recv_from_inter_cgra_noc__msg.dst_x, recv_from_inter_cgra_noc__msg.dst_y, 8'd0, 1'd0, recv_from_inter_cgra_noc__msg.payload };
      end
    end
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/controller/ControllerRTL.py:361
  // @update
  // def update_sending_to_noc_msg():
  //   s.send_to_inter_cgra_noc.val @= s.crossbar.send[0].val
  //   s.crossbar.send[0].rdy @= s.send_to_inter_cgra_noc.rdy
  //   s.send_to_inter_cgra_noc.msg @= s.crossbar.send[0].msg.inter_cgra_pkt
  //   # addr_dst_id = 0
  //   if (s.crossbar.send[0].msg.inter_cgra_pkt.payload.cmd == CMD_LOAD_REQUEST) | \
  //      (s.crossbar.send[0].msg.inter_cgra_pkt.payload.cmd == CMD_STORE_REQUEST):
  //     s.send_to_inter_cgra_noc.msg.dst @= s.addr_dst_id
  //     s.send_to_inter_cgra_noc.msg.dst_x @= s.idTo2d_x_lut[s.addr_dst_id]
  //     s.send_to_inter_cgra_noc.msg.dst_y @= s.idTo2d_y_lut[s.addr_dst_id]
  
  always_comb begin : update_sending_to_noc_msg
    send_to_inter_cgra_noc__val = crossbar__send__val[1'd0];
    crossbar__send__rdy[1'd0] = send_to_inter_cgra_noc__rdy;
    send_to_inter_cgra_noc__msg = crossbar__send__msg[1'd0].inter_cgra_pkt;
    if ( ( crossbar__send__msg[1'd0].inter_cgra_pkt.payload.cmd == 5'( __const__CMD_LOAD_REQUEST ) ) | ( crossbar__send__msg[1'd0].inter_cgra_pkt.payload.cmd == 5'( __const__CMD_STORE_REQUEST ) ) ) begin
      send_to_inter_cgra_noc__msg.dst = addr_dst_id;
      send_to_inter_cgra_noc__msg.dst_x = idTo2d_x_lut[addr_dst_id];
      send_to_inter_cgra_noc__msg.dst_y = idTo2d_y_lut[addr_dst_id];
    end
  end

  assign recv_from_tile_load_request_pkt_queue__clk = clk;
  assign recv_from_tile_load_request_pkt_queue__reset = reset;
  assign recv_from_tile_load_response_pkt_queue__clk = clk;
  assign recv_from_tile_load_response_pkt_queue__reset = reset;
  assign recv_from_tile_store_request_pkt_queue__clk = clk;
  assign recv_from_tile_store_request_pkt_queue__reset = reset;
  assign send_to_mem_load_request_queue__clk = clk;
  assign send_to_mem_load_request_queue__reset = reset;
  assign send_to_tile_load_response_queue__clk = clk;
  assign send_to_tile_load_response_queue__reset = reset;
  assign send_to_mem_store_request_queue__clk = clk;
  assign send_to_mem_store_request_queue__reset = reset;
  assign crossbar__clk = clk;
  assign crossbar__reset = reset;
  assign recv_from_cpu_pkt_queue__clk = clk;
  assign recv_from_cpu_pkt_queue__reset = reset;
  assign send_to_cpu_pkt_queue__clk = clk;
  assign send_to_cpu_pkt_queue__reset = reset;
  assign global_reduce_unit__clk = clk;
  assign global_reduce_unit__reset = reset;
  assign addr2controller_lut[0] = 2'd0;
  assign addr2controller_lut[1] = 2'd1;
  assign addr2controller_lut[2] = 2'd2;
  assign addr2controller_lut[3] = 2'd3;
  assign idTo2d_x_lut[0] = 2'd0;
  assign idTo2d_y_lut[0] = 1'd0;
  assign idTo2d_x_lut[1] = 2'd1;
  assign idTo2d_y_lut[1] = 1'd0;
  assign idTo2d_x_lut[2] = 2'd2;
  assign idTo2d_y_lut[2] = 1'd0;
  assign idTo2d_x_lut[3] = 2'd3;
  assign idTo2d_y_lut[3] = 1'd0;
  assign recv_from_tile_load_request_pkt_queue__recv__msg = recv_from_tile_load_request_pkt__msg;
  assign recv_from_tile_load_request_pkt__rdy = recv_from_tile_load_request_pkt_queue__recv__rdy;
  assign recv_from_tile_load_request_pkt_queue__recv__val = recv_from_tile_load_request_pkt__val;
  assign recv_from_tile_load_response_pkt_queue__recv__msg = recv_from_tile_load_response_pkt__msg;
  assign recv_from_tile_load_response_pkt__rdy = recv_from_tile_load_response_pkt_queue__recv__rdy;
  assign recv_from_tile_load_response_pkt_queue__recv__val = recv_from_tile_load_response_pkt__val;
  assign recv_from_tile_store_request_pkt_queue__recv__msg = recv_from_tile_store_request_pkt__msg;
  assign recv_from_tile_store_request_pkt__rdy = recv_from_tile_store_request_pkt_queue__recv__rdy;
  assign recv_from_tile_store_request_pkt_queue__recv__val = recv_from_tile_store_request_pkt__val;
  assign send_to_mem_load_request__msg = send_to_mem_load_request_queue__send__msg;
  assign send_to_mem_load_request_queue__send__rdy = send_to_mem_load_request__rdy;
  assign send_to_mem_load_request__val = send_to_mem_load_request_queue__send__val;
  assign send_to_tile_load_response__msg = send_to_tile_load_response_queue__send__msg;
  assign send_to_tile_load_response_queue__send__rdy = send_to_tile_load_response__rdy;
  assign send_to_tile_load_response__val = send_to_tile_load_response_queue__send__val;
  assign send_to_mem_store_request__msg = send_to_mem_store_request_queue__send__msg;
  assign send_to_mem_store_request_queue__send__rdy = send_to_mem_store_request__rdy;
  assign send_to_mem_store_request__val = send_to_mem_store_request_queue__send__val;
  assign recv_from_cpu_pkt_queue__recv__msg = recv_from_cpu_pkt__msg;
  assign recv_from_cpu_pkt__rdy = recv_from_cpu_pkt_queue__recv__rdy;
  assign recv_from_cpu_pkt_queue__recv__val = recv_from_cpu_pkt__val;
  assign send_to_cpu_pkt__msg = send_to_cpu_pkt_queue__send__msg;
  assign send_to_cpu_pkt_queue__send__rdy = send_to_cpu_pkt__rdy;
  assign send_to_cpu_pkt__val = send_to_cpu_pkt_queue__send__val;

endmodule


// PyMTL Component Counter Definition
// At /cgra/VectorCGRA/noc/PyOCN/pymtl3_net/ocnlib/rtl/Counter.py

module Counter__Type_Bits2__reset_value_2
(
  input  logic [0:0] clk ,
  output logic [1:0] count ,
  input  logic [0:0] decr ,
  input  logic [0:0] incr ,
  input  logic [0:0] load ,
  input  logic [1:0] load_value ,
  input  logic [0:0] reset 
);
  localparam logic [1:0] __const__reset_value_at_up_count  = 2'd2;

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/noc/PyOCN/pymtl3_net/ocnlib/rtl/Counter.py:28
  // @update_ff
  // def up_count():
  // 
  //   if s.reset:
  //     s.count <<= reset_value
  // 
  //   elif s.load:
  //     s.count <<= s.load_value
  // 
  //   elif s.incr & ~s.decr:
  //     s.count <<= s.count + 1
  // 
  //   elif ~s.incr & s.decr:
  //     s.count <<= s.count - 1
  
  always_ff @(posedge clk) begin : up_count
    if ( reset ) begin
      count <= 2'( __const__reset_value_at_up_count );
    end
    else if ( load ) begin
      count <= load_value;
    end
    else if ( incr & ( ~decr ) ) begin
      count <= count + 2'd1;
    end
    else if ( ( ~incr ) & decr ) begin
      count <= count - 2'd1;
    end
  end

endmodule


// PyMTL Component RecvRTL2CreditSendRTL Definition
// Full name: RecvRTL2CreditSendRTL__MsgType_IntraCgraPacket_4_4x1_4_8_2_CgraPayload__11cd3f8c0d91825c__vc_2__credit_line_2
// At /cgra/VectorCGRA/noc/PyOCN/pymtl3_net/ocnlib/ifcs/CreditIfc.py

module RecvRTL2CreditSendRTL__b299f27b560c5025
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input IntraCgraPacket_4_4x1_4_8_2_CgraPayload__11cd3f8c0d91825c recv__msg  ,
  output logic [0:0] recv__rdy  ,
  input logic [0:0] recv__val  ,
  output logic [0:0] send__en  ,
  output IntraCgraPacket_4_4x1_4_8_2_CgraPayload__11cd3f8c0d91825c send__msg  ,
  input logic [0:0] send__yum [0:1] 
);
  localparam logic [1:0] __const__vc_at_up_credit_send  = 2'd2;
  localparam logic [1:0] __const__vc_at_up_counter_decr  = 2'd2;
  //-------------------------------------------------------------
  // Component credit[0:1]
  //-------------------------------------------------------------

  logic [0:0] credit__clk [0:1];
  logic [1:0] credit__count [0:1];
  logic [0:0] credit__decr [0:1];
  logic [0:0] credit__incr [0:1];
  logic [0:0] credit__load [0:1];
  logic [1:0] credit__load_value [0:1];
  logic [0:0] credit__reset [0:1];

  Counter__Type_Bits2__reset_value_2 credit__0
  (
    .clk( credit__clk[0] ),
    .count( credit__count[0] ),
    .decr( credit__decr[0] ),
    .incr( credit__incr[0] ),
    .load( credit__load[0] ),
    .load_value( credit__load_value[0] ),
    .reset( credit__reset[0] )
  );

  Counter__Type_Bits2__reset_value_2 credit__1
  (
    .clk( credit__clk[1] ),
    .count( credit__count[1] ),
    .decr( credit__decr[1] ),
    .incr( credit__incr[1] ),
    .load( credit__load[1] ),
    .load_value( credit__load_value[1] ),
    .reset( credit__reset[1] )
  );

  //-------------------------------------------------------------
  // End of component credit[0:1]
  //-------------------------------------------------------------

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/noc/PyOCN/pymtl3_net/ocnlib/ifcs/CreditIfc.py:149
  // @update
  // def up_counter_decr():
  //   for i in range( vc ):
  //     s.credit[i].decr @= s.send.en & ( i == s.send.msg.vc_id )
  
  always_comb begin : up_counter_decr
    for ( int unsigned i = 1'd0; i < 2'( __const__vc_at_up_counter_decr ); i += 1'd1 )
      credit__decr[1'(i)] = send__en & ( 1'(i) == send__msg.vc_id );
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/noc/PyOCN/pymtl3_net/ocnlib/ifcs/CreditIfc.py:137
  // @update
  // def up_credit_send():
  //   s.send.en  @= 0
  //   s.recv.rdy @= 0
  //   # NOTE: recv.rdy depends on recv.val.
  //   #       Be careful about combinationl loop.
  //   if s.recv.val:
  //     for i in range( vc ):
  //       if ( i == s.recv.msg.vc_id ) & ( s.credit[i].count > 0 ):
  //         s.send.en  @= 1
  //         s.recv.rdy @= 1
  
  always_comb begin : up_credit_send
    send__en = 1'd0;
    recv__rdy = 1'd0;
    if ( recv__val ) begin
      for ( int unsigned i = 1'd0; i < 2'( __const__vc_at_up_credit_send ); i += 1'd1 )
        if ( ( 1'(i) == recv__msg.vc_id ) & ( credit__count[1'(i)] > 2'd0 ) ) begin
          send__en = 1'd1;
          recv__rdy = 1'd1;
        end
    end
  end

  assign credit__clk[0] = clk;
  assign credit__reset[0] = reset;
  assign credit__clk[1] = clk;
  assign credit__reset[1] = reset;
  assign send__msg = recv__msg;
  assign credit__incr[0] = send__yum[0];
  assign credit__load[0] = 1'd0;
  assign credit__load_value[0] = 2'd0;
  assign credit__incr[1] = send__yum[1];
  assign credit__load[1] = 1'd0;
  assign credit__load_value[1] = 2'd0;

endmodule


// PyMTL Component InputUnitCreditRTL Definition
// Full name: InputUnitCreditRTL__PacketType_IntraCgraPacket_4_4x1_4_8_2_CgraPayload__11cd3f8c0d91825c__QueueType_NormalQueueRTL__vc_2__credit_line_2
// At /cgra/VectorCGRA/noc/PyOCN/pymtl3_net/router/InputUnitCreditRTL.py

module InputUnitCreditRTL__d0e2ec98c86283e8
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input logic [0:0] recv__en  ,
  input IntraCgraPacket_4_4x1_4_8_2_CgraPayload__11cd3f8c0d91825c recv__msg  ,
  output logic [0:0] recv__yum [0:1] ,
  output IntraCgraPacket_4_4x1_4_8_2_CgraPayload__11cd3f8c0d91825c send__msg [0:1] ,
  input logic [0:0] send__rdy [0:1] ,
  output logic [0:0] send__val [0:1] 
);
  localparam logic [0:0] __const__i_at__lambda__s_dut_ctrl_ring_routers_0__input_units_0__recv_yum_0_  = 1'd0;
  localparam logic [0:0] __const__i_at__lambda__s_dut_ctrl_ring_routers_0__input_units_0__recv_yum_1_  = 1'd1;
  localparam logic [1:0] __const__vc_at_up_enq  = 2'd2;
  //-------------------------------------------------------------
  // Component buffers[0:1]
  //-------------------------------------------------------------

  logic [0:0] buffers__clk [0:1];
  logic [1:0] buffers__count [0:1];
  logic [0:0] buffers__reset [0:1];
  IntraCgraPacket_4_4x1_4_8_2_CgraPayload__11cd3f8c0d91825c buffers__recv__msg [0:1];
  logic [0:0] buffers__recv__rdy [0:1];
  logic [0:0] buffers__recv__val [0:1];
  IntraCgraPacket_4_4x1_4_8_2_CgraPayload__11cd3f8c0d91825c buffers__send__msg [0:1];
  logic [0:0] buffers__send__rdy [0:1];
  logic [0:0] buffers__send__val [0:1];

  NormalQueueRTL__4d91d5ee0229de22 buffers__0
  (
    .clk( buffers__clk[0] ),
    .count( buffers__count[0] ),
    .reset( buffers__reset[0] ),
    .recv__msg( buffers__recv__msg[0] ),
    .recv__rdy( buffers__recv__rdy[0] ),
    .recv__val( buffers__recv__val[0] ),
    .send__msg( buffers__send__msg[0] ),
    .send__rdy( buffers__send__rdy[0] ),
    .send__val( buffers__send__val[0] )
  );

  NormalQueueRTL__4d91d5ee0229de22 buffers__1
  (
    .clk( buffers__clk[1] ),
    .count( buffers__count[1] ),
    .reset( buffers__reset[1] ),
    .recv__msg( buffers__recv__msg[1] ),
    .recv__rdy( buffers__recv__rdy[1] ),
    .recv__val( buffers__recv__val[1] ),
    .send__msg( buffers__send__msg[1] ),
    .send__rdy( buffers__send__rdy[1] ),
    .send__val( buffers__send__val[1] )
  );

  //-------------------------------------------------------------
  // End of component buffers[0:1]
  //-------------------------------------------------------------

  // PyMTL Lambda Block Source
  // At /cgra/VectorCGRA/noc/PyOCN/pymtl3_net/router/InputUnitCreditRTL.py:39
  // s.recv.yum[i]         //= lambda: s.send[i].val & s.send[i].rdy
  
  always_comb begin : _lambda__s_dut_ctrl_ring_routers_0__input_units_0__recv_yum_0_
    recv__yum[1'd0] = send__val[1'( __const__i_at__lambda__s_dut_ctrl_ring_routers_0__input_units_0__recv_yum_0_ )] & send__rdy[1'( __const__i_at__lambda__s_dut_ctrl_ring_routers_0__input_units_0__recv_yum_0_ )];
  end

  // PyMTL Lambda Block Source
  // At /cgra/VectorCGRA/noc/PyOCN/pymtl3_net/router/InputUnitCreditRTL.py:39
  // s.recv.yum[i]         //= lambda: s.send[i].val & s.send[i].rdy
  
  always_comb begin : _lambda__s_dut_ctrl_ring_routers_0__input_units_0__recv_yum_1_
    recv__yum[1'd1] = send__val[1'( __const__i_at__lambda__s_dut_ctrl_ring_routers_0__input_units_0__recv_yum_1_ )] & send__rdy[1'( __const__i_at__lambda__s_dut_ctrl_ring_routers_0__input_units_0__recv_yum_1_ )];
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/noc/PyOCN/pymtl3_net/router/InputUnitCreditRTL.py:41
  // @update
  // def up_enq():
  //   if s.recv.en:
  //     for i in range( vc ):
  //       s.buffers[i].recv.val @= ( s.recv.msg.vc_id == i )
  //   else:
  //     for i in range( vc ):
  //       s.buffers[i].recv.val @= 0
  
  always_comb begin : up_enq
    if ( recv__en ) begin
      for ( int unsigned i = 1'd0; i < 2'( __const__vc_at_up_enq ); i += 1'd1 )
        buffers__recv__val[1'(i)] = recv__msg.vc_id == 1'(i);
    end
    else
      for ( int unsigned i = 1'd0; i < 2'( __const__vc_at_up_enq ); i += 1'd1 )
        buffers__recv__val[1'(i)] = 1'd0;
  end

  assign buffers__clk[0] = clk;
  assign buffers__reset[0] = reset;
  assign buffers__clk[1] = clk;
  assign buffers__reset[1] = reset;
  assign buffers__recv__msg[0] = recv__msg;
  assign send__msg[0] = buffers__send__msg[0];
  assign buffers__send__rdy[0] = send__rdy[0];
  assign send__val[0] = buffers__send__val[0];
  assign buffers__recv__msg[1] = recv__msg;
  assign send__msg[1] = buffers__send__msg[1];
  assign buffers__send__rdy[1] = send__rdy[1];
  assign send__val[1] = buffers__send__val[1];

endmodule


// PyMTL Component OutputUnitCreditRTL Definition
// Full name: OutputUnitCreditRTL__MsgType_IntraCgraPacket_4_4x1_4_8_2_CgraPayload__11cd3f8c0d91825c__vc_2__credit_line_2
// At /cgra/VectorCGRA/noc/PyOCN/pymtl3_net/router/OutputUnitCreditRTL.py

module OutputUnitCreditRTL__b299f27b560c5025
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input IntraCgraPacket_4_4x1_4_8_2_CgraPayload__11cd3f8c0d91825c recv__msg  ,
  output logic [0:0] recv__rdy  ,
  input logic [0:0] recv__val  ,
  output logic [0:0] send__en  ,
  output IntraCgraPacket_4_4x1_4_8_2_CgraPayload__11cd3f8c0d91825c send__msg  ,
  input logic [0:0] send__yum [0:1] 
);
  localparam logic [1:0] __const__vc_at_up_credit_send  = 2'd2;
  localparam logic [1:0] __const__vc_at_up_counter_decr  = 2'd2;
  //-------------------------------------------------------------
  // Component credit[0:1]
  //-------------------------------------------------------------

  logic [0:0] credit__clk [0:1];
  logic [1:0] credit__count [0:1];
  logic [0:0] credit__decr [0:1];
  logic [0:0] credit__incr [0:1];
  logic [0:0] credit__load [0:1];
  logic [1:0] credit__load_value [0:1];
  logic [0:0] credit__reset [0:1];

  Counter__Type_Bits2__reset_value_2 credit__0
  (
    .clk( credit__clk[0] ),
    .count( credit__count[0] ),
    .decr( credit__decr[0] ),
    .incr( credit__incr[0] ),
    .load( credit__load[0] ),
    .load_value( credit__load_value[0] ),
    .reset( credit__reset[0] )
  );

  Counter__Type_Bits2__reset_value_2 credit__1
  (
    .clk( credit__clk[1] ),
    .count( credit__count[1] ),
    .decr( credit__decr[1] ),
    .incr( credit__incr[1] ),
    .load( credit__load[1] ),
    .load_value( credit__load_value[1] ),
    .reset( credit__reset[1] )
  );

  //-------------------------------------------------------------
  // End of component credit[0:1]
  //-------------------------------------------------------------

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/noc/PyOCN/pymtl3_net/router/OutputUnitCreditRTL.py:47
  // @update
  // def up_counter_decr():
  //   for i in range( vc ):
  //     s.credit[i].decr @= s.send.en & ( i == s.send.msg.vc_id )
  
  always_comb begin : up_counter_decr
    for ( int unsigned i = 1'd0; i < 2'( __const__vc_at_up_counter_decr ); i += 1'd1 )
      credit__decr[1'(i)] = send__en & ( 1'(i) == send__msg.vc_id );
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/noc/PyOCN/pymtl3_net/router/OutputUnitCreditRTL.py:35
  // @update
  // def up_credit_send():
  //   s.send.en  @= 0
  //   s.recv.rdy @= 0
  //   # NOTE: Here the recv.rdy depends on recv.val.
  //   #       Be careful about combinational loop.
  //   if s.recv.val:
  //     for i in range( vc ):
  //       if (i == s.recv.msg.vc_id) & (s.credit[i].count > 0):
  //         s.send.en  @= 1
  //         s.recv.rdy @= 1
  
  always_comb begin : up_credit_send
    send__en = 1'd0;
    recv__rdy = 1'd0;
    if ( recv__val ) begin
      for ( int unsigned i = 1'd0; i < 2'( __const__vc_at_up_credit_send ); i += 1'd1 )
        if ( ( 1'(i) == recv__msg.vc_id ) & ( credit__count[1'(i)] > 2'd0 ) ) begin
          send__en = 1'd1;
          recv__rdy = 1'd1;
        end
    end
  end

  assign credit__clk[0] = clk;
  assign credit__reset[0] = reset;
  assign credit__clk[1] = clk;
  assign credit__reset[1] = reset;
  assign send__msg = recv__msg;
  assign credit__incr[0] = send__yum[0];
  assign credit__load[0] = 1'd0;
  assign credit__load_value[0] = 2'd0;
  assign credit__incr[1] = send__yum[1];
  assign credit__load[1] = 1'd0;
  assign credit__load_value[1] = 2'd0;

endmodule


// PyMTL Component RingRouteUnitRTL Definition
// Full name: RingRouteUnitRTL__PacketType_IntraCgraPacket_4_4x1_4_8_2_CgraPayload__11cd3f8c0d91825c__PositionType_Bits3__num_routers_5
// At /cgra/VectorCGRA/noc/PyOCN/pymtl3_net/ringnet/RingRouteUnitRTL.py

module RingRouteUnitRTL__ebc4c4285a30cd6a
(
  input  logic [0:0] clk ,
  input  logic [2:0] pos ,
  input  logic [0:0] reset ,
  input IntraCgraPacket_4_4x1_4_8_2_CgraPayload__11cd3f8c0d91825c recv__msg  ,
  output logic [0:0] recv__rdy  ,
  input logic [0:0] recv__val  ,
  output IntraCgraPacket_4_4x1_4_8_2_CgraPayload__11cd3f8c0d91825c send__msg [0:2] ,
  input logic [0:0] send__rdy [0:2] ,
  output logic [0:0] send__val [0:2] 
);
  localparam logic [1:0] __const__SELF  = 2'd2;
  localparam logic [0:0] __const__LEFT  = 1'd0;
  localparam logic [0:0] __const__RIGHT  = 1'd1;
  logic [2:0] left_dist;
  logic [1:0] out_dir;
  logic [2:0] right_dist;
  IntraCgraPacket_4_4x1_4_8_2_CgraPayload__11cd3f8c0d91825c send_msg_wire;
  logic [2:0] send_rdy;

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/noc/PyOCN/pymtl3_net/ringnet/RingRouteUnitRTL.py:51
  // @update
  // def up_left_right_dist():
  //   if s.recv.msg.dst < s.pos:
  //     s.left_dist  @= zext(s.pos, DistType) - zext(s.recv.msg.dst, DistType)
  //     s.right_dist @= zext(s.last_idx, DistType) - zext(s.pos, DistType) + zext(s.recv.msg.dst, DistType) + 1
  //   else:
  //     s.left_dist  @= 1 + zext(s.last_idx, DistType) + zext(s.pos, DistType) - zext(s.recv.msg.dst, DistType)
  //     s.right_dist @= zext(s.recv.msg.dst, DistType) - zext(s.pos, DistType)
  
  always_comb begin : up_left_right_dist
    if ( recv__msg.dst < pos ) begin
      left_dist = pos - recv__msg.dst;
      right_dist = ( ( 3'd4 - pos ) + recv__msg.dst ) + 3'd1;
    end
    else begin
      left_dist = ( ( 3'd1 + 3'd4 ) + pos ) - recv__msg.dst;
      right_dist = recv__msg.dst - pos;
    end
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/noc/PyOCN/pymtl3_net/ringnet/RingRouteUnitRTL.py:85
  // @update
  // def up_ru_recv_rdy():
  //   s.recv.rdy @= s.send_rdy[ s.out_dir ]
  
  always_comb begin : up_ru_recv_rdy
    recv__rdy = send_rdy[out_dir];
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/noc/PyOCN/pymtl3_net/ringnet/RingRouteUnitRTL.py:60
  // @update
  // def up_ru_routing():
  // 
  //   s.out_dir @= 0
  //   s.send_msg_wire @= s.recv.msg
  //   for i in range( s.num_outports ):
  //     s.send[i].val @= 0
  //     s.send[i].msg @= s.recv.msg
  // 
  //   if s.recv.val:
  //     if s.pos == s.recv.msg.dst:
  //       s.out_dir @= SELF
  //     elif s.left_dist < s.right_dist:
  //       s.out_dir @= LEFT
  //     else:
  //       s.out_dir @= RIGHT
  // 
  //     if ( s.pos == s.last_idx ) & ( s.out_dir == RIGHT ):
  //       s.send_msg_wire.vc_id @= 1
  //     elif ( s.pos == 0 ) & ( s.out_dir == LEFT ):
  //       s.send_msg_wire.vc_id @= 1
  // 
  //     s.send[ s.out_dir ].val @= 1
  //     s.send[ s.out_dir ].msg @= s.send_msg_wire
  
  always_comb begin : up_ru_routing
    out_dir = 2'd0;
    send_msg_wire = recv__msg;
    for ( int unsigned i = 1'd0; i < 2'd3; i += 1'd1 ) begin
      send__val[2'(i)] = 1'd0;
      send__msg[2'(i)] = recv__msg;
    end
    if ( recv__val ) begin
      if ( pos == recv__msg.dst ) begin
        out_dir = 2'( __const__SELF );
      end
      else if ( left_dist < right_dist ) begin
        out_dir = 2'( __const__LEFT );
      end
      else
        out_dir = 2'( __const__RIGHT );
      if ( ( pos == 3'd4 ) & ( out_dir == 2'( __const__RIGHT ) ) ) begin
        send_msg_wire.vc_id = 1'd1;
      end
      else if ( ( pos == 3'd0 ) & ( out_dir == 2'( __const__LEFT ) ) ) begin
        send_msg_wire.vc_id = 1'd1;
      end
      send__val[out_dir] = 1'd1;
      send__msg[out_dir] = send_msg_wire;
    end
  end

  assign send_rdy[0:0] = send__rdy[0];
  assign send_rdy[1:1] = send__rdy[1];
  assign send_rdy[2:2] = send__rdy[2];

endmodule


// PyMTL Component Mux Definition
// Full name: Mux__Type_IntraCgraPacket_4_4x1_4_8_2_CgraPayload__11cd3f8c0d91825c__ninputs_6
// At /cgra/venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/arithmetics.py

module Mux__8c935bf8b6adc0e3
(
  input  logic [0:0] clk ,
  input  IntraCgraPacket_4_4x1_4_8_2_CgraPayload__11cd3f8c0d91825c in_ [0:5],
  output IntraCgraPacket_4_4x1_4_8_2_CgraPayload__11cd3f8c0d91825c out ,
  input  logic [0:0] reset ,
  input  logic [2:0] sel 
);

  // PyMTL Update Block Source
  // At /cgra/venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/arithmetics.py:13
  // @update
  // def up_mux():
  //   s.out @= s.in_[ s.sel ]
  
  always_comb begin : up_mux
    out = in_[sel];
  end

endmodule


// PyMTL Component SwitchUnitRTL Definition
// Full name: SwitchUnitRTL__PacketType_IntraCgraPacket_4_4x1_4_8_2_CgraPayload__11cd3f8c0d91825c__num_inports_6
// At /cgra/VectorCGRA/noc/PyOCN/pymtl3_net/router/SwitchUnitRTL.py

module SwitchUnitRTL__559e235c7e27ff40
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input IntraCgraPacket_4_4x1_4_8_2_CgraPayload__11cd3f8c0d91825c recv__msg [0:5] ,
  output logic [0:0] recv__rdy [0:5] ,
  input logic [0:0] recv__val [0:5] ,
  output IntraCgraPacket_4_4x1_4_8_2_CgraPayload__11cd3f8c0d91825c send__msg  ,
  input logic [0:0] send__rdy  ,
  output logic [0:0] send__val  
);
  localparam logic [2:0] __const__num_inports_at_up_get_en  = 3'd6;
  //-------------------------------------------------------------
  // Component arbiter
  //-------------------------------------------------------------

  logic [0:0] arbiter__clk;
  logic [0:0] arbiter__en;
  logic [5:0] arbiter__grants;
  logic [5:0] arbiter__reqs;
  logic [0:0] arbiter__reset;

  RoundRobinArbiterEn__nreqs_6 arbiter
  (
    .clk( arbiter__clk ),
    .en( arbiter__en ),
    .grants( arbiter__grants ),
    .reqs( arbiter__reqs ),
    .reset( arbiter__reset )
  );

  //-------------------------------------------------------------
  // End of component arbiter
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component encoder
  //-------------------------------------------------------------

  logic [0:0] encoder__clk;
  logic [5:0] encoder__in_;
  logic [2:0] encoder__out;
  logic [0:0] encoder__reset;

  Encoder__in_nbits_6__out_nbits_3 encoder
  (
    .clk( encoder__clk ),
    .in_( encoder__in_ ),
    .out( encoder__out ),
    .reset( encoder__reset )
  );

  //-------------------------------------------------------------
  // End of component encoder
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component mux
  //-------------------------------------------------------------

  logic [0:0] mux__clk;
  IntraCgraPacket_4_4x1_4_8_2_CgraPayload__11cd3f8c0d91825c mux__in_ [0:5];
  IntraCgraPacket_4_4x1_4_8_2_CgraPayload__11cd3f8c0d91825c mux__out;
  logic [0:0] mux__reset;
  logic [2:0] mux__sel;

  Mux__8c935bf8b6adc0e3 mux
  (
    .clk( mux__clk ),
    .in_( mux__in_ ),
    .out( mux__out ),
    .reset( mux__reset ),
    .sel( mux__sel )
  );

  //-------------------------------------------------------------
  // End of component mux
  //-------------------------------------------------------------

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/noc/PyOCN/pymtl3_net/router/SwitchUnitRTL.py:56
  // @update
  // def up_get_en():
  //   for i in range( num_inports ):
  //     s.recv[i].rdy @= s.send.rdy & ( s.mux.sel == i )
  
  always_comb begin : up_get_en
    for ( int unsigned i = 1'd0; i < 3'( __const__num_inports_at_up_get_en ); i += 1'd1 )
      recv__rdy[3'(i)] = send__rdy & ( mux__sel == 3'(i) );
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/noc/PyOCN/pymtl3_net/router/SwitchUnitRTL.py:51
  // @update
  // def up_send_val():
  //   s.send.val @= s.arbiter.grants > 0
  
  always_comb begin : up_send_val
    send__val = arbiter__grants > 6'd0;
  end

  assign arbiter__clk = clk;
  assign arbiter__reset = reset;
  assign arbiter__en = 1'd1;
  assign mux__clk = clk;
  assign mux__reset = reset;
  assign send__msg = mux__out;
  assign encoder__clk = clk;
  assign encoder__reset = reset;
  assign encoder__in_ = arbiter__grants;
  assign mux__sel = encoder__out;
  assign arbiter__reqs[0:0] = recv__val[0];
  assign mux__in_[0] = recv__msg[0];
  assign arbiter__reqs[1:1] = recv__val[1];
  assign mux__in_[1] = recv__msg[1];
  assign arbiter__reqs[2:2] = recv__val[2];
  assign mux__in_[2] = recv__msg[2];
  assign arbiter__reqs[3:3] = recv__val[3];
  assign mux__in_[3] = recv__msg[3];
  assign arbiter__reqs[4:4] = recv__val[4];
  assign mux__in_[4] = recv__msg[4];
  assign arbiter__reqs[5:5] = recv__val[5];
  assign mux__in_[5] = recv__msg[5];

endmodule


// PyMTL Component RingRouterRTL Definition
// Full name: RingRouterRTL__PacketType_IntraCgraPacket_4_4x1_4_8_2_CgraPayload__11cd3f8c0d91825c__PositionType_Bits3__num_routers_5__InputUnitType_InputUnitCreditRTL__RouteUnitType_RingRouteUnitRTL__SwitchUnitType_SwitchUnitRTL__OutputUnitType_OutputUnitCreditRTL__vc_2__credit_line_2
// At /cgra/VectorCGRA/noc/PyOCN/pymtl3_net/ringnet/RingRouterRTL.py

module RingRouterRTL__795a7ef5c610671c
(
  input  logic [0:0] clk ,
  input  logic [2:0] pos ,
  input  logic [0:0] reset ,
  input logic [0:0] recv__en [0:2] ,
  input IntraCgraPacket_4_4x1_4_8_2_CgraPayload__11cd3f8c0d91825c recv__msg [0:2] ,
  output logic [0:0] recv__yum [0:2][0:1] ,
  output logic [0:0] send__en [0:2] ,
  output IntraCgraPacket_4_4x1_4_8_2_CgraPayload__11cd3f8c0d91825c send__msg [0:2] ,
  input logic [0:0] send__yum [0:2][0:1] 
);
  //-------------------------------------------------------------
  // Component input_units[0:2]
  //-------------------------------------------------------------

  logic [0:0] input_units__clk [0:2];
  logic [0:0] input_units__reset [0:2];
  logic [0:0] input_units__recv__en [0:2];
  IntraCgraPacket_4_4x1_4_8_2_CgraPayload__11cd3f8c0d91825c input_units__recv__msg [0:2];
  logic [0:0] input_units__recv__yum [0:2][0:1];
  IntraCgraPacket_4_4x1_4_8_2_CgraPayload__11cd3f8c0d91825c input_units__send__msg [0:2][0:1];
  logic [0:0] input_units__send__rdy [0:2][0:1];
  logic [0:0] input_units__send__val [0:2][0:1];

  InputUnitCreditRTL__d0e2ec98c86283e8 input_units__0
  (
    .clk( input_units__clk[0] ),
    .reset( input_units__reset[0] ),
    .recv__en( input_units__recv__en[0] ),
    .recv__msg( input_units__recv__msg[0] ),
    .recv__yum( input_units__recv__yum[0] ),
    .send__msg( input_units__send__msg[0] ),
    .send__rdy( input_units__send__rdy[0] ),
    .send__val( input_units__send__val[0] )
  );

  InputUnitCreditRTL__d0e2ec98c86283e8 input_units__1
  (
    .clk( input_units__clk[1] ),
    .reset( input_units__reset[1] ),
    .recv__en( input_units__recv__en[1] ),
    .recv__msg( input_units__recv__msg[1] ),
    .recv__yum( input_units__recv__yum[1] ),
    .send__msg( input_units__send__msg[1] ),
    .send__rdy( input_units__send__rdy[1] ),
    .send__val( input_units__send__val[1] )
  );

  InputUnitCreditRTL__d0e2ec98c86283e8 input_units__2
  (
    .clk( input_units__clk[2] ),
    .reset( input_units__reset[2] ),
    .recv__en( input_units__recv__en[2] ),
    .recv__msg( input_units__recv__msg[2] ),
    .recv__yum( input_units__recv__yum[2] ),
    .send__msg( input_units__send__msg[2] ),
    .send__rdy( input_units__send__rdy[2] ),
    .send__val( input_units__send__val[2] )
  );

  //-------------------------------------------------------------
  // End of component input_units[0:2]
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component output_units[0:2]
  //-------------------------------------------------------------

  logic [0:0] output_units__clk [0:2];
  logic [0:0] output_units__reset [0:2];
  IntraCgraPacket_4_4x1_4_8_2_CgraPayload__11cd3f8c0d91825c output_units__recv__msg [0:2];
  logic [0:0] output_units__recv__rdy [0:2];
  logic [0:0] output_units__recv__val [0:2];
  logic [0:0] output_units__send__en [0:2];
  IntraCgraPacket_4_4x1_4_8_2_CgraPayload__11cd3f8c0d91825c output_units__send__msg [0:2];
  logic [0:0] output_units__send__yum [0:2][0:1];

  OutputUnitCreditRTL__b299f27b560c5025 output_units__0
  (
    .clk( output_units__clk[0] ),
    .reset( output_units__reset[0] ),
    .recv__msg( output_units__recv__msg[0] ),
    .recv__rdy( output_units__recv__rdy[0] ),
    .recv__val( output_units__recv__val[0] ),
    .send__en( output_units__send__en[0] ),
    .send__msg( output_units__send__msg[0] ),
    .send__yum( output_units__send__yum[0] )
  );

  OutputUnitCreditRTL__b299f27b560c5025 output_units__1
  (
    .clk( output_units__clk[1] ),
    .reset( output_units__reset[1] ),
    .recv__msg( output_units__recv__msg[1] ),
    .recv__rdy( output_units__recv__rdy[1] ),
    .recv__val( output_units__recv__val[1] ),
    .send__en( output_units__send__en[1] ),
    .send__msg( output_units__send__msg[1] ),
    .send__yum( output_units__send__yum[1] )
  );

  OutputUnitCreditRTL__b299f27b560c5025 output_units__2
  (
    .clk( output_units__clk[2] ),
    .reset( output_units__reset[2] ),
    .recv__msg( output_units__recv__msg[2] ),
    .recv__rdy( output_units__recv__rdy[2] ),
    .recv__val( output_units__recv__val[2] ),
    .send__en( output_units__send__en[2] ),
    .send__msg( output_units__send__msg[2] ),
    .send__yum( output_units__send__yum[2] )
  );

  //-------------------------------------------------------------
  // End of component output_units[0:2]
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component route_units[0:5]
  //-------------------------------------------------------------

  logic [0:0] route_units__clk [0:5];
  logic [2:0] route_units__pos [0:5];
  logic [0:0] route_units__reset [0:5];
  IntraCgraPacket_4_4x1_4_8_2_CgraPayload__11cd3f8c0d91825c route_units__recv__msg [0:5];
  logic [0:0] route_units__recv__rdy [0:5];
  logic [0:0] route_units__recv__val [0:5];
  IntraCgraPacket_4_4x1_4_8_2_CgraPayload__11cd3f8c0d91825c route_units__send__msg [0:5][0:2];
  logic [0:0] route_units__send__rdy [0:5][0:2];
  logic [0:0] route_units__send__val [0:5][0:2];

  RingRouteUnitRTL__ebc4c4285a30cd6a route_units__0
  (
    .clk( route_units__clk[0] ),
    .pos( route_units__pos[0] ),
    .reset( route_units__reset[0] ),
    .recv__msg( route_units__recv__msg[0] ),
    .recv__rdy( route_units__recv__rdy[0] ),
    .recv__val( route_units__recv__val[0] ),
    .send__msg( route_units__send__msg[0] ),
    .send__rdy( route_units__send__rdy[0] ),
    .send__val( route_units__send__val[0] )
  );

  RingRouteUnitRTL__ebc4c4285a30cd6a route_units__1
  (
    .clk( route_units__clk[1] ),
    .pos( route_units__pos[1] ),
    .reset( route_units__reset[1] ),
    .recv__msg( route_units__recv__msg[1] ),
    .recv__rdy( route_units__recv__rdy[1] ),
    .recv__val( route_units__recv__val[1] ),
    .send__msg( route_units__send__msg[1] ),
    .send__rdy( route_units__send__rdy[1] ),
    .send__val( route_units__send__val[1] )
  );

  RingRouteUnitRTL__ebc4c4285a30cd6a route_units__2
  (
    .clk( route_units__clk[2] ),
    .pos( route_units__pos[2] ),
    .reset( route_units__reset[2] ),
    .recv__msg( route_units__recv__msg[2] ),
    .recv__rdy( route_units__recv__rdy[2] ),
    .recv__val( route_units__recv__val[2] ),
    .send__msg( route_units__send__msg[2] ),
    .send__rdy( route_units__send__rdy[2] ),
    .send__val( route_units__send__val[2] )
  );

  RingRouteUnitRTL__ebc4c4285a30cd6a route_units__3
  (
    .clk( route_units__clk[3] ),
    .pos( route_units__pos[3] ),
    .reset( route_units__reset[3] ),
    .recv__msg( route_units__recv__msg[3] ),
    .recv__rdy( route_units__recv__rdy[3] ),
    .recv__val( route_units__recv__val[3] ),
    .send__msg( route_units__send__msg[3] ),
    .send__rdy( route_units__send__rdy[3] ),
    .send__val( route_units__send__val[3] )
  );

  RingRouteUnitRTL__ebc4c4285a30cd6a route_units__4
  (
    .clk( route_units__clk[4] ),
    .pos( route_units__pos[4] ),
    .reset( route_units__reset[4] ),
    .recv__msg( route_units__recv__msg[4] ),
    .recv__rdy( route_units__recv__rdy[4] ),
    .recv__val( route_units__recv__val[4] ),
    .send__msg( route_units__send__msg[4] ),
    .send__rdy( route_units__send__rdy[4] ),
    .send__val( route_units__send__val[4] )
  );

  RingRouteUnitRTL__ebc4c4285a30cd6a route_units__5
  (
    .clk( route_units__clk[5] ),
    .pos( route_units__pos[5] ),
    .reset( route_units__reset[5] ),
    .recv__msg( route_units__recv__msg[5] ),
    .recv__rdy( route_units__recv__rdy[5] ),
    .recv__val( route_units__recv__val[5] ),
    .send__msg( route_units__send__msg[5] ),
    .send__rdy( route_units__send__rdy[5] ),
    .send__val( route_units__send__val[5] )
  );

  //-------------------------------------------------------------
  // End of component route_units[0:5]
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component switch_units[0:2]
  //-------------------------------------------------------------

  logic [0:0] switch_units__clk [0:2];
  logic [0:0] switch_units__reset [0:2];
  IntraCgraPacket_4_4x1_4_8_2_CgraPayload__11cd3f8c0d91825c switch_units__recv__msg [0:2][0:5];
  logic [0:0] switch_units__recv__rdy [0:2][0:5];
  logic [0:0] switch_units__recv__val [0:2][0:5];
  IntraCgraPacket_4_4x1_4_8_2_CgraPayload__11cd3f8c0d91825c switch_units__send__msg [0:2];
  logic [0:0] switch_units__send__rdy [0:2];
  logic [0:0] switch_units__send__val [0:2];

  SwitchUnitRTL__559e235c7e27ff40 switch_units__0
  (
    .clk( switch_units__clk[0] ),
    .reset( switch_units__reset[0] ),
    .recv__msg( switch_units__recv__msg[0] ),
    .recv__rdy( switch_units__recv__rdy[0] ),
    .recv__val( switch_units__recv__val[0] ),
    .send__msg( switch_units__send__msg[0] ),
    .send__rdy( switch_units__send__rdy[0] ),
    .send__val( switch_units__send__val[0] )
  );

  SwitchUnitRTL__559e235c7e27ff40 switch_units__1
  (
    .clk( switch_units__clk[1] ),
    .reset( switch_units__reset[1] ),
    .recv__msg( switch_units__recv__msg[1] ),
    .recv__rdy( switch_units__recv__rdy[1] ),
    .recv__val( switch_units__recv__val[1] ),
    .send__msg( switch_units__send__msg[1] ),
    .send__rdy( switch_units__send__rdy[1] ),
    .send__val( switch_units__send__val[1] )
  );

  SwitchUnitRTL__559e235c7e27ff40 switch_units__2
  (
    .clk( switch_units__clk[2] ),
    .reset( switch_units__reset[2] ),
    .recv__msg( switch_units__recv__msg[2] ),
    .recv__rdy( switch_units__recv__rdy[2] ),
    .recv__val( switch_units__recv__val[2] ),
    .send__msg( switch_units__send__msg[2] ),
    .send__rdy( switch_units__send__rdy[2] ),
    .send__val( switch_units__send__val[2] )
  );

  //-------------------------------------------------------------
  // End of component switch_units[0:2]
  //-------------------------------------------------------------

  assign input_units__clk[0] = clk;
  assign input_units__reset[0] = reset;
  assign input_units__clk[1] = clk;
  assign input_units__reset[1] = reset;
  assign input_units__clk[2] = clk;
  assign input_units__reset[2] = reset;
  assign route_units__clk[0] = clk;
  assign route_units__reset[0] = reset;
  assign route_units__clk[1] = clk;
  assign route_units__reset[1] = reset;
  assign route_units__clk[2] = clk;
  assign route_units__reset[2] = reset;
  assign route_units__clk[3] = clk;
  assign route_units__reset[3] = reset;
  assign route_units__clk[4] = clk;
  assign route_units__reset[4] = reset;
  assign route_units__clk[5] = clk;
  assign route_units__reset[5] = reset;
  assign switch_units__clk[0] = clk;
  assign switch_units__reset[0] = reset;
  assign switch_units__clk[1] = clk;
  assign switch_units__reset[1] = reset;
  assign switch_units__clk[2] = clk;
  assign switch_units__reset[2] = reset;
  assign output_units__clk[0] = clk;
  assign output_units__reset[0] = reset;
  assign output_units__clk[1] = clk;
  assign output_units__reset[1] = reset;
  assign output_units__clk[2] = clk;
  assign output_units__reset[2] = reset;
  assign input_units__recv__en[0] = recv__en[0];
  assign input_units__recv__msg[0] = recv__msg[0];
  assign recv__yum[0][0] = input_units__recv__yum[0][0];
  assign recv__yum[0][1] = input_units__recv__yum[0][1];
  assign route_units__recv__msg[0] = input_units__send__msg[0][0];
  assign input_units__send__rdy[0][0] = route_units__recv__rdy[0];
  assign route_units__recv__val[0] = input_units__send__val[0][0];
  assign route_units__pos[0] = pos;
  assign route_units__recv__msg[1] = input_units__send__msg[0][1];
  assign input_units__send__rdy[0][1] = route_units__recv__rdy[1];
  assign route_units__recv__val[1] = input_units__send__val[0][1];
  assign route_units__pos[1] = pos;
  assign input_units__recv__en[1] = recv__en[1];
  assign input_units__recv__msg[1] = recv__msg[1];
  assign recv__yum[1][0] = input_units__recv__yum[1][0];
  assign recv__yum[1][1] = input_units__recv__yum[1][1];
  assign route_units__recv__msg[2] = input_units__send__msg[1][0];
  assign input_units__send__rdy[1][0] = route_units__recv__rdy[2];
  assign route_units__recv__val[2] = input_units__send__val[1][0];
  assign route_units__pos[2] = pos;
  assign route_units__recv__msg[3] = input_units__send__msg[1][1];
  assign input_units__send__rdy[1][1] = route_units__recv__rdy[3];
  assign route_units__recv__val[3] = input_units__send__val[1][1];
  assign route_units__pos[3] = pos;
  assign input_units__recv__en[2] = recv__en[2];
  assign input_units__recv__msg[2] = recv__msg[2];
  assign recv__yum[2][0] = input_units__recv__yum[2][0];
  assign recv__yum[2][1] = input_units__recv__yum[2][1];
  assign route_units__recv__msg[4] = input_units__send__msg[2][0];
  assign input_units__send__rdy[2][0] = route_units__recv__rdy[4];
  assign route_units__recv__val[4] = input_units__send__val[2][0];
  assign route_units__pos[4] = pos;
  assign route_units__recv__msg[5] = input_units__send__msg[2][1];
  assign input_units__send__rdy[2][1] = route_units__recv__rdy[5];
  assign route_units__recv__val[5] = input_units__send__val[2][1];
  assign route_units__pos[5] = pos;
  assign switch_units__recv__msg[0][0] = route_units__send__msg[0][0];
  assign route_units__send__rdy[0][0] = switch_units__recv__rdy[0][0];
  assign switch_units__recv__val[0][0] = route_units__send__val[0][0];
  assign switch_units__recv__msg[1][0] = route_units__send__msg[0][1];
  assign route_units__send__rdy[0][1] = switch_units__recv__rdy[1][0];
  assign switch_units__recv__val[1][0] = route_units__send__val[0][1];
  assign switch_units__recv__msg[2][0] = route_units__send__msg[0][2];
  assign route_units__send__rdy[0][2] = switch_units__recv__rdy[2][0];
  assign switch_units__recv__val[2][0] = route_units__send__val[0][2];
  assign switch_units__recv__msg[0][1] = route_units__send__msg[1][0];
  assign route_units__send__rdy[1][0] = switch_units__recv__rdy[0][1];
  assign switch_units__recv__val[0][1] = route_units__send__val[1][0];
  assign switch_units__recv__msg[1][1] = route_units__send__msg[1][1];
  assign route_units__send__rdy[1][1] = switch_units__recv__rdy[1][1];
  assign switch_units__recv__val[1][1] = route_units__send__val[1][1];
  assign switch_units__recv__msg[2][1] = route_units__send__msg[1][2];
  assign route_units__send__rdy[1][2] = switch_units__recv__rdy[2][1];
  assign switch_units__recv__val[2][1] = route_units__send__val[1][2];
  assign switch_units__recv__msg[0][2] = route_units__send__msg[2][0];
  assign route_units__send__rdy[2][0] = switch_units__recv__rdy[0][2];
  assign switch_units__recv__val[0][2] = route_units__send__val[2][0];
  assign switch_units__recv__msg[1][2] = route_units__send__msg[2][1];
  assign route_units__send__rdy[2][1] = switch_units__recv__rdy[1][2];
  assign switch_units__recv__val[1][2] = route_units__send__val[2][1];
  assign switch_units__recv__msg[2][2] = route_units__send__msg[2][2];
  assign route_units__send__rdy[2][2] = switch_units__recv__rdy[2][2];
  assign switch_units__recv__val[2][2] = route_units__send__val[2][2];
  assign switch_units__recv__msg[0][3] = route_units__send__msg[3][0];
  assign route_units__send__rdy[3][0] = switch_units__recv__rdy[0][3];
  assign switch_units__recv__val[0][3] = route_units__send__val[3][0];
  assign switch_units__recv__msg[1][3] = route_units__send__msg[3][1];
  assign route_units__send__rdy[3][1] = switch_units__recv__rdy[1][3];
  assign switch_units__recv__val[1][3] = route_units__send__val[3][1];
  assign switch_units__recv__msg[2][3] = route_units__send__msg[3][2];
  assign route_units__send__rdy[3][2] = switch_units__recv__rdy[2][3];
  assign switch_units__recv__val[2][3] = route_units__send__val[3][2];
  assign switch_units__recv__msg[0][4] = route_units__send__msg[4][0];
  assign route_units__send__rdy[4][0] = switch_units__recv__rdy[0][4];
  assign switch_units__recv__val[0][4] = route_units__send__val[4][0];
  assign switch_units__recv__msg[1][4] = route_units__send__msg[4][1];
  assign route_units__send__rdy[4][1] = switch_units__recv__rdy[1][4];
  assign switch_units__recv__val[1][4] = route_units__send__val[4][1];
  assign switch_units__recv__msg[2][4] = route_units__send__msg[4][2];
  assign route_units__send__rdy[4][2] = switch_units__recv__rdy[2][4];
  assign switch_units__recv__val[2][4] = route_units__send__val[4][2];
  assign switch_units__recv__msg[0][5] = route_units__send__msg[5][0];
  assign route_units__send__rdy[5][0] = switch_units__recv__rdy[0][5];
  assign switch_units__recv__val[0][5] = route_units__send__val[5][0];
  assign switch_units__recv__msg[1][5] = route_units__send__msg[5][1];
  assign route_units__send__rdy[5][1] = switch_units__recv__rdy[1][5];
  assign switch_units__recv__val[1][5] = route_units__send__val[5][1];
  assign switch_units__recv__msg[2][5] = route_units__send__msg[5][2];
  assign route_units__send__rdy[5][2] = switch_units__recv__rdy[2][5];
  assign switch_units__recv__val[2][5] = route_units__send__val[5][2];
  assign output_units__recv__msg[0] = switch_units__send__msg[0];
  assign switch_units__send__rdy[0] = output_units__recv__rdy[0];
  assign output_units__recv__val[0] = switch_units__send__val[0];
  assign send__en[0] = output_units__send__en[0];
  assign send__msg[0] = output_units__send__msg[0];
  assign output_units__send__yum[0][0] = send__yum[0][0];
  assign output_units__send__yum[0][1] = send__yum[0][1];
  assign output_units__recv__msg[1] = switch_units__send__msg[1];
  assign switch_units__send__rdy[1] = output_units__recv__rdy[1];
  assign output_units__recv__val[1] = switch_units__send__val[1];
  assign send__en[1] = output_units__send__en[1];
  assign send__msg[1] = output_units__send__msg[1];
  assign output_units__send__yum[1][0] = send__yum[1][0];
  assign output_units__send__yum[1][1] = send__yum[1][1];
  assign output_units__recv__msg[2] = switch_units__send__msg[2];
  assign switch_units__send__rdy[2] = output_units__recv__rdy[2];
  assign output_units__recv__val[2] = switch_units__send__val[2];
  assign send__en[2] = output_units__send__en[2];
  assign send__msg[2] = output_units__send__msg[2];
  assign output_units__send__yum[2][0] = send__yum[2][0];
  assign output_units__send__yum[2][1] = send__yum[2][1];

endmodule


// PyMTL Component RegEnRst Definition
// At /cgra/venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/registers.py

module RegEnRst__Type_Bits2__reset_value_1
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  input  logic [1:0] in_ ,
  output logic [1:0] out ,
  input  logic [0:0] reset 
);
  localparam logic [0:0] __const__reset_value_at_up_regenrst  = 1'd1;

  // PyMTL Update Block Source
  // At /cgra/venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/registers.py:55
  // @update_ff
  // def up_regenrst():
  //   if s.reset: s.out <<= reset_value
  //   elif s.en:  s.out <<= s.in_
  
  always_ff @(posedge clk) begin : up_regenrst
    if ( reset ) begin
      out <= 2'( __const__reset_value_at_up_regenrst );
    end
    else if ( en ) begin
      out <= in_;
    end
  end

endmodule


// PyMTL Component RoundRobinArbiterEn Definition
// At /cgra/venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/arbiters.py

module RoundRobinArbiterEn__nreqs_2
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  output logic [1:0] grants ,
  input  logic [1:0] reqs ,
  input  logic [0:0] reset 
);
  localparam logic [1:0] __const__nreqs_at_comb_reqs_int  = 2'd2;
  localparam logic [2:0] __const__nreqsX2_at_comb_reqs_int  = 3'd4;
  localparam logic [1:0] __const__nreqs_at_comb_grants  = 2'd2;
  localparam logic [1:0] __const__nreqs_at_comb_priority_int  = 2'd2;
  localparam logic [2:0] __const__nreqsX2_at_comb_priority_int  = 3'd4;
  localparam logic [2:0] __const__nreqsX2_at_comb_kills  = 3'd4;
  localparam logic [2:0] __const__nreqsX2_at_comb_grants_int  = 3'd4;
  logic [3:0] grants_int;
  logic [4:0] kills;
  logic [0:0] priority_en;
  logic [3:0] priority_int;
  logic [3:0] reqs_int;
  //-------------------------------------------------------------
  // Component priority_reg
  //-------------------------------------------------------------

  logic [0:0] priority_reg__clk;
  logic [0:0] priority_reg__en;
  logic [1:0] priority_reg__in_;
  logic [1:0] priority_reg__out;
  logic [0:0] priority_reg__reset;

  RegEnRst__Type_Bits2__reset_value_1 priority_reg
  (
    .clk( priority_reg__clk ),
    .en( priority_reg__en ),
    .in_( priority_reg__in_ ),
    .out( priority_reg__out ),
    .reset( priority_reg__reset )
  );

  //-------------------------------------------------------------
  // End of component priority_reg
  //-------------------------------------------------------------

  // PyMTL Update Block Source
  // At /cgra/venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/arbiters.py:118
  // @update
  // def comb_grants():
  //   for i in range( nreqs ):
  //     s.grants[i] @= s.grants_int[i] | s.grants_int[nreqs+i]
  
  always_comb begin : comb_grants
    for ( int unsigned i = 1'd0; i < 2'( __const__nreqs_at_comb_grants ); i += 1'd1 )
      grants[1'(i)] = grants_int[2'(i)] | grants_int[2'( __const__nreqs_at_comb_grants ) + 2'(i)];
  end

  // PyMTL Update Block Source
  // At /cgra/venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/arbiters.py:141
  // @update
  // def comb_grants_int():
  //   for i in range( nreqsX2 ):
  //     if s.priority_int[i]:
  //       s.grants_int[i] @= s.reqs_int[i]
  //     else:
  //       s.grants_int[i] @= ~s.kills[i] & s.reqs_int[i]
  
  always_comb begin : comb_grants_int
    for ( int unsigned i = 1'd0; i < 3'( __const__nreqsX2_at_comb_grants_int ); i += 1'd1 )
      if ( priority_int[2'(i)] ) begin
        grants_int[2'(i)] = reqs_int[2'(i)];
      end
      else
        grants_int[2'(i)] = ( ~kills[3'(i)] ) & reqs_int[2'(i)];
  end

  // PyMTL Update Block Source
  // At /cgra/venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/arbiters.py:132
  // @update
  // def comb_kills():
  //   s.kills[0] @= 1
  //   for i in range( nreqsX2 ):
  //     if s.priority_int[i]:
  //       s.kills[i+1] @= s.reqs_int[i]
  //     else:
  //       s.kills[i+1] @= s.kills[i] | ( ~s.kills[i] & s.reqs_int[i] )
  
  always_comb begin : comb_kills
    kills[3'd0] = 1'd1;
    for ( int unsigned i = 1'd0; i < 3'( __const__nreqsX2_at_comb_kills ); i += 1'd1 )
      if ( priority_int[2'(i)] ) begin
        kills[3'(i) + 3'd1] = reqs_int[2'(i)];
      end
      else
        kills[3'(i) + 3'd1] = kills[3'(i)] | ( ( ~kills[3'(i)] ) & reqs_int[2'(i)] );
  end

  // PyMTL Update Block Source
  // At /cgra/venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/arbiters.py:123
  // @update
  // def comb_priority_en():
  //   s.priority_en @= ( s.grants != 0 ) & s.en
  
  always_comb begin : comb_priority_en
    priority_en = ( grants != 2'd0 ) & en;
  end

  // PyMTL Update Block Source
  // At /cgra/venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/arbiters.py:127
  // @update
  // def comb_priority_int():
  //   s.priority_int[    0:nreqs  ] @= s.priority_reg.out
  //   s.priority_int[nreqs:nreqsX2] @= 0
  
  always_comb begin : comb_priority_int
    priority_int[2'd1:2'd0] = priority_reg__out;
    priority_int[2'd3:2'( __const__nreqs_at_comb_priority_int )] = 2'd0;
  end

  // PyMTL Update Block Source
  // At /cgra/venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/arbiters.py:113
  // @update
  // def comb_reqs_int():
  //   s.reqs_int [    0:nreqs  ] @= s.reqs
  //   s.reqs_int [nreqs:nreqsX2] @= s.reqs
  
  always_comb begin : comb_reqs_int
    reqs_int[2'd1:2'd0] = reqs;
    reqs_int[2'd3:2'( __const__nreqs_at_comb_reqs_int )] = reqs;
  end

  assign priority_reg__clk = clk;
  assign priority_reg__reset = reset;
  assign priority_reg__en = priority_en;
  assign priority_reg__in_[1:1] = grants[0:0];
  assign priority_reg__in_[0:0] = grants[1:1];

endmodule


// PyMTL Component BypassQueueCtrlRTL Definition
// At /cgra/VectorCGRA/lib/basic/val_rdy/queues.py

module BypassQueueCtrlRTL__num_entries_2
(
  input  logic [0:0] clk ,
  output logic [1:0] count ,
  output logic [0:0] mux_sel ,
  output logic [0:0] raddr ,
  output logic [0:0] recv_rdy ,
  input  logic [0:0] recv_val ,
  input  logic [0:0] reset ,
  input  logic [0:0] send_rdy ,
  output logic [0:0] send_val ,
  output logic [0:0] waddr ,
  output logic [0:0] wen 
);
  localparam logic [1:0] __const__num_entries_at__lambda__s_dut_ctrl_ring_send_adp_0__buffers_0__ctrl_recv_rdy  = 2'd2;
  localparam logic [1:0] __const__num_entries_at_up_reg  = 2'd2;
  logic [0:0] head;
  logic [0:0] recv_xfer;
  logic [0:0] send_xfer;
  logic [0:0] tail;

  // PyMTL Lambda Block Source
  // At /cgra/VectorCGRA/lib/basic/val_rdy/queues.py:645
  // s.mux_sel //= lambda: s.count == 0
  
  always_comb begin : _lambda__s_dut_ctrl_ring_send_adp_0__buffers_0__ctrl_mux_sel
    mux_sel = count == 2'd0;
  end

  // PyMTL Lambda Block Source
  // At /cgra/VectorCGRA/lib/basic/val_rdy/queues.py:642
  // s.recv_rdy //= lambda: s.count < num_entries
  
  always_comb begin : _lambda__s_dut_ctrl_ring_send_adp_0__buffers_0__ctrl_recv_rdy
    recv_rdy = count < 2'( __const__num_entries_at__lambda__s_dut_ctrl_ring_send_adp_0__buffers_0__ctrl_recv_rdy );
  end

  // PyMTL Lambda Block Source
  // At /cgra/VectorCGRA/lib/basic/val_rdy/queues.py:647
  // s.recv_xfer //= lambda: s.recv_val & s.recv_rdy
  
  always_comb begin : _lambda__s_dut_ctrl_ring_send_adp_0__buffers_0__ctrl_recv_xfer
    recv_xfer = recv_val & recv_rdy;
  end

  // PyMTL Lambda Block Source
  // At /cgra/VectorCGRA/lib/basic/val_rdy/queues.py:643
  // s.send_val //= lambda: (s.count > 0) | s.recv_val
  
  always_comb begin : _lambda__s_dut_ctrl_ring_send_adp_0__buffers_0__ctrl_send_val
    send_val = ( count > 2'd0 ) | recv_val;
  end

  // PyMTL Lambda Block Source
  // At /cgra/VectorCGRA/lib/basic/val_rdy/queues.py:648
  // s.send_xfer //= lambda: s.send_val & s.send_rdy
  
  always_comb begin : _lambda__s_dut_ctrl_ring_send_adp_0__buffers_0__ctrl_send_xfer
    send_xfer = send_val & send_rdy;
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/lib/basic/val_rdy/queues.py:650
  // @update_ff
  // def up_reg():
  // 
  //   if s.reset:
  //     s.head  <<= 0
  //     s.tail  <<= 0
  //     s.count <<= 0
  // 
  //   else:
  //     if s.recv_xfer:
  //       s.tail <<= s.tail + 1 if ( s.tail < num_entries - 1 ) else 0
  // 
  //     if s.send_xfer:
  //       s.head <<= s.head + 1 if ( s.head < num_entries -1 ) else 0
  // 
  //     if s.recv_xfer & ~s.send_xfer:
  //       s.count <<= s.count + 1
  //     if ~s.recv_xfer & s.send_xfer:
  //       s.count <<= s.count - 1
  
  always_ff @(posedge clk) begin : up_reg
    if ( reset ) begin
      head <= 1'd0;
      tail <= 1'd0;
      count <= 2'd0;
    end
    else begin
      if ( recv_xfer ) begin
        tail <= ( tail < ( 1'( __const__num_entries_at_up_reg ) - 1'd1 ) ) ? tail + 1'd1 : 1'd0;
      end
      if ( send_xfer ) begin
        head <= ( head < ( 1'( __const__num_entries_at_up_reg ) - 1'd1 ) ) ? head + 1'd1 : 1'd0;
      end
      if ( recv_xfer & ( ~send_xfer ) ) begin
        count <= count + 2'd1;
      end
      if ( ( ~recv_xfer ) & send_xfer ) begin
        count <= count - 2'd1;
      end
    end
  end

  assign wen = recv_xfer;
  assign waddr = tail;
  assign raddr = head;

endmodule


// PyMTL Component Mux Definition
// Full name: Mux__Type_IntraCgraPacket_4_4x1_4_8_2_CgraPayload__11cd3f8c0d91825c__ninputs_2
// At /cgra/venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/arithmetics.py

module Mux__3ebf9295f9fd3a5c
(
  input  logic [0:0] clk ,
  input  IntraCgraPacket_4_4x1_4_8_2_CgraPayload__11cd3f8c0d91825c in_ [0:1],
  output IntraCgraPacket_4_4x1_4_8_2_CgraPayload__11cd3f8c0d91825c out ,
  input  logic [0:0] reset ,
  input  logic [0:0] sel 
);

  // PyMTL Update Block Source
  // At /cgra/venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/arithmetics.py:13
  // @update
  // def up_mux():
  //   s.out @= s.in_[ s.sel ]
  
  always_comb begin : up_mux
    out = in_[sel];
  end

endmodule


// PyMTL Component BypassQueueDpathRTL Definition
// Full name: BypassQueueDpathRTL__EntryType_IntraCgraPacket_4_4x1_4_8_2_CgraPayload__11cd3f8c0d91825c__num_entries_2
// At /cgra/VectorCGRA/lib/basic/val_rdy/queues.py

module BypassQueueDpathRTL__4d91d5ee0229de22
(
  input  logic [0:0] clk ,
  input  logic [0:0] mux_sel ,
  input  logic [0:0] raddr ,
  input  IntraCgraPacket_4_4x1_4_8_2_CgraPayload__11cd3f8c0d91825c recv_msg ,
  input  logic [0:0] reset ,
  output IntraCgraPacket_4_4x1_4_8_2_CgraPayload__11cd3f8c0d91825c send_msg ,
  input  logic [0:0] waddr ,
  input  logic [0:0] wen 
);
  //-------------------------------------------------------------
  // Component mux
  //-------------------------------------------------------------

  logic [0:0] mux__clk;
  IntraCgraPacket_4_4x1_4_8_2_CgraPayload__11cd3f8c0d91825c mux__in_ [0:1];
  IntraCgraPacket_4_4x1_4_8_2_CgraPayload__11cd3f8c0d91825c mux__out;
  logic [0:0] mux__reset;
  logic [0:0] mux__sel;

  Mux__3ebf9295f9fd3a5c mux
  (
    .clk( mux__clk ),
    .in_( mux__in_ ),
    .out( mux__out ),
    .reset( mux__reset ),
    .sel( mux__sel )
  );

  //-------------------------------------------------------------
  // End of component mux
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component rf
  //-------------------------------------------------------------

  logic [0:0] rf__clk;
  logic [0:0] rf__raddr [0:0];
  IntraCgraPacket_4_4x1_4_8_2_CgraPayload__11cd3f8c0d91825c rf__rdata [0:0];
  logic [0:0] rf__reset;
  logic [0:0] rf__waddr [0:0];
  IntraCgraPacket_4_4x1_4_8_2_CgraPayload__11cd3f8c0d91825c rf__wdata [0:0];
  logic [0:0] rf__wen [0:0];

  RegisterFile__c97a00dce3981e0a rf
  (
    .clk( rf__clk ),
    .raddr( rf__raddr ),
    .rdata( rf__rdata ),
    .reset( rf__reset ),
    .waddr( rf__waddr ),
    .wdata( rf__wdata ),
    .wen( rf__wen )
  );

  //-------------------------------------------------------------
  // End of component rf
  //-------------------------------------------------------------

  assign rf__clk = clk;
  assign rf__reset = reset;
  assign rf__raddr[0] = raddr;
  assign rf__wen[0] = wen;
  assign rf__waddr[0] = waddr;
  assign rf__wdata[0] = recv_msg;
  assign mux__clk = clk;
  assign mux__reset = reset;
  assign mux__sel = mux_sel;
  assign mux__in_[0] = rf__rdata[0];
  assign mux__in_[1] = recv_msg;
  assign send_msg = mux__out;

endmodule


// PyMTL Component BypassQueueRTL Definition
// Full name: BypassQueueRTL__EntryType_IntraCgraPacket_4_4x1_4_8_2_CgraPayload__11cd3f8c0d91825c__num_entries_2
// At /cgra/VectorCGRA/lib/basic/val_rdy/queues.py

module BypassQueueRTL__4d91d5ee0229de22
(
  input  logic [0:0] clk ,
  output logic [1:0] count ,
  input  logic [0:0] reset ,
  input IntraCgraPacket_4_4x1_4_8_2_CgraPayload__11cd3f8c0d91825c recv__msg  ,
  output logic [0:0] recv__rdy  ,
  input logic [0:0] recv__val  ,
  output IntraCgraPacket_4_4x1_4_8_2_CgraPayload__11cd3f8c0d91825c send__msg  ,
  input logic [0:0] send__rdy  ,
  output logic [0:0] send__val  
);
  //-------------------------------------------------------------
  // Component ctrl
  //-------------------------------------------------------------

  logic [0:0] ctrl__clk;
  logic [1:0] ctrl__count;
  logic [0:0] ctrl__mux_sel;
  logic [0:0] ctrl__raddr;
  logic [0:0] ctrl__recv_rdy;
  logic [0:0] ctrl__recv_val;
  logic [0:0] ctrl__reset;
  logic [0:0] ctrl__send_rdy;
  logic [0:0] ctrl__send_val;
  logic [0:0] ctrl__waddr;
  logic [0:0] ctrl__wen;

  BypassQueueCtrlRTL__num_entries_2 ctrl
  (
    .clk( ctrl__clk ),
    .count( ctrl__count ),
    .mux_sel( ctrl__mux_sel ),
    .raddr( ctrl__raddr ),
    .recv_rdy( ctrl__recv_rdy ),
    .recv_val( ctrl__recv_val ),
    .reset( ctrl__reset ),
    .send_rdy( ctrl__send_rdy ),
    .send_val( ctrl__send_val ),
    .waddr( ctrl__waddr ),
    .wen( ctrl__wen )
  );

  //-------------------------------------------------------------
  // End of component ctrl
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component dpath
  //-------------------------------------------------------------

  logic [0:0] dpath__clk;
  logic [0:0] dpath__mux_sel;
  logic [0:0] dpath__raddr;
  IntraCgraPacket_4_4x1_4_8_2_CgraPayload__11cd3f8c0d91825c dpath__recv_msg;
  logic [0:0] dpath__reset;
  IntraCgraPacket_4_4x1_4_8_2_CgraPayload__11cd3f8c0d91825c dpath__send_msg;
  logic [0:0] dpath__waddr;
  logic [0:0] dpath__wen;

  BypassQueueDpathRTL__4d91d5ee0229de22 dpath
  (
    .clk( dpath__clk ),
    .mux_sel( dpath__mux_sel ),
    .raddr( dpath__raddr ),
    .recv_msg( dpath__recv_msg ),
    .reset( dpath__reset ),
    .send_msg( dpath__send_msg ),
    .waddr( dpath__waddr ),
    .wen( dpath__wen )
  );

  //-------------------------------------------------------------
  // End of component dpath
  //-------------------------------------------------------------

  assign ctrl__clk = clk;
  assign ctrl__reset = reset;
  assign dpath__clk = clk;
  assign dpath__reset = reset;
  assign dpath__wen = ctrl__wen;
  assign dpath__waddr = ctrl__waddr;
  assign dpath__raddr = ctrl__raddr;
  assign dpath__mux_sel = ctrl__mux_sel;
  assign ctrl__recv_val = recv__val;
  assign recv__rdy = ctrl__recv_rdy;
  assign send__val = ctrl__send_val;
  assign ctrl__send_rdy = send__rdy;
  assign count = ctrl__count;
  assign dpath__recv_msg = recv__msg;
  assign send__msg = dpath__send_msg;

endmodule


// PyMTL Component Encoder Definition
// At /cgra/venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/encoders.py

module Encoder__in_nbits_2__out_nbits_1
(
  input  logic [0:0] clk ,
  input  logic [1:0] in_ ,
  output logic [0:0] out ,
  input  logic [0:0] reset 
);

  // PyMTL Update Block Source
  // At /cgra/venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/encoders.py:28
  // @update
  // def encode():
  //   s.out @= 0
  //   for i in range( s.in_nbits ):
  //     if s.in_[i]:
  //       s.out @= i
  
  always_comb begin : encode
    out = 1'd0;
    for ( int unsigned i = 1'd0; i < 2'd2; i += 1'd1 )
      if ( in_[1'(i)] ) begin
        out = 1'(i);
      end
  end

endmodule


// PyMTL Component CreditRecvRTL2SendRTL Definition
// Full name: CreditRecvRTL2SendRTL__MsgType_IntraCgraPacket_4_4x1_4_8_2_CgraPayload__11cd3f8c0d91825c__vc_2__credit_line_2__QType_BypassQueueRTL
// At /cgra/VectorCGRA/noc/PyOCN/pymtl3_net/ocnlib/ifcs/CreditIfc.py

module CreditRecvRTL2SendRTL__8b4e283003268cf5
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input logic [0:0] recv__en  ,
  input IntraCgraPacket_4_4x1_4_8_2_CgraPayload__11cd3f8c0d91825c recv__msg  ,
  output logic [0:0] recv__yum [0:1] ,
  output IntraCgraPacket_4_4x1_4_8_2_CgraPayload__11cd3f8c0d91825c send__msg  ,
  input logic [0:0] send__rdy  ,
  output logic [0:0] send__val  
);
  localparam logic [1:0] __const__vc_at_up_enq  = 2'd2;
  localparam logic [1:0] __const__vc_at_up_deq_and_send  = 2'd2;
  localparam logic [1:0] __const__vc_at_up_yummy  = 2'd2;
  //-------------------------------------------------------------
  // Component arbiter
  //-------------------------------------------------------------

  logic [0:0] arbiter__clk;
  logic [0:0] arbiter__en;
  logic [1:0] arbiter__grants;
  logic [1:0] arbiter__reqs;
  logic [0:0] arbiter__reset;

  RoundRobinArbiterEn__nreqs_2 arbiter
  (
    .clk( arbiter__clk ),
    .en( arbiter__en ),
    .grants( arbiter__grants ),
    .reqs( arbiter__reqs ),
    .reset( arbiter__reset )
  );

  //-------------------------------------------------------------
  // End of component arbiter
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component buffers[0:1]
  //-------------------------------------------------------------

  logic [0:0] buffers__clk [0:1];
  logic [1:0] buffers__count [0:1];
  logic [0:0] buffers__reset [0:1];
  IntraCgraPacket_4_4x1_4_8_2_CgraPayload__11cd3f8c0d91825c buffers__recv__msg [0:1];
  logic [0:0] buffers__recv__rdy [0:1];
  logic [0:0] buffers__recv__val [0:1];
  IntraCgraPacket_4_4x1_4_8_2_CgraPayload__11cd3f8c0d91825c buffers__send__msg [0:1];
  logic [0:0] buffers__send__rdy [0:1];
  logic [0:0] buffers__send__val [0:1];

  BypassQueueRTL__4d91d5ee0229de22 buffers__0
  (
    .clk( buffers__clk[0] ),
    .count( buffers__count[0] ),
    .reset( buffers__reset[0] ),
    .recv__msg( buffers__recv__msg[0] ),
    .recv__rdy( buffers__recv__rdy[0] ),
    .recv__val( buffers__recv__val[0] ),
    .send__msg( buffers__send__msg[0] ),
    .send__rdy( buffers__send__rdy[0] ),
    .send__val( buffers__send__val[0] )
  );

  BypassQueueRTL__4d91d5ee0229de22 buffers__1
  (
    .clk( buffers__clk[1] ),
    .count( buffers__count[1] ),
    .reset( buffers__reset[1] ),
    .recv__msg( buffers__recv__msg[1] ),
    .recv__rdy( buffers__recv__rdy[1] ),
    .recv__val( buffers__recv__val[1] ),
    .send__msg( buffers__send__msg[1] ),
    .send__rdy( buffers__send__rdy[1] ),
    .send__val( buffers__send__val[1] )
  );

  //-------------------------------------------------------------
  // End of component buffers[0:1]
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component encoder
  //-------------------------------------------------------------

  logic [0:0] encoder__clk;
  logic [1:0] encoder__in_;
  logic [0:0] encoder__out;
  logic [0:0] encoder__reset;

  Encoder__in_nbits_2__out_nbits_1 encoder
  (
    .clk( encoder__clk ),
    .in_( encoder__in_ ),
    .out( encoder__out ),
    .reset( encoder__reset )
  );

  //-------------------------------------------------------------
  // End of component encoder
  //-------------------------------------------------------------

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/noc/PyOCN/pymtl3_net/ocnlib/ifcs/CreditIfc.py:205
  // @update
  // def up_deq_and_send():
  //   for i in range( vc ):
  //     s.buffers[i].send.rdy @= 0
  // 
  //   s.send.msg @= s.buffers[ s.encoder.out ].send.msg
  // 
  //   if s.arbiter.grants > 0:
  //     s.send.val @= 1
  //     s.buffers[ s.encoder.out ].send.rdy @= s.send.rdy
  //   else:
  //     s.send.val @= 0
  
  always_comb begin : up_deq_and_send
    for ( int unsigned i = 1'd0; i < 2'( __const__vc_at_up_deq_and_send ); i += 1'd1 )
      buffers__send__rdy[1'(i)] = 1'd0;
    send__msg = buffers__send__msg[encoder__out];
    if ( arbiter__grants > 2'd0 ) begin
      send__val = 1'd1;
      buffers__send__rdy[encoder__out] = send__rdy;
    end
    else
      send__val = 1'd0;
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/noc/PyOCN/pymtl3_net/ocnlib/ifcs/CreditIfc.py:194
  // @update
  // def up_enq():
  //   if s.recv.en:
  //     for i in range( vc ):
  //       s.buffers[i].recv.val @= ( s.recv.msg.vc_id == i )
  //   else:
  //     for i in range( vc ):
  //       s.buffers[i].recv.val @= 0
  
  always_comb begin : up_enq
    if ( recv__en ) begin
      for ( int unsigned i = 1'd0; i < 2'( __const__vc_at_up_enq ); i += 1'd1 )
        buffers__recv__val[1'(i)] = recv__msg.vc_id == 1'(i);
    end
    else
      for ( int unsigned i = 1'd0; i < 2'( __const__vc_at_up_enq ); i += 1'd1 )
        buffers__recv__val[1'(i)] = 1'd0;
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/noc/PyOCN/pymtl3_net/ocnlib/ifcs/CreditIfc.py:218
  // @update
  // def up_yummy():
  //   for i in range( vc ):
  //     s.recv.yum[i] @= s.buffers[i].send.val & s.buffers[i].send.rdy
  
  always_comb begin : up_yummy
    for ( int unsigned i = 1'd0; i < 2'( __const__vc_at_up_yummy ); i += 1'd1 )
      recv__yum[1'(i)] = buffers__send__val[1'(i)] & buffers__send__rdy[1'(i)];
  end

  assign buffers__clk[0] = clk;
  assign buffers__reset[0] = reset;
  assign buffers__clk[1] = clk;
  assign buffers__reset[1] = reset;
  assign arbiter__clk = clk;
  assign arbiter__reset = reset;
  assign encoder__clk = clk;
  assign encoder__reset = reset;
  assign buffers__recv__msg[0] = recv__msg;
  assign arbiter__reqs[0:0] = buffers__send__val[0];
  assign buffers__recv__msg[1] = recv__msg;
  assign arbiter__reqs[1:1] = buffers__send__val[1];
  assign encoder__in_ = arbiter__grants;
  assign arbiter__en = send__val;

endmodule


// PyMTL Component RingNetworkRTL Definition
// Full name: RingNetworkRTL__PacketType_IntraCgraPacket_4_4x1_4_8_2_CgraPayload__11cd3f8c0d91825c__PositionType_Bits3__num_routers_5__chl_lat_1__vc_2__credit_line_2
// At /cgra/VectorCGRA/noc/PyOCN/pymtl3_net/ringnet/RingNetworkRTL.py

module RingNetworkRTL__344ed987b950e64f
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input IntraCgraPacket_4_4x1_4_8_2_CgraPayload__11cd3f8c0d91825c recv__msg [0:4] ,
  output logic [0:0] recv__rdy [0:4] ,
  input logic [0:0] recv__val [0:4] ,
  output IntraCgraPacket_4_4x1_4_8_2_CgraPayload__11cd3f8c0d91825c send__msg [0:4] ,
  input logic [0:0] send__rdy [0:4] ,
  output logic [0:0] send__val [0:4] 
);
  //-------------------------------------------------------------
  // Component recv_adp[0:4]
  //-------------------------------------------------------------

  logic [0:0] recv_adp__clk [0:4];
  logic [0:0] recv_adp__reset [0:4];
  IntraCgraPacket_4_4x1_4_8_2_CgraPayload__11cd3f8c0d91825c recv_adp__recv__msg [0:4];
  logic [0:0] recv_adp__recv__rdy [0:4];
  logic [0:0] recv_adp__recv__val [0:4];
  logic [0:0] recv_adp__send__en [0:4];
  IntraCgraPacket_4_4x1_4_8_2_CgraPayload__11cd3f8c0d91825c recv_adp__send__msg [0:4];
  logic [0:0] recv_adp__send__yum [0:4][0:1];

  RecvRTL2CreditSendRTL__b299f27b560c5025 recv_adp__0
  (
    .clk( recv_adp__clk[0] ),
    .reset( recv_adp__reset[0] ),
    .recv__msg( recv_adp__recv__msg[0] ),
    .recv__rdy( recv_adp__recv__rdy[0] ),
    .recv__val( recv_adp__recv__val[0] ),
    .send__en( recv_adp__send__en[0] ),
    .send__msg( recv_adp__send__msg[0] ),
    .send__yum( recv_adp__send__yum[0] )
  );

  RecvRTL2CreditSendRTL__b299f27b560c5025 recv_adp__1
  (
    .clk( recv_adp__clk[1] ),
    .reset( recv_adp__reset[1] ),
    .recv__msg( recv_adp__recv__msg[1] ),
    .recv__rdy( recv_adp__recv__rdy[1] ),
    .recv__val( recv_adp__recv__val[1] ),
    .send__en( recv_adp__send__en[1] ),
    .send__msg( recv_adp__send__msg[1] ),
    .send__yum( recv_adp__send__yum[1] )
  );

  RecvRTL2CreditSendRTL__b299f27b560c5025 recv_adp__2
  (
    .clk( recv_adp__clk[2] ),
    .reset( recv_adp__reset[2] ),
    .recv__msg( recv_adp__recv__msg[2] ),
    .recv__rdy( recv_adp__recv__rdy[2] ),
    .recv__val( recv_adp__recv__val[2] ),
    .send__en( recv_adp__send__en[2] ),
    .send__msg( recv_adp__send__msg[2] ),
    .send__yum( recv_adp__send__yum[2] )
  );

  RecvRTL2CreditSendRTL__b299f27b560c5025 recv_adp__3
  (
    .clk( recv_adp__clk[3] ),
    .reset( recv_adp__reset[3] ),
    .recv__msg( recv_adp__recv__msg[3] ),
    .recv__rdy( recv_adp__recv__rdy[3] ),
    .recv__val( recv_adp__recv__val[3] ),
    .send__en( recv_adp__send__en[3] ),
    .send__msg( recv_adp__send__msg[3] ),
    .send__yum( recv_adp__send__yum[3] )
  );

  RecvRTL2CreditSendRTL__b299f27b560c5025 recv_adp__4
  (
    .clk( recv_adp__clk[4] ),
    .reset( recv_adp__reset[4] ),
    .recv__msg( recv_adp__recv__msg[4] ),
    .recv__rdy( recv_adp__recv__rdy[4] ),
    .recv__val( recv_adp__recv__val[4] ),
    .send__en( recv_adp__send__en[4] ),
    .send__msg( recv_adp__send__msg[4] ),
    .send__yum( recv_adp__send__yum[4] )
  );

  //-------------------------------------------------------------
  // End of component recv_adp[0:4]
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component routers[0:4]
  //-------------------------------------------------------------

  logic [0:0] routers__clk [0:4];
  logic [2:0] routers__pos [0:4];
  logic [0:0] routers__reset [0:4];
  logic [0:0] routers__recv__en [0:4][0:2];
  IntraCgraPacket_4_4x1_4_8_2_CgraPayload__11cd3f8c0d91825c routers__recv__msg [0:4][0:2];
  logic [0:0] routers__recv__yum [0:4][0:2][0:1];
  logic [0:0] routers__send__en [0:4][0:2];
  IntraCgraPacket_4_4x1_4_8_2_CgraPayload__11cd3f8c0d91825c routers__send__msg [0:4][0:2];
  logic [0:0] routers__send__yum [0:4][0:2][0:1];

  RingRouterRTL__795a7ef5c610671c routers__0
  (
    .clk( routers__clk[0] ),
    .pos( routers__pos[0] ),
    .reset( routers__reset[0] ),
    .recv__en( routers__recv__en[0] ),
    .recv__msg( routers__recv__msg[0] ),
    .recv__yum( routers__recv__yum[0] ),
    .send__en( routers__send__en[0] ),
    .send__msg( routers__send__msg[0] ),
    .send__yum( routers__send__yum[0] )
  );

  RingRouterRTL__795a7ef5c610671c routers__1
  (
    .clk( routers__clk[1] ),
    .pos( routers__pos[1] ),
    .reset( routers__reset[1] ),
    .recv__en( routers__recv__en[1] ),
    .recv__msg( routers__recv__msg[1] ),
    .recv__yum( routers__recv__yum[1] ),
    .send__en( routers__send__en[1] ),
    .send__msg( routers__send__msg[1] ),
    .send__yum( routers__send__yum[1] )
  );

  RingRouterRTL__795a7ef5c610671c routers__2
  (
    .clk( routers__clk[2] ),
    .pos( routers__pos[2] ),
    .reset( routers__reset[2] ),
    .recv__en( routers__recv__en[2] ),
    .recv__msg( routers__recv__msg[2] ),
    .recv__yum( routers__recv__yum[2] ),
    .send__en( routers__send__en[2] ),
    .send__msg( routers__send__msg[2] ),
    .send__yum( routers__send__yum[2] )
  );

  RingRouterRTL__795a7ef5c610671c routers__3
  (
    .clk( routers__clk[3] ),
    .pos( routers__pos[3] ),
    .reset( routers__reset[3] ),
    .recv__en( routers__recv__en[3] ),
    .recv__msg( routers__recv__msg[3] ),
    .recv__yum( routers__recv__yum[3] ),
    .send__en( routers__send__en[3] ),
    .send__msg( routers__send__msg[3] ),
    .send__yum( routers__send__yum[3] )
  );

  RingRouterRTL__795a7ef5c610671c routers__4
  (
    .clk( routers__clk[4] ),
    .pos( routers__pos[4] ),
    .reset( routers__reset[4] ),
    .recv__en( routers__recv__en[4] ),
    .recv__msg( routers__recv__msg[4] ),
    .recv__yum( routers__recv__yum[4] ),
    .send__en( routers__send__en[4] ),
    .send__msg( routers__send__msg[4] ),
    .send__yum( routers__send__yum[4] )
  );

  //-------------------------------------------------------------
  // End of component routers[0:4]
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component send_adp[0:4]
  //-------------------------------------------------------------

  logic [0:0] send_adp__clk [0:4];
  logic [0:0] send_adp__reset [0:4];
  logic [0:0] send_adp__recv__en [0:4];
  IntraCgraPacket_4_4x1_4_8_2_CgraPayload__11cd3f8c0d91825c send_adp__recv__msg [0:4];
  logic [0:0] send_adp__recv__yum [0:4][0:1];
  IntraCgraPacket_4_4x1_4_8_2_CgraPayload__11cd3f8c0d91825c send_adp__send__msg [0:4];
  logic [0:0] send_adp__send__rdy [0:4];
  logic [0:0] send_adp__send__val [0:4];

  CreditRecvRTL2SendRTL__8b4e283003268cf5 send_adp__0
  (
    .clk( send_adp__clk[0] ),
    .reset( send_adp__reset[0] ),
    .recv__en( send_adp__recv__en[0] ),
    .recv__msg( send_adp__recv__msg[0] ),
    .recv__yum( send_adp__recv__yum[0] ),
    .send__msg( send_adp__send__msg[0] ),
    .send__rdy( send_adp__send__rdy[0] ),
    .send__val( send_adp__send__val[0] )
  );

  CreditRecvRTL2SendRTL__8b4e283003268cf5 send_adp__1
  (
    .clk( send_adp__clk[1] ),
    .reset( send_adp__reset[1] ),
    .recv__en( send_adp__recv__en[1] ),
    .recv__msg( send_adp__recv__msg[1] ),
    .recv__yum( send_adp__recv__yum[1] ),
    .send__msg( send_adp__send__msg[1] ),
    .send__rdy( send_adp__send__rdy[1] ),
    .send__val( send_adp__send__val[1] )
  );

  CreditRecvRTL2SendRTL__8b4e283003268cf5 send_adp__2
  (
    .clk( send_adp__clk[2] ),
    .reset( send_adp__reset[2] ),
    .recv__en( send_adp__recv__en[2] ),
    .recv__msg( send_adp__recv__msg[2] ),
    .recv__yum( send_adp__recv__yum[2] ),
    .send__msg( send_adp__send__msg[2] ),
    .send__rdy( send_adp__send__rdy[2] ),
    .send__val( send_adp__send__val[2] )
  );

  CreditRecvRTL2SendRTL__8b4e283003268cf5 send_adp__3
  (
    .clk( send_adp__clk[3] ),
    .reset( send_adp__reset[3] ),
    .recv__en( send_adp__recv__en[3] ),
    .recv__msg( send_adp__recv__msg[3] ),
    .recv__yum( send_adp__recv__yum[3] ),
    .send__msg( send_adp__send__msg[3] ),
    .send__rdy( send_adp__send__rdy[3] ),
    .send__val( send_adp__send__val[3] )
  );

  CreditRecvRTL2SendRTL__8b4e283003268cf5 send_adp__4
  (
    .clk( send_adp__clk[4] ),
    .reset( send_adp__reset[4] ),
    .recv__en( send_adp__recv__en[4] ),
    .recv__msg( send_adp__recv__msg[4] ),
    .recv__yum( send_adp__recv__yum[4] ),
    .send__msg( send_adp__send__msg[4] ),
    .send__rdy( send_adp__send__rdy[4] ),
    .send__val( send_adp__send__val[4] )
  );

  //-------------------------------------------------------------
  // End of component send_adp[0:4]
  //-------------------------------------------------------------

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/noc/PyOCN/pymtl3_net/ringnet/RingNetworkRTL.py:58
  // @update
  // def up_pos():
  //   for r in range( s.num_routers ):
  //     s.routers[r].pos @= r
  
  always_comb begin : up_pos
    for ( int unsigned r = 1'd0; r < 3'd5; r += 1'd1 )
      routers__pos[3'(r)] = 3'(r);
  end

  assign routers__clk[0] = clk;
  assign routers__reset[0] = reset;
  assign routers__clk[1] = clk;
  assign routers__reset[1] = reset;
  assign routers__clk[2] = clk;
  assign routers__reset[2] = reset;
  assign routers__clk[3] = clk;
  assign routers__reset[3] = reset;
  assign routers__clk[4] = clk;
  assign routers__reset[4] = reset;
  assign recv_adp__clk[0] = clk;
  assign recv_adp__reset[0] = reset;
  assign recv_adp__clk[1] = clk;
  assign recv_adp__reset[1] = reset;
  assign recv_adp__clk[2] = clk;
  assign recv_adp__reset[2] = reset;
  assign recv_adp__clk[3] = clk;
  assign recv_adp__reset[3] = reset;
  assign recv_adp__clk[4] = clk;
  assign recv_adp__reset[4] = reset;
  assign send_adp__clk[0] = clk;
  assign send_adp__reset[0] = reset;
  assign send_adp__clk[1] = clk;
  assign send_adp__reset[1] = reset;
  assign send_adp__clk[2] = clk;
  assign send_adp__reset[2] = reset;
  assign send_adp__clk[3] = clk;
  assign send_adp__reset[3] = reset;
  assign send_adp__clk[4] = clk;
  assign send_adp__reset[4] = reset;
  assign routers__recv__en[1][0] = routers__send__en[0][1];
  assign routers__recv__msg[1][0] = routers__send__msg[0][1];
  assign routers__send__yum[0][1][0] = routers__recv__yum[1][0][0];
  assign routers__send__yum[0][1][1] = routers__recv__yum[1][0][1];
  assign routers__recv__en[0][1] = routers__send__en[1][0];
  assign routers__recv__msg[0][1] = routers__send__msg[1][0];
  assign routers__send__yum[1][0][0] = routers__recv__yum[0][1][0];
  assign routers__send__yum[1][0][1] = routers__recv__yum[0][1][1];
  assign recv_adp__recv__msg[0] = recv__msg[0];
  assign recv__rdy[0] = recv_adp__recv__rdy[0];
  assign recv_adp__recv__val[0] = recv__val[0];
  assign routers__recv__en[0][2] = recv_adp__send__en[0];
  assign routers__recv__msg[0][2] = recv_adp__send__msg[0];
  assign recv_adp__send__yum[0][0] = routers__recv__yum[0][2][0];
  assign recv_adp__send__yum[0][1] = routers__recv__yum[0][2][1];
  assign send_adp__recv__en[0] = routers__send__en[0][2];
  assign send_adp__recv__msg[0] = routers__send__msg[0][2];
  assign routers__send__yum[0][2][0] = send_adp__recv__yum[0][0];
  assign routers__send__yum[0][2][1] = send_adp__recv__yum[0][1];
  assign send__msg[0] = send_adp__send__msg[0];
  assign send_adp__send__rdy[0] = send__rdy[0];
  assign send__val[0] = send_adp__send__val[0];
  assign routers__recv__en[2][0] = routers__send__en[1][1];
  assign routers__recv__msg[2][0] = routers__send__msg[1][1];
  assign routers__send__yum[1][1][0] = routers__recv__yum[2][0][0];
  assign routers__send__yum[1][1][1] = routers__recv__yum[2][0][1];
  assign routers__recv__en[1][1] = routers__send__en[2][0];
  assign routers__recv__msg[1][1] = routers__send__msg[2][0];
  assign routers__send__yum[2][0][0] = routers__recv__yum[1][1][0];
  assign routers__send__yum[2][0][1] = routers__recv__yum[1][1][1];
  assign recv_adp__recv__msg[1] = recv__msg[1];
  assign recv__rdy[1] = recv_adp__recv__rdy[1];
  assign recv_adp__recv__val[1] = recv__val[1];
  assign routers__recv__en[1][2] = recv_adp__send__en[1];
  assign routers__recv__msg[1][2] = recv_adp__send__msg[1];
  assign recv_adp__send__yum[1][0] = routers__recv__yum[1][2][0];
  assign recv_adp__send__yum[1][1] = routers__recv__yum[1][2][1];
  assign send_adp__recv__en[1] = routers__send__en[1][2];
  assign send_adp__recv__msg[1] = routers__send__msg[1][2];
  assign routers__send__yum[1][2][0] = send_adp__recv__yum[1][0];
  assign routers__send__yum[1][2][1] = send_adp__recv__yum[1][1];
  assign send__msg[1] = send_adp__send__msg[1];
  assign send_adp__send__rdy[1] = send__rdy[1];
  assign send__val[1] = send_adp__send__val[1];
  assign routers__recv__en[3][0] = routers__send__en[2][1];
  assign routers__recv__msg[3][0] = routers__send__msg[2][1];
  assign routers__send__yum[2][1][0] = routers__recv__yum[3][0][0];
  assign routers__send__yum[2][1][1] = routers__recv__yum[3][0][1];
  assign routers__recv__en[2][1] = routers__send__en[3][0];
  assign routers__recv__msg[2][1] = routers__send__msg[3][0];
  assign routers__send__yum[3][0][0] = routers__recv__yum[2][1][0];
  assign routers__send__yum[3][0][1] = routers__recv__yum[2][1][1];
  assign recv_adp__recv__msg[2] = recv__msg[2];
  assign recv__rdy[2] = recv_adp__recv__rdy[2];
  assign recv_adp__recv__val[2] = recv__val[2];
  assign routers__recv__en[2][2] = recv_adp__send__en[2];
  assign routers__recv__msg[2][2] = recv_adp__send__msg[2];
  assign recv_adp__send__yum[2][0] = routers__recv__yum[2][2][0];
  assign recv_adp__send__yum[2][1] = routers__recv__yum[2][2][1];
  assign send_adp__recv__en[2] = routers__send__en[2][2];
  assign send_adp__recv__msg[2] = routers__send__msg[2][2];
  assign routers__send__yum[2][2][0] = send_adp__recv__yum[2][0];
  assign routers__send__yum[2][2][1] = send_adp__recv__yum[2][1];
  assign send__msg[2] = send_adp__send__msg[2];
  assign send_adp__send__rdy[2] = send__rdy[2];
  assign send__val[2] = send_adp__send__val[2];
  assign routers__recv__en[4][0] = routers__send__en[3][1];
  assign routers__recv__msg[4][0] = routers__send__msg[3][1];
  assign routers__send__yum[3][1][0] = routers__recv__yum[4][0][0];
  assign routers__send__yum[3][1][1] = routers__recv__yum[4][0][1];
  assign routers__recv__en[3][1] = routers__send__en[4][0];
  assign routers__recv__msg[3][1] = routers__send__msg[4][0];
  assign routers__send__yum[4][0][0] = routers__recv__yum[3][1][0];
  assign routers__send__yum[4][0][1] = routers__recv__yum[3][1][1];
  assign recv_adp__recv__msg[3] = recv__msg[3];
  assign recv__rdy[3] = recv_adp__recv__rdy[3];
  assign recv_adp__recv__val[3] = recv__val[3];
  assign routers__recv__en[3][2] = recv_adp__send__en[3];
  assign routers__recv__msg[3][2] = recv_adp__send__msg[3];
  assign recv_adp__send__yum[3][0] = routers__recv__yum[3][2][0];
  assign recv_adp__send__yum[3][1] = routers__recv__yum[3][2][1];
  assign send_adp__recv__en[3] = routers__send__en[3][2];
  assign send_adp__recv__msg[3] = routers__send__msg[3][2];
  assign routers__send__yum[3][2][0] = send_adp__recv__yum[3][0];
  assign routers__send__yum[3][2][1] = send_adp__recv__yum[3][1];
  assign send__msg[3] = send_adp__send__msg[3];
  assign send_adp__send__rdy[3] = send__rdy[3];
  assign send__val[3] = send_adp__send__val[3];
  assign routers__recv__en[0][0] = routers__send__en[4][1];
  assign routers__recv__msg[0][0] = routers__send__msg[4][1];
  assign routers__send__yum[4][1][0] = routers__recv__yum[0][0][0];
  assign routers__send__yum[4][1][1] = routers__recv__yum[0][0][1];
  assign routers__recv__en[4][1] = routers__send__en[0][0];
  assign routers__recv__msg[4][1] = routers__send__msg[0][0];
  assign routers__send__yum[0][0][0] = routers__recv__yum[4][1][0];
  assign routers__send__yum[0][0][1] = routers__recv__yum[4][1][1];
  assign recv_adp__recv__msg[4] = recv__msg[4];
  assign recv__rdy[4] = recv_adp__recv__rdy[4];
  assign recv_adp__recv__val[4] = recv__val[4];
  assign routers__recv__en[4][2] = recv_adp__send__en[4];
  assign routers__recv__msg[4][2] = recv_adp__send__msg[4];
  assign recv_adp__send__yum[4][0] = routers__recv__yum[4][2][0];
  assign recv_adp__send__yum[4][1] = routers__recv__yum[4][2][1];
  assign send_adp__recv__en[4] = routers__send__en[4][2];
  assign send_adp__recv__msg[4] = routers__send__msg[4][2];
  assign routers__send__yum[4][2][0] = send_adp__recv__yum[4][0];
  assign routers__send__yum[4][2][1] = send_adp__recv__yum[4][1];
  assign send__msg[4] = send_adp__send__msg[4];
  assign send_adp__send__rdy[4] = send__rdy[4];
  assign send__val[4] = send_adp__send__val[4];

endmodule


// PyMTL Component RegisterFile Definition
// Full name: RegisterFile__Type_MemAccessPacket_4_3_512__e6eb6c33f0815ad1__nregs_2__rd_ports_1__wr_ports_1__const_zero_False
// At /cgra/venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/register_files.py

module RegisterFile__f7ac537c1018529c
(
  input  logic [0:0] clk ,
  input  logic [0:0] raddr [0:0],
  output MemAccessPacket_4_3_512__e6eb6c33f0815ad1 rdata [0:0],
  input  logic [0:0] reset ,
  input  logic [0:0] waddr [0:0],
  input  MemAccessPacket_4_3_512__e6eb6c33f0815ad1 wdata [0:0],
  input  logic [0:0] wen [0:0]
);
  localparam logic [0:0] __const__rd_ports_at_up_rf_read  = 1'd1;
  localparam logic [0:0] __const__wr_ports_at_up_rf_write  = 1'd1;
  MemAccessPacket_4_3_512__e6eb6c33f0815ad1 regs [0:1];

  // PyMTL Update Block Source
  // At /cgra/venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/register_files.py:20
  // @update
  // def up_rf_read():
  //   for i in range( rd_ports ):
  //     s.rdata[i] @= s.regs[ s.raddr[i] ]
  
  always_comb begin : up_rf_read
    for ( int unsigned i = 1'd0; i < 1'( __const__rd_ports_at_up_rf_read ); i += 1'd1 )
      rdata[1'(i)] = regs[raddr[1'(i)]];
  end

  // PyMTL Update Block Source
  // At /cgra/venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/register_files.py:32
  // @update_ff
  // def up_rf_write():
  //   for i in range( wr_ports ):
  //     if s.wen[i]:
  //       s.regs[ s.waddr[i] ] <<= s.wdata[i]
  
  always_ff @(posedge clk) begin : up_rf_write
    for ( int unsigned i = 1'd0; i < 1'( __const__wr_ports_at_up_rf_write ); i += 1'd1 )
      if ( wen[1'(i)] ) begin
        regs[waddr[1'(i)]] <= wdata[1'(i)];
      end
  end

endmodule


// PyMTL Component NormalQueueDpathRTL Definition
// Full name: NormalQueueDpathRTL__EntryType_MemAccessPacket_4_3_512__e6eb6c33f0815ad1__num_entries_2
// At /cgra/VectorCGRA/lib/basic/val_rdy/queues.py

module NormalQueueDpathRTL__69d7201f95bb857e
(
  input  logic [0:0] clk ,
  input  logic [0:0] raddr ,
  input  MemAccessPacket_4_3_512__e6eb6c33f0815ad1 recv_msg ,
  input  logic [0:0] reset ,
  output MemAccessPacket_4_3_512__e6eb6c33f0815ad1 send_msg ,
  input  logic [0:0] waddr ,
  input  logic [0:0] wen 
);
  //-------------------------------------------------------------
  // Component rf
  //-------------------------------------------------------------

  logic [0:0] rf__clk;
  logic [0:0] rf__raddr [0:0];
  MemAccessPacket_4_3_512__e6eb6c33f0815ad1 rf__rdata [0:0];
  logic [0:0] rf__reset;
  logic [0:0] rf__waddr [0:0];
  MemAccessPacket_4_3_512__e6eb6c33f0815ad1 rf__wdata [0:0];
  logic [0:0] rf__wen [0:0];

  RegisterFile__f7ac537c1018529c rf
  (
    .clk( rf__clk ),
    .raddr( rf__raddr ),
    .rdata( rf__rdata ),
    .reset( rf__reset ),
    .waddr( rf__waddr ),
    .wdata( rf__wdata ),
    .wen( rf__wen )
  );

  //-------------------------------------------------------------
  // End of component rf
  //-------------------------------------------------------------

  assign rf__clk = clk;
  assign rf__reset = reset;
  assign rf__raddr[0] = raddr;
  assign send_msg = rf__rdata[0];
  assign rf__wen[0] = wen;
  assign rf__waddr[0] = waddr;
  assign rf__wdata[0] = recv_msg;

endmodule


// PyMTL Component NormalQueueRTL Definition
// Full name: NormalQueueRTL__EntryType_MemAccessPacket_4_3_512__e6eb6c33f0815ad1__num_entries_2
// At /cgra/VectorCGRA/lib/basic/val_rdy/queues.py

module NormalQueueRTL__69d7201f95bb857e
(
  input  logic [0:0] clk ,
  output logic [1:0] count ,
  input  logic [0:0] reset ,
  input MemAccessPacket_4_3_512__e6eb6c33f0815ad1 recv__msg  ,
  output logic [0:0] recv__rdy  ,
  input logic [0:0] recv__val  ,
  output MemAccessPacket_4_3_512__e6eb6c33f0815ad1 send__msg  ,
  input logic [0:0] send__rdy  ,
  output logic [0:0] send__val  
);
  //-------------------------------------------------------------
  // Component ctrl
  //-------------------------------------------------------------

  logic [0:0] ctrl__clk;
  logic [1:0] ctrl__count;
  logic [0:0] ctrl__raddr;
  logic [0:0] ctrl__recv_rdy;
  logic [0:0] ctrl__recv_val;
  logic [0:0] ctrl__reset;
  logic [0:0] ctrl__send_rdy;
  logic [0:0] ctrl__send_val;
  logic [0:0] ctrl__waddr;
  logic [0:0] ctrl__wen;

  NormalQueueCtrlRTL__num_entries_2 ctrl
  (
    .clk( ctrl__clk ),
    .count( ctrl__count ),
    .raddr( ctrl__raddr ),
    .recv_rdy( ctrl__recv_rdy ),
    .recv_val( ctrl__recv_val ),
    .reset( ctrl__reset ),
    .send_rdy( ctrl__send_rdy ),
    .send_val( ctrl__send_val ),
    .waddr( ctrl__waddr ),
    .wen( ctrl__wen )
  );

  //-------------------------------------------------------------
  // End of component ctrl
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component dpath
  //-------------------------------------------------------------

  logic [0:0] dpath__clk;
  logic [0:0] dpath__raddr;
  MemAccessPacket_4_3_512__e6eb6c33f0815ad1 dpath__recv_msg;
  logic [0:0] dpath__reset;
  MemAccessPacket_4_3_512__e6eb6c33f0815ad1 dpath__send_msg;
  logic [0:0] dpath__waddr;
  logic [0:0] dpath__wen;

  NormalQueueDpathRTL__69d7201f95bb857e dpath
  (
    .clk( dpath__clk ),
    .raddr( dpath__raddr ),
    .recv_msg( dpath__recv_msg ),
    .reset( dpath__reset ),
    .send_msg( dpath__send_msg ),
    .waddr( dpath__waddr ),
    .wen( dpath__wen )
  );

  //-------------------------------------------------------------
  // End of component dpath
  //-------------------------------------------------------------

  assign ctrl__clk = clk;
  assign ctrl__reset = reset;
  assign dpath__clk = clk;
  assign dpath__reset = reset;
  assign dpath__wen = ctrl__wen;
  assign dpath__waddr = ctrl__waddr;
  assign dpath__raddr = ctrl__raddr;
  assign ctrl__recv_val = recv__val;
  assign recv__rdy = ctrl__recv_rdy;
  assign dpath__recv_msg = recv__msg;
  assign send__val = ctrl__send_val;
  assign ctrl__send_rdy = send__rdy;
  assign send__msg = dpath__send_msg;
  assign count = ctrl__count;

endmodule


// PyMTL Component ChannelRTL Definition
// Full name: ChannelRTL__PacketType_MemAccessPacket_4_3_512__e6eb6c33f0815ad1__QueueType_NormalQueueRTL__latency_1
// At /cgra/VectorCGRA/noc/PyOCN/pymtl3_net/channel/ChannelRTL.py

module ChannelRTL__3f90e4f9f6f69f44
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input MemAccessPacket_4_3_512__e6eb6c33f0815ad1 recv__msg  ,
  output logic [0:0] recv__rdy  ,
  input logic [0:0] recv__val  ,
  output MemAccessPacket_4_3_512__e6eb6c33f0815ad1 send__msg  ,
  input logic [0:0] send__rdy  ,
  output logic [0:0] send__val  
);
  //-------------------------------------------------------------
  // Component queues[0:0]
  //-------------------------------------------------------------

  logic [0:0] queues__clk [0:0];
  logic [1:0] queues__count [0:0];
  logic [0:0] queues__reset [0:0];
  MemAccessPacket_4_3_512__e6eb6c33f0815ad1 queues__recv__msg [0:0];
  logic [0:0] queues__recv__rdy [0:0];
  logic [0:0] queues__recv__val [0:0];
  MemAccessPacket_4_3_512__e6eb6c33f0815ad1 queues__send__msg [0:0];
  logic [0:0] queues__send__rdy [0:0];
  logic [0:0] queues__send__val [0:0];

  NormalQueueRTL__69d7201f95bb857e queues__0
  (
    .clk( queues__clk[0] ),
    .count( queues__count[0] ),
    .reset( queues__reset[0] ),
    .recv__msg( queues__recv__msg[0] ),
    .recv__rdy( queues__recv__rdy[0] ),
    .recv__val( queues__recv__val[0] ),
    .send__msg( queues__send__msg[0] ),
    .send__rdy( queues__send__rdy[0] ),
    .send__val( queues__send__val[0] )
  );

  //-------------------------------------------------------------
  // End of component queues[0:0]
  //-------------------------------------------------------------

  assign queues__clk[0] = clk;
  assign queues__reset[0] = reset;
  assign queues__recv__msg[0] = recv__msg;
  assign recv__rdy = queues__recv__rdy[0];
  assign queues__recv__val[0] = recv__val;
  assign send__msg = queues__send__msg[0];
  assign queues__send__rdy[0] = send__rdy;
  assign send__val = queues__send__val[0];

endmodule


// PyMTL Component RegisterFile Definition
// Full name: RegisterFile__Type_CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1__nregs_32__rd_ports_1__wr_ports_1__const_zero_False
// At /cgra/venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/register_files.py

module RegisterFile__217468e476601edf
(
  input  logic [0:0] clk ,
  input  logic [4:0] raddr [0:0],
  output CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 rdata [0:0],
  input  logic [0:0] reset ,
  input  logic [4:0] waddr [0:0],
  input  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 wdata [0:0],
  input  logic [0:0] wen [0:0]
);
  localparam logic [0:0] __const__rd_ports_at_up_rf_read  = 1'd1;
  localparam logic [0:0] __const__wr_ports_at_up_rf_write  = 1'd1;
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 regs [0:31];

  // PyMTL Update Block Source
  // At /cgra/venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/register_files.py:20
  // @update
  // def up_rf_read():
  //   for i in range( rd_ports ):
  //     s.rdata[i] @= s.regs[ s.raddr[i] ]
  
  always_comb begin : up_rf_read
    for ( int unsigned i = 1'd0; i < 1'( __const__rd_ports_at_up_rf_read ); i += 1'd1 )
      rdata[1'(i)] = regs[raddr[1'(i)]];
  end

  // PyMTL Update Block Source
  // At /cgra/venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/register_files.py:32
  // @update_ff
  // def up_rf_write():
  //   for i in range( wr_ports ):
  //     if s.wen[i]:
  //       s.regs[ s.waddr[i] ] <<= s.wdata[i]
  
  always_ff @(posedge clk) begin : up_rf_write
    for ( int unsigned i = 1'd0; i < 1'( __const__wr_ports_at_up_rf_write ); i += 1'd1 )
      if ( wen[1'(i)] ) begin
        regs[waddr[1'(i)]] <= wdata[1'(i)];
      end
  end

endmodule


// PyMTL Component DataMemWrapperRTL Definition
// Full name: DataMemWrapperRTL__DataType_CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1__MemReadType_MemAccessPacket_4_3_512__e6eb6c33f0815ad1__MemWriteType_MemAccessPacket_4_3_512__e6eb6c33f0815ad1__MemResponseType_MemAccessPacket_3_4_512__e6eb6c33f0815ad1__global_data_mem_size_512__per_bank_data_mem_size_32__is_combinational_False
// At /cgra/VectorCGRA/mem/data/DataMemWrapperRTL.py

module DataMemWrapperRTL__32d61ad0410ab3a5
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input MemAccessPacket_4_3_512__e6eb6c33f0815ad1 recv_rd__msg  ,
  output logic [0:0] recv_rd__rdy  ,
  input logic [0:0] recv_rd__val  ,
  input MemAccessPacket_4_3_512__e6eb6c33f0815ad1 recv_wr__msg  ,
  output logic [0:0] recv_wr__rdy  ,
  input logic [0:0] recv_wr__val  ,
  output MemAccessPacket_3_4_512__e6eb6c33f0815ad1 send__msg  ,
  input logic [0:0] send__rdy  ,
  output logic [0:0] send__val  
);
  localparam logic [5:0] __const__per_bank_data_mem_size_at_request_memory  = 6'd32;
  //-------------------------------------------------------------
  // Component channel_rd
  //-------------------------------------------------------------

  logic [0:0] channel_rd__clk;
  logic [0:0] channel_rd__reset;
  MemAccessPacket_4_3_512__e6eb6c33f0815ad1 channel_rd__recv__msg;
  logic [0:0] channel_rd__recv__rdy;
  logic [0:0] channel_rd__recv__val;
  MemAccessPacket_4_3_512__e6eb6c33f0815ad1 channel_rd__send__msg;
  logic [0:0] channel_rd__send__rdy;
  logic [0:0] channel_rd__send__val;

  ChannelRTL__3f90e4f9f6f69f44 channel_rd
  (
    .clk( channel_rd__clk ),
    .reset( channel_rd__reset ),
    .recv__msg( channel_rd__recv__msg ),
    .recv__rdy( channel_rd__recv__rdy ),
    .recv__val( channel_rd__recv__val ),
    .send__msg( channel_rd__send__msg ),
    .send__rdy( channel_rd__send__rdy ),
    .send__val( channel_rd__send__val )
  );

  //-------------------------------------------------------------
  // End of component channel_rd
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component channel_wr
  //-------------------------------------------------------------

  logic [0:0] channel_wr__clk;
  logic [0:0] channel_wr__reset;
  MemAccessPacket_4_3_512__e6eb6c33f0815ad1 channel_wr__recv__msg;
  logic [0:0] channel_wr__recv__rdy;
  logic [0:0] channel_wr__recv__val;
  MemAccessPacket_4_3_512__e6eb6c33f0815ad1 channel_wr__send__msg;
  logic [0:0] channel_wr__send__rdy;
  logic [0:0] channel_wr__send__val;

  ChannelRTL__3f90e4f9f6f69f44 channel_wr
  (
    .clk( channel_wr__clk ),
    .reset( channel_wr__reset ),
    .recv__msg( channel_wr__recv__msg ),
    .recv__rdy( channel_wr__recv__rdy ),
    .recv__val( channel_wr__recv__val ),
    .send__msg( channel_wr__send__msg ),
    .send__rdy( channel_wr__send__rdy ),
    .send__val( channel_wr__send__val )
  );

  //-------------------------------------------------------------
  // End of component channel_wr
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component memory
  //-------------------------------------------------------------

  logic [0:0] memory__clk;
  logic [4:0] memory__raddr [0:0];
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 memory__rdata [0:0];
  logic [0:0] memory__reset;
  logic [4:0] memory__waddr [0:0];
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 memory__wdata [0:0];
  logic [0:0] memory__wen [0:0];

  RegisterFile__217468e476601edf memory
  (
    .clk( memory__clk ),
    .raddr( memory__raddr ),
    .rdata( memory__rdata ),
    .reset( memory__reset ),
    .waddr( memory__waddr ),
    .wdata( memory__wdata ),
    .wen( memory__wen )
  );

  //-------------------------------------------------------------
  // End of component memory
  //-------------------------------------------------------------

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/mem/data/DataMemWrapperRTL.py:58
  // @update
  // def compose_send_msg():
  //   s.send.msg @= MemResponseType(0, 0, 0, DataType(0, 0, 0, 0), 0, 0, 0)
  //   # TODO: change to pipe's out's wen.
  //   if s.channel_rd.send.val:
  //     s.send.msg.src                @= s.channel_rd.send.msg.dst
  //     s.send.msg.dst                @= s.channel_rd.send.msg.src
  //     s.send.msg.addr               @= s.channel_rd.send.msg.addr
  //     s.send.msg.data               @= s.memory.rdata[0]
  //     s.send.msg.src_cgra           @= s.channel_rd.send.msg.src_cgra
  //     s.send.msg.src_tile           @= s.channel_rd.send.msg.src_tile
  //     s.send.msg.remote_src_port    @= s.channel_rd.send.msg.remote_src_port
  
  always_comb begin : compose_send_msg
    send__msg = { 2'd0, 2'd0, 9'd0, { 32'd0, 1'd0, 1'd0, 1'd0 }, 2'd0, 3'd0, 2'd0 };
    if ( channel_rd__send__val ) begin
      send__msg.src = channel_rd__send__msg.dst;
      send__msg.dst = channel_rd__send__msg.src;
      send__msg.addr = channel_rd__send__msg.addr;
      send__msg.data = memory__rdata[1'd0];
      send__msg.src_cgra = channel_rd__send__msg.src_cgra;
      send__msg.src_tile = channel_rd__send__msg.src_tile;
      send__msg.remote_src_port = channel_rd__send__msg.remote_src_port;
    end
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/mem/data/DataMemWrapperRTL.py:88
  // @update
  // def notify_channel_rdy():
  //   # TODO: change to SRAM's rdy when replacing register file
  //   # with SRAM.
  //   s.channel_rd.send.rdy @= s.send.rdy
  //   s.channel_wr.send.rdy @= 1
  
  always_comb begin : notify_channel_rdy
    channel_rd__send__rdy = send__rdy;
    channel_wr__send__rdy = 1'd1;
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/mem/data/DataMemWrapperRTL.py:95
  // @update
  // def notify_send_val():
  //   # TODO: change to SRAM's valid when replacing register file
  //   # with SRAM.
  //   s.send.val @= s.channel_rd.send.val
  
  always_comb begin : notify_send_val
    send__val = channel_rd__send__val;
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/mem/data/DataMemWrapperRTL.py:71
  // @update
  // def request_memory():
  //   # Default values.
  //   s.memory.wen[0]   @= 0
  //   s.memory.raddr[0] @= PerBankAddrType(0)
  //   s.memory.waddr[0] @= PerBankAddrType(0)
  //   s.memory.wdata[0] @= DataType(0, 0, 0, 0)
  // 
  //   if s.channel_rd.send.val:
  //     s.memory.raddr[0] @= \
  //       trunc(s.channel_rd.send.msg.addr % per_bank_data_mem_size, PerBankAddrType)
  //   if s.channel_wr.send.val:
  //     s.memory.waddr[0] @= \
  //       trunc(s.channel_wr.send.msg.addr % per_bank_data_mem_size, PerBankAddrType)
  //     s.memory.wdata[0] @= s.channel_wr.send.msg.data
  //     s.memory.wen[0]   @= 1
  
  always_comb begin : request_memory
    memory__wen[1'd0] = 1'd0;
    memory__raddr[1'd0] = 5'd0;
    memory__waddr[1'd0] = 5'd0;
    memory__wdata[1'd0] = { 32'd0, 1'd0, 1'd0, 1'd0 };
    if ( channel_rd__send__val ) begin
      memory__raddr[1'd0] = 5'(channel_rd__send__msg.addr % 9'( __const__per_bank_data_mem_size_at_request_memory ));
    end
    if ( channel_wr__send__val ) begin
      memory__waddr[1'd0] = 5'(channel_wr__send__msg.addr % 9'( __const__per_bank_data_mem_size_at_request_memory ));
      memory__wdata[1'd0] = channel_wr__send__msg.data;
      memory__wen[1'd0] = 1'd1;
    end
  end

  assign memory__clk = clk;
  assign memory__reset = reset;
  assign channel_rd__clk = clk;
  assign channel_rd__reset = reset;
  assign channel_wr__clk = clk;
  assign channel_wr__reset = reset;
  assign channel_rd__recv__msg = recv_rd__msg;
  assign recv_rd__rdy = channel_rd__recv__rdy;
  assign channel_rd__recv__val = recv_rd__val;
  assign channel_wr__recv__msg = recv_wr__msg;
  assign recv_wr__rdy = channel_wr__recv__rdy;
  assign channel_wr__recv__val = recv_wr__val;

endmodule


// PyMTL Component Mux Definition
// At /cgra/venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/arithmetics.py

module Mux__Type_MemAccessPacket_4_3_512__e6eb6c33f0815ad1__ninputs_2
(
  input  logic [0:0] clk ,
  input  MemAccessPacket_4_3_512__e6eb6c33f0815ad1 in_ [0:1],
  output MemAccessPacket_4_3_512__e6eb6c33f0815ad1 out ,
  input  logic [0:0] reset ,
  input  logic [0:0] sel 
);

  // PyMTL Update Block Source
  // At /cgra/venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/arithmetics.py:13
  // @update
  // def up_mux():
  //   s.out @= s.in_[ s.sel ]
  
  always_comb begin : up_mux
    out = in_[sel];
  end

endmodule


// PyMTL Component BypassQueueDpathRTL Definition
// Full name: BypassQueueDpathRTL__EntryType_MemAccessPacket_4_3_512__e6eb6c33f0815ad1__num_entries_2
// At /cgra/VectorCGRA/lib/basic/val_rdy/queues.py

module BypassQueueDpathRTL__69d7201f95bb857e
(
  input  logic [0:0] clk ,
  input  logic [0:0] mux_sel ,
  input  logic [0:0] raddr ,
  input  MemAccessPacket_4_3_512__e6eb6c33f0815ad1 recv_msg ,
  input  logic [0:0] reset ,
  output MemAccessPacket_4_3_512__e6eb6c33f0815ad1 send_msg ,
  input  logic [0:0] waddr ,
  input  logic [0:0] wen 
);
  //-------------------------------------------------------------
  // Component mux
  //-------------------------------------------------------------

  logic [0:0] mux__clk;
  MemAccessPacket_4_3_512__e6eb6c33f0815ad1 mux__in_ [0:1];
  MemAccessPacket_4_3_512__e6eb6c33f0815ad1 mux__out;
  logic [0:0] mux__reset;
  logic [0:0] mux__sel;

  Mux__Type_MemAccessPacket_4_3_512__e6eb6c33f0815ad1__ninputs_2 mux
  (
    .clk( mux__clk ),
    .in_( mux__in_ ),
    .out( mux__out ),
    .reset( mux__reset ),
    .sel( mux__sel )
  );

  //-------------------------------------------------------------
  // End of component mux
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component rf
  //-------------------------------------------------------------

  logic [0:0] rf__clk;
  logic [0:0] rf__raddr [0:0];
  MemAccessPacket_4_3_512__e6eb6c33f0815ad1 rf__rdata [0:0];
  logic [0:0] rf__reset;
  logic [0:0] rf__waddr [0:0];
  MemAccessPacket_4_3_512__e6eb6c33f0815ad1 rf__wdata [0:0];
  logic [0:0] rf__wen [0:0];

  RegisterFile__f7ac537c1018529c rf
  (
    .clk( rf__clk ),
    .raddr( rf__raddr ),
    .rdata( rf__rdata ),
    .reset( rf__reset ),
    .waddr( rf__waddr ),
    .wdata( rf__wdata ),
    .wen( rf__wen )
  );

  //-------------------------------------------------------------
  // End of component rf
  //-------------------------------------------------------------

  assign rf__clk = clk;
  assign rf__reset = reset;
  assign rf__raddr[0] = raddr;
  assign rf__wen[0] = wen;
  assign rf__waddr[0] = waddr;
  assign rf__wdata[0] = recv_msg;
  assign mux__clk = clk;
  assign mux__reset = reset;
  assign mux__sel = mux_sel;
  assign mux__in_[0] = rf__rdata[0];
  assign mux__in_[1] = recv_msg;
  assign send_msg = mux__out;

endmodule


// PyMTL Component BypassQueueRTL Definition
// Full name: BypassQueueRTL__EntryType_MemAccessPacket_4_3_512__e6eb6c33f0815ad1__num_entries_2
// At /cgra/VectorCGRA/lib/basic/val_rdy/queues.py

module BypassQueueRTL__69d7201f95bb857e
(
  input  logic [0:0] clk ,
  output logic [1:0] count ,
  input  logic [0:0] reset ,
  input MemAccessPacket_4_3_512__e6eb6c33f0815ad1 recv__msg  ,
  output logic [0:0] recv__rdy  ,
  input logic [0:0] recv__val  ,
  output MemAccessPacket_4_3_512__e6eb6c33f0815ad1 send__msg  ,
  input logic [0:0] send__rdy  ,
  output logic [0:0] send__val  
);
  //-------------------------------------------------------------
  // Component ctrl
  //-------------------------------------------------------------

  logic [0:0] ctrl__clk;
  logic [1:0] ctrl__count;
  logic [0:0] ctrl__mux_sel;
  logic [0:0] ctrl__raddr;
  logic [0:0] ctrl__recv_rdy;
  logic [0:0] ctrl__recv_val;
  logic [0:0] ctrl__reset;
  logic [0:0] ctrl__send_rdy;
  logic [0:0] ctrl__send_val;
  logic [0:0] ctrl__waddr;
  logic [0:0] ctrl__wen;

  BypassQueueCtrlRTL__num_entries_2 ctrl
  (
    .clk( ctrl__clk ),
    .count( ctrl__count ),
    .mux_sel( ctrl__mux_sel ),
    .raddr( ctrl__raddr ),
    .recv_rdy( ctrl__recv_rdy ),
    .recv_val( ctrl__recv_val ),
    .reset( ctrl__reset ),
    .send_rdy( ctrl__send_rdy ),
    .send_val( ctrl__send_val ),
    .waddr( ctrl__waddr ),
    .wen( ctrl__wen )
  );

  //-------------------------------------------------------------
  // End of component ctrl
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component dpath
  //-------------------------------------------------------------

  logic [0:0] dpath__clk;
  logic [0:0] dpath__mux_sel;
  logic [0:0] dpath__raddr;
  MemAccessPacket_4_3_512__e6eb6c33f0815ad1 dpath__recv_msg;
  logic [0:0] dpath__reset;
  MemAccessPacket_4_3_512__e6eb6c33f0815ad1 dpath__send_msg;
  logic [0:0] dpath__waddr;
  logic [0:0] dpath__wen;

  BypassQueueDpathRTL__69d7201f95bb857e dpath
  (
    .clk( dpath__clk ),
    .mux_sel( dpath__mux_sel ),
    .raddr( dpath__raddr ),
    .recv_msg( dpath__recv_msg ),
    .reset( dpath__reset ),
    .send_msg( dpath__send_msg ),
    .waddr( dpath__waddr ),
    .wen( dpath__wen )
  );

  //-------------------------------------------------------------
  // End of component dpath
  //-------------------------------------------------------------

  assign ctrl__clk = clk;
  assign ctrl__reset = reset;
  assign dpath__clk = clk;
  assign dpath__reset = reset;
  assign dpath__wen = ctrl__wen;
  assign dpath__waddr = ctrl__waddr;
  assign dpath__raddr = ctrl__raddr;
  assign dpath__mux_sel = ctrl__mux_sel;
  assign ctrl__recv_val = recv__val;
  assign recv__rdy = ctrl__recv_rdy;
  assign send__val = ctrl__send_val;
  assign ctrl__send_rdy = send__rdy;
  assign count = ctrl__count;
  assign dpath__recv_msg = recv__msg;
  assign send__msg = dpath__send_msg;

endmodule


// PyMTL Component InputUnitRTL Definition
// Full name: InputUnitRTL__PacketType_MemAccessPacket_4_3_512__e6eb6c33f0815ad1__QueueType_BypassQueueRTL
// At /cgra/VectorCGRA/noc/PyOCN/pymtl3_net/router/InputUnitRTL.py

module InputUnitRTL__e5f985f1cb3f044e
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input MemAccessPacket_4_3_512__e6eb6c33f0815ad1 recv__msg  ,
  output logic [0:0] recv__rdy  ,
  input logic [0:0] recv__val  ,
  output MemAccessPacket_4_3_512__e6eb6c33f0815ad1 send__msg  ,
  input logic [0:0] send__rdy  ,
  output logic [0:0] send__val  
);
  //-------------------------------------------------------------
  // Component queue
  //-------------------------------------------------------------

  logic [0:0] queue__clk;
  logic [1:0] queue__count;
  logic [0:0] queue__reset;
  MemAccessPacket_4_3_512__e6eb6c33f0815ad1 queue__recv__msg;
  logic [0:0] queue__recv__rdy;
  logic [0:0] queue__recv__val;
  MemAccessPacket_4_3_512__e6eb6c33f0815ad1 queue__send__msg;
  logic [0:0] queue__send__rdy;
  logic [0:0] queue__send__val;

  BypassQueueRTL__69d7201f95bb857e queue
  (
    .clk( queue__clk ),
    .count( queue__count ),
    .reset( queue__reset ),
    .recv__msg( queue__recv__msg ),
    .recv__rdy( queue__recv__rdy ),
    .recv__val( queue__recv__val ),
    .send__msg( queue__send__msg ),
    .send__rdy( queue__send__rdy ),
    .send__val( queue__send__val )
  );

  //-------------------------------------------------------------
  // End of component queue
  //-------------------------------------------------------------

  assign queue__clk = clk;
  assign queue__reset = reset;
  assign queue__recv__msg = recv__msg;
  assign recv__rdy = queue__recv__rdy;
  assign queue__recv__val = recv__val;
  assign send__msg = queue__send__msg;
  assign queue__send__rdy = send__rdy;
  assign send__val = queue__send__val;

endmodule


// PyMTL Component OutputUnitRTL Definition
// Full name: OutputUnitRTL__PacketType_MemAccessPacket_4_3_512__e6eb6c33f0815ad1__QueueType_None
// At /cgra/VectorCGRA/noc/PyOCN/pymtl3_net/router/OutputUnitRTL.py

module OutputUnitRTL__e8003dc24da1def2
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input MemAccessPacket_4_3_512__e6eb6c33f0815ad1 recv__msg  ,
  output logic [0:0] recv__rdy  ,
  input logic [0:0] recv__val  ,
  output MemAccessPacket_4_3_512__e6eb6c33f0815ad1 send__msg  ,
  input logic [0:0] send__rdy  ,
  output logic [0:0] send__val  
);

  assign send__msg = recv__msg;
  assign recv__rdy = send__rdy;
  assign send__val = recv__val;

endmodule


// PyMTL Component XbarRouteUnitRTL Definition
// Full name: XbarRouteUnitRTL__PacketType_MemAccessPacket_4_3_512__e6eb6c33f0815ad1__num_outports_3
// At /cgra/VectorCGRA/noc/PyOCN/pymtl3_net/xbar/XbarRouteUnitRTL.py

module XbarRouteUnitRTL__251c34b750ac9306
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input MemAccessPacket_4_3_512__e6eb6c33f0815ad1 recv__msg  ,
  output logic [0:0] recv__rdy  ,
  input logic [0:0] recv__val  ,
  output MemAccessPacket_4_3_512__e6eb6c33f0815ad1 send__msg [0:2] ,
  input logic [0:0] send__rdy [0:2] ,
  output logic [0:0] send__val [0:2] 
);
  localparam logic [1:0] __const__num_outports_at_up_ru_routing  = 2'd3;
  logic [1:0] out_dir;
  logic [2:0] send_val;

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/noc/PyOCN/pymtl3_net/xbar/XbarRouteUnitRTL.py:51
  // @update
  // def up_ru_recv_rdy():
  //   s.recv.rdy @= s.send[ s.out_dir ].rdy > 0
  
  always_comb begin : up_ru_recv_rdy
    recv__rdy = send__rdy[out_dir] > 1'd0;
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/noc/PyOCN/pymtl3_net/xbar/XbarRouteUnitRTL.py:41
  // @update
  // def up_ru_routing():
  //   s.out_dir @= trunc( s.recv.msg.dst, dir_nbits )
  // 
  //   for i in range( num_outports ):
  //     s.send[i].val @= b1(0)
  // 
  //   if s.recv.val:
  //     s.send[ s.out_dir ].val @= b1(1)
  
  always_comb begin : up_ru_routing
    out_dir = recv__msg.dst;
    for ( int unsigned i = 1'd0; i < 2'( __const__num_outports_at_up_ru_routing ); i += 1'd1 )
      send__val[2'(i)] = 1'd0;
    if ( recv__val ) begin
      send__val[out_dir] = 1'd1;
    end
  end

  assign send__msg[0] = recv__msg;
  assign send_val[0:0] = send__val[0];
  assign send__msg[1] = recv__msg;
  assign send_val[1:1] = send__val[1];
  assign send__msg[2] = recv__msg;
  assign send_val[2:2] = send__val[2];

endmodule


// PyMTL Component RegEnRst Definition
// At /cgra/venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/registers.py

module RegEnRst__Type_Bits4__reset_value_1
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  input  logic [3:0] in_ ,
  output logic [3:0] out ,
  input  logic [0:0] reset 
);
  localparam logic [0:0] __const__reset_value_at_up_regenrst  = 1'd1;

  // PyMTL Update Block Source
  // At /cgra/venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/registers.py:55
  // @update_ff
  // def up_regenrst():
  //   if s.reset: s.out <<= reset_value
  //   elif s.en:  s.out <<= s.in_
  
  always_ff @(posedge clk) begin : up_regenrst
    if ( reset ) begin
      out <= 4'( __const__reset_value_at_up_regenrst );
    end
    else if ( en ) begin
      out <= in_;
    end
  end

endmodule


// PyMTL Component RoundRobinArbiterEn Definition
// At /cgra/venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/arbiters.py

module RoundRobinArbiterEn__nreqs_4
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  output logic [3:0] grants ,
  input  logic [3:0] reqs ,
  input  logic [0:0] reset 
);
  localparam logic [2:0] __const__nreqs_at_comb_reqs_int  = 3'd4;
  localparam logic [3:0] __const__nreqsX2_at_comb_reqs_int  = 4'd8;
  localparam logic [2:0] __const__nreqs_at_comb_grants  = 3'd4;
  localparam logic [2:0] __const__nreqs_at_comb_priority_int  = 3'd4;
  localparam logic [3:0] __const__nreqsX2_at_comb_priority_int  = 4'd8;
  localparam logic [3:0] __const__nreqsX2_at_comb_kills  = 4'd8;
  localparam logic [3:0] __const__nreqsX2_at_comb_grants_int  = 4'd8;
  logic [7:0] grants_int;
  logic [8:0] kills;
  logic [0:0] priority_en;
  logic [7:0] priority_int;
  logic [7:0] reqs_int;
  //-------------------------------------------------------------
  // Component priority_reg
  //-------------------------------------------------------------

  logic [0:0] priority_reg__clk;
  logic [0:0] priority_reg__en;
  logic [3:0] priority_reg__in_;
  logic [3:0] priority_reg__out;
  logic [0:0] priority_reg__reset;

  RegEnRst__Type_Bits4__reset_value_1 priority_reg
  (
    .clk( priority_reg__clk ),
    .en( priority_reg__en ),
    .in_( priority_reg__in_ ),
    .out( priority_reg__out ),
    .reset( priority_reg__reset )
  );

  //-------------------------------------------------------------
  // End of component priority_reg
  //-------------------------------------------------------------

  // PyMTL Update Block Source
  // At /cgra/venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/arbiters.py:118
  // @update
  // def comb_grants():
  //   for i in range( nreqs ):
  //     s.grants[i] @= s.grants_int[i] | s.grants_int[nreqs+i]
  
  always_comb begin : comb_grants
    for ( int unsigned i = 1'd0; i < 3'( __const__nreqs_at_comb_grants ); i += 1'd1 )
      grants[2'(i)] = grants_int[3'(i)] | grants_int[3'( __const__nreqs_at_comb_grants ) + 3'(i)];
  end

  // PyMTL Update Block Source
  // At /cgra/venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/arbiters.py:141
  // @update
  // def comb_grants_int():
  //   for i in range( nreqsX2 ):
  //     if s.priority_int[i]:
  //       s.grants_int[i] @= s.reqs_int[i]
  //     else:
  //       s.grants_int[i] @= ~s.kills[i] & s.reqs_int[i]
  
  always_comb begin : comb_grants_int
    for ( int unsigned i = 1'd0; i < 4'( __const__nreqsX2_at_comb_grants_int ); i += 1'd1 )
      if ( priority_int[3'(i)] ) begin
        grants_int[3'(i)] = reqs_int[3'(i)];
      end
      else
        grants_int[3'(i)] = ( ~kills[4'(i)] ) & reqs_int[3'(i)];
  end

  // PyMTL Update Block Source
  // At /cgra/venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/arbiters.py:132
  // @update
  // def comb_kills():
  //   s.kills[0] @= 1
  //   for i in range( nreqsX2 ):
  //     if s.priority_int[i]:
  //       s.kills[i+1] @= s.reqs_int[i]
  //     else:
  //       s.kills[i+1] @= s.kills[i] | ( ~s.kills[i] & s.reqs_int[i] )
  
  always_comb begin : comb_kills
    kills[4'd0] = 1'd1;
    for ( int unsigned i = 1'd0; i < 4'( __const__nreqsX2_at_comb_kills ); i += 1'd1 )
      if ( priority_int[3'(i)] ) begin
        kills[4'(i) + 4'd1] = reqs_int[3'(i)];
      end
      else
        kills[4'(i) + 4'd1] = kills[4'(i)] | ( ( ~kills[4'(i)] ) & reqs_int[3'(i)] );
  end

  // PyMTL Update Block Source
  // At /cgra/venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/arbiters.py:123
  // @update
  // def comb_priority_en():
  //   s.priority_en @= ( s.grants != 0 ) & s.en
  
  always_comb begin : comb_priority_en
    priority_en = ( grants != 4'd0 ) & en;
  end

  // PyMTL Update Block Source
  // At /cgra/venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/arbiters.py:127
  // @update
  // def comb_priority_int():
  //   s.priority_int[    0:nreqs  ] @= s.priority_reg.out
  //   s.priority_int[nreqs:nreqsX2] @= 0
  
  always_comb begin : comb_priority_int
    priority_int[3'd3:3'd0] = priority_reg__out;
    priority_int[3'd7:3'( __const__nreqs_at_comb_priority_int )] = 4'd0;
  end

  // PyMTL Update Block Source
  // At /cgra/venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/arbiters.py:113
  // @update
  // def comb_reqs_int():
  //   s.reqs_int [    0:nreqs  ] @= s.reqs
  //   s.reqs_int [nreqs:nreqsX2] @= s.reqs
  
  always_comb begin : comb_reqs_int
    reqs_int[3'd3:3'd0] = reqs;
    reqs_int[3'd7:3'( __const__nreqs_at_comb_reqs_int )] = reqs;
  end

  assign priority_reg__clk = clk;
  assign priority_reg__reset = reset;
  assign priority_reg__en = priority_en;
  assign priority_reg__in_[3:1] = grants[2:0];
  assign priority_reg__in_[0:0] = grants[3:3];

endmodule


// PyMTL Component Encoder Definition
// At /cgra/venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/encoders.py

module Encoder__in_nbits_4__out_nbits_2
(
  input  logic [0:0] clk ,
  input  logic [3:0] in_ ,
  output logic [1:0] out ,
  input  logic [0:0] reset 
);

  // PyMTL Update Block Source
  // At /cgra/venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/encoders.py:28
  // @update
  // def encode():
  //   s.out @= 0
  //   for i in range( s.in_nbits ):
  //     if s.in_[i]:
  //       s.out @= i
  
  always_comb begin : encode
    out = 2'd0;
    for ( int unsigned i = 1'd0; i < 3'd4; i += 1'd1 )
      if ( in_[2'(i)] ) begin
        out = 2'(i);
      end
  end

endmodule


// PyMTL Component Mux Definition
// At /cgra/venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/arithmetics.py

module Mux__Type_MemAccessPacket_4_3_512__e6eb6c33f0815ad1__ninputs_4
(
  input  logic [0:0] clk ,
  input  MemAccessPacket_4_3_512__e6eb6c33f0815ad1 in_ [0:3],
  output MemAccessPacket_4_3_512__e6eb6c33f0815ad1 out ,
  input  logic [0:0] reset ,
  input  logic [1:0] sel 
);

  // PyMTL Update Block Source
  // At /cgra/venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/arithmetics.py:13
  // @update
  // def up_mux():
  //   s.out @= s.in_[ s.sel ]
  
  always_comb begin : up_mux
    out = in_[sel];
  end

endmodule


// PyMTL Component SwitchUnitRTL Definition
// Full name: SwitchUnitRTL__PacketType_MemAccessPacket_4_3_512__e6eb6c33f0815ad1__num_inports_4
// At /cgra/VectorCGRA/noc/PyOCN/pymtl3_net/router/SwitchUnitRTL.py

module SwitchUnitRTL__7c21928e9a5f254a
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input MemAccessPacket_4_3_512__e6eb6c33f0815ad1 recv__msg [0:3] ,
  output logic [0:0] recv__rdy [0:3] ,
  input logic [0:0] recv__val [0:3] ,
  output MemAccessPacket_4_3_512__e6eb6c33f0815ad1 send__msg  ,
  input logic [0:0] send__rdy  ,
  output logic [0:0] send__val  
);
  localparam logic [2:0] __const__num_inports_at_up_get_en  = 3'd4;
  //-------------------------------------------------------------
  // Component arbiter
  //-------------------------------------------------------------

  logic [0:0] arbiter__clk;
  logic [0:0] arbiter__en;
  logic [3:0] arbiter__grants;
  logic [3:0] arbiter__reqs;
  logic [0:0] arbiter__reset;

  RoundRobinArbiterEn__nreqs_4 arbiter
  (
    .clk( arbiter__clk ),
    .en( arbiter__en ),
    .grants( arbiter__grants ),
    .reqs( arbiter__reqs ),
    .reset( arbiter__reset )
  );

  //-------------------------------------------------------------
  // End of component arbiter
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component encoder
  //-------------------------------------------------------------

  logic [0:0] encoder__clk;
  logic [3:0] encoder__in_;
  logic [1:0] encoder__out;
  logic [0:0] encoder__reset;

  Encoder__in_nbits_4__out_nbits_2 encoder
  (
    .clk( encoder__clk ),
    .in_( encoder__in_ ),
    .out( encoder__out ),
    .reset( encoder__reset )
  );

  //-------------------------------------------------------------
  // End of component encoder
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component mux
  //-------------------------------------------------------------

  logic [0:0] mux__clk;
  MemAccessPacket_4_3_512__e6eb6c33f0815ad1 mux__in_ [0:3];
  MemAccessPacket_4_3_512__e6eb6c33f0815ad1 mux__out;
  logic [0:0] mux__reset;
  logic [1:0] mux__sel;

  Mux__Type_MemAccessPacket_4_3_512__e6eb6c33f0815ad1__ninputs_4 mux
  (
    .clk( mux__clk ),
    .in_( mux__in_ ),
    .out( mux__out ),
    .reset( mux__reset ),
    .sel( mux__sel )
  );

  //-------------------------------------------------------------
  // End of component mux
  //-------------------------------------------------------------

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/noc/PyOCN/pymtl3_net/router/SwitchUnitRTL.py:56
  // @update
  // def up_get_en():
  //   for i in range( num_inports ):
  //     s.recv[i].rdy @= s.send.rdy & ( s.mux.sel == i )
  
  always_comb begin : up_get_en
    for ( int unsigned i = 1'd0; i < 3'( __const__num_inports_at_up_get_en ); i += 1'd1 )
      recv__rdy[2'(i)] = send__rdy & ( mux__sel == 2'(i) );
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/noc/PyOCN/pymtl3_net/router/SwitchUnitRTL.py:51
  // @update
  // def up_send_val():
  //   s.send.val @= s.arbiter.grants > 0
  
  always_comb begin : up_send_val
    send__val = arbiter__grants > 4'd0;
  end

  assign arbiter__clk = clk;
  assign arbiter__reset = reset;
  assign arbiter__en = 1'd1;
  assign mux__clk = clk;
  assign mux__reset = reset;
  assign send__msg = mux__out;
  assign encoder__clk = clk;
  assign encoder__reset = reset;
  assign encoder__in_ = arbiter__grants;
  assign mux__sel = encoder__out;
  assign arbiter__reqs[0:0] = recv__val[0];
  assign mux__in_[0] = recv__msg[0];
  assign arbiter__reqs[1:1] = recv__val[1];
  assign mux__in_[1] = recv__msg[1];
  assign arbiter__reqs[2:2] = recv__val[2];
  assign mux__in_[2] = recv__msg[2];
  assign arbiter__reqs[3:3] = recv__val[3];
  assign mux__in_[3] = recv__msg[3];

endmodule


// PyMTL Component XbarBypassQueueRTL Definition
// Full name: XbarBypassQueueRTL__PacketType_MemAccessPacket_4_3_512__e6eb6c33f0815ad1__num_inports_4__num_outports_3__InputUnitType_InputUnitRTL__RouteUnitType_XbarRouteUnitRTL__SwitchUnitType_SwitchUnitRTL__OutputUnitType_OutputUnitRTL
// At /cgra/VectorCGRA/noc/PyOCN/pymtl3_net/xbar/XbarBypassQueueRTL.py

module XbarBypassQueueRTL__5326d7b10201b6e9
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input MemAccessPacket_4_3_512__e6eb6c33f0815ad1 recv__msg [0:3] ,
  output logic [0:0] recv__rdy [0:3] ,
  input logic [0:0] recv__val [0:3] ,
  output MemAccessPacket_4_3_512__e6eb6c33f0815ad1 send__msg [0:2] ,
  input logic [0:0] send__rdy [0:2] ,
  output logic [0:0] send__val [0:2] 
);
  //-------------------------------------------------------------
  // Component input_units[0:3]
  //-------------------------------------------------------------

  logic [0:0] input_units__clk [0:3];
  logic [0:0] input_units__reset [0:3];
  MemAccessPacket_4_3_512__e6eb6c33f0815ad1 input_units__recv__msg [0:3];
  logic [0:0] input_units__recv__rdy [0:3];
  logic [0:0] input_units__recv__val [0:3];
  MemAccessPacket_4_3_512__e6eb6c33f0815ad1 input_units__send__msg [0:3];
  logic [0:0] input_units__send__rdy [0:3];
  logic [0:0] input_units__send__val [0:3];

  InputUnitRTL__e5f985f1cb3f044e input_units__0
  (
    .clk( input_units__clk[0] ),
    .reset( input_units__reset[0] ),
    .recv__msg( input_units__recv__msg[0] ),
    .recv__rdy( input_units__recv__rdy[0] ),
    .recv__val( input_units__recv__val[0] ),
    .send__msg( input_units__send__msg[0] ),
    .send__rdy( input_units__send__rdy[0] ),
    .send__val( input_units__send__val[0] )
  );

  InputUnitRTL__e5f985f1cb3f044e input_units__1
  (
    .clk( input_units__clk[1] ),
    .reset( input_units__reset[1] ),
    .recv__msg( input_units__recv__msg[1] ),
    .recv__rdy( input_units__recv__rdy[1] ),
    .recv__val( input_units__recv__val[1] ),
    .send__msg( input_units__send__msg[1] ),
    .send__rdy( input_units__send__rdy[1] ),
    .send__val( input_units__send__val[1] )
  );

  InputUnitRTL__e5f985f1cb3f044e input_units__2
  (
    .clk( input_units__clk[2] ),
    .reset( input_units__reset[2] ),
    .recv__msg( input_units__recv__msg[2] ),
    .recv__rdy( input_units__recv__rdy[2] ),
    .recv__val( input_units__recv__val[2] ),
    .send__msg( input_units__send__msg[2] ),
    .send__rdy( input_units__send__rdy[2] ),
    .send__val( input_units__send__val[2] )
  );

  InputUnitRTL__e5f985f1cb3f044e input_units__3
  (
    .clk( input_units__clk[3] ),
    .reset( input_units__reset[3] ),
    .recv__msg( input_units__recv__msg[3] ),
    .recv__rdy( input_units__recv__rdy[3] ),
    .recv__val( input_units__recv__val[3] ),
    .send__msg( input_units__send__msg[3] ),
    .send__rdy( input_units__send__rdy[3] ),
    .send__val( input_units__send__val[3] )
  );

  //-------------------------------------------------------------
  // End of component input_units[0:3]
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component output_units[0:2]
  //-------------------------------------------------------------

  logic [0:0] output_units__clk [0:2];
  logic [0:0] output_units__reset [0:2];
  MemAccessPacket_4_3_512__e6eb6c33f0815ad1 output_units__recv__msg [0:2];
  logic [0:0] output_units__recv__rdy [0:2];
  logic [0:0] output_units__recv__val [0:2];
  MemAccessPacket_4_3_512__e6eb6c33f0815ad1 output_units__send__msg [0:2];
  logic [0:0] output_units__send__rdy [0:2];
  logic [0:0] output_units__send__val [0:2];

  OutputUnitRTL__e8003dc24da1def2 output_units__0
  (
    .clk( output_units__clk[0] ),
    .reset( output_units__reset[0] ),
    .recv__msg( output_units__recv__msg[0] ),
    .recv__rdy( output_units__recv__rdy[0] ),
    .recv__val( output_units__recv__val[0] ),
    .send__msg( output_units__send__msg[0] ),
    .send__rdy( output_units__send__rdy[0] ),
    .send__val( output_units__send__val[0] )
  );

  OutputUnitRTL__e8003dc24da1def2 output_units__1
  (
    .clk( output_units__clk[1] ),
    .reset( output_units__reset[1] ),
    .recv__msg( output_units__recv__msg[1] ),
    .recv__rdy( output_units__recv__rdy[1] ),
    .recv__val( output_units__recv__val[1] ),
    .send__msg( output_units__send__msg[1] ),
    .send__rdy( output_units__send__rdy[1] ),
    .send__val( output_units__send__val[1] )
  );

  OutputUnitRTL__e8003dc24da1def2 output_units__2
  (
    .clk( output_units__clk[2] ),
    .reset( output_units__reset[2] ),
    .recv__msg( output_units__recv__msg[2] ),
    .recv__rdy( output_units__recv__rdy[2] ),
    .recv__val( output_units__recv__val[2] ),
    .send__msg( output_units__send__msg[2] ),
    .send__rdy( output_units__send__rdy[2] ),
    .send__val( output_units__send__val[2] )
  );

  //-------------------------------------------------------------
  // End of component output_units[0:2]
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component route_units[0:3]
  //-------------------------------------------------------------

  logic [0:0] route_units__clk [0:3];
  logic [0:0] route_units__reset [0:3];
  MemAccessPacket_4_3_512__e6eb6c33f0815ad1 route_units__recv__msg [0:3];
  logic [0:0] route_units__recv__rdy [0:3];
  logic [0:0] route_units__recv__val [0:3];
  MemAccessPacket_4_3_512__e6eb6c33f0815ad1 route_units__send__msg [0:3][0:2];
  logic [0:0] route_units__send__rdy [0:3][0:2];
  logic [0:0] route_units__send__val [0:3][0:2];

  XbarRouteUnitRTL__251c34b750ac9306 route_units__0
  (
    .clk( route_units__clk[0] ),
    .reset( route_units__reset[0] ),
    .recv__msg( route_units__recv__msg[0] ),
    .recv__rdy( route_units__recv__rdy[0] ),
    .recv__val( route_units__recv__val[0] ),
    .send__msg( route_units__send__msg[0] ),
    .send__rdy( route_units__send__rdy[0] ),
    .send__val( route_units__send__val[0] )
  );

  XbarRouteUnitRTL__251c34b750ac9306 route_units__1
  (
    .clk( route_units__clk[1] ),
    .reset( route_units__reset[1] ),
    .recv__msg( route_units__recv__msg[1] ),
    .recv__rdy( route_units__recv__rdy[1] ),
    .recv__val( route_units__recv__val[1] ),
    .send__msg( route_units__send__msg[1] ),
    .send__rdy( route_units__send__rdy[1] ),
    .send__val( route_units__send__val[1] )
  );

  XbarRouteUnitRTL__251c34b750ac9306 route_units__2
  (
    .clk( route_units__clk[2] ),
    .reset( route_units__reset[2] ),
    .recv__msg( route_units__recv__msg[2] ),
    .recv__rdy( route_units__recv__rdy[2] ),
    .recv__val( route_units__recv__val[2] ),
    .send__msg( route_units__send__msg[2] ),
    .send__rdy( route_units__send__rdy[2] ),
    .send__val( route_units__send__val[2] )
  );

  XbarRouteUnitRTL__251c34b750ac9306 route_units__3
  (
    .clk( route_units__clk[3] ),
    .reset( route_units__reset[3] ),
    .recv__msg( route_units__recv__msg[3] ),
    .recv__rdy( route_units__recv__rdy[3] ),
    .recv__val( route_units__recv__val[3] ),
    .send__msg( route_units__send__msg[3] ),
    .send__rdy( route_units__send__rdy[3] ),
    .send__val( route_units__send__val[3] )
  );

  //-------------------------------------------------------------
  // End of component route_units[0:3]
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component switch_units[0:2]
  //-------------------------------------------------------------

  logic [0:0] switch_units__clk [0:2];
  logic [0:0] switch_units__reset [0:2];
  MemAccessPacket_4_3_512__e6eb6c33f0815ad1 switch_units__recv__msg [0:2][0:3];
  logic [0:0] switch_units__recv__rdy [0:2][0:3];
  logic [0:0] switch_units__recv__val [0:2][0:3];
  MemAccessPacket_4_3_512__e6eb6c33f0815ad1 switch_units__send__msg [0:2];
  logic [0:0] switch_units__send__rdy [0:2];
  logic [0:0] switch_units__send__val [0:2];

  SwitchUnitRTL__7c21928e9a5f254a switch_units__0
  (
    .clk( switch_units__clk[0] ),
    .reset( switch_units__reset[0] ),
    .recv__msg( switch_units__recv__msg[0] ),
    .recv__rdy( switch_units__recv__rdy[0] ),
    .recv__val( switch_units__recv__val[0] ),
    .send__msg( switch_units__send__msg[0] ),
    .send__rdy( switch_units__send__rdy[0] ),
    .send__val( switch_units__send__val[0] )
  );

  SwitchUnitRTL__7c21928e9a5f254a switch_units__1
  (
    .clk( switch_units__clk[1] ),
    .reset( switch_units__reset[1] ),
    .recv__msg( switch_units__recv__msg[1] ),
    .recv__rdy( switch_units__recv__rdy[1] ),
    .recv__val( switch_units__recv__val[1] ),
    .send__msg( switch_units__send__msg[1] ),
    .send__rdy( switch_units__send__rdy[1] ),
    .send__val( switch_units__send__val[1] )
  );

  SwitchUnitRTL__7c21928e9a5f254a switch_units__2
  (
    .clk( switch_units__clk[2] ),
    .reset( switch_units__reset[2] ),
    .recv__msg( switch_units__recv__msg[2] ),
    .recv__rdy( switch_units__recv__rdy[2] ),
    .recv__val( switch_units__recv__val[2] ),
    .send__msg( switch_units__send__msg[2] ),
    .send__rdy( switch_units__send__rdy[2] ),
    .send__val( switch_units__send__val[2] )
  );

  //-------------------------------------------------------------
  // End of component switch_units[0:2]
  //-------------------------------------------------------------

  assign input_units__clk[0] = clk;
  assign input_units__reset[0] = reset;
  assign input_units__clk[1] = clk;
  assign input_units__reset[1] = reset;
  assign input_units__clk[2] = clk;
  assign input_units__reset[2] = reset;
  assign input_units__clk[3] = clk;
  assign input_units__reset[3] = reset;
  assign route_units__clk[0] = clk;
  assign route_units__reset[0] = reset;
  assign route_units__clk[1] = clk;
  assign route_units__reset[1] = reset;
  assign route_units__clk[2] = clk;
  assign route_units__reset[2] = reset;
  assign route_units__clk[3] = clk;
  assign route_units__reset[3] = reset;
  assign switch_units__clk[0] = clk;
  assign switch_units__reset[0] = reset;
  assign switch_units__clk[1] = clk;
  assign switch_units__reset[1] = reset;
  assign switch_units__clk[2] = clk;
  assign switch_units__reset[2] = reset;
  assign output_units__clk[0] = clk;
  assign output_units__reset[0] = reset;
  assign output_units__clk[1] = clk;
  assign output_units__reset[1] = reset;
  assign output_units__clk[2] = clk;
  assign output_units__reset[2] = reset;
  assign input_units__recv__msg[0] = recv__msg[0];
  assign recv__rdy[0] = input_units__recv__rdy[0];
  assign input_units__recv__val[0] = recv__val[0];
  assign route_units__recv__msg[0] = input_units__send__msg[0];
  assign input_units__send__rdy[0] = route_units__recv__rdy[0];
  assign route_units__recv__val[0] = input_units__send__val[0];
  assign input_units__recv__msg[1] = recv__msg[1];
  assign recv__rdy[1] = input_units__recv__rdy[1];
  assign input_units__recv__val[1] = recv__val[1];
  assign route_units__recv__msg[1] = input_units__send__msg[1];
  assign input_units__send__rdy[1] = route_units__recv__rdy[1];
  assign route_units__recv__val[1] = input_units__send__val[1];
  assign input_units__recv__msg[2] = recv__msg[2];
  assign recv__rdy[2] = input_units__recv__rdy[2];
  assign input_units__recv__val[2] = recv__val[2];
  assign route_units__recv__msg[2] = input_units__send__msg[2];
  assign input_units__send__rdy[2] = route_units__recv__rdy[2];
  assign route_units__recv__val[2] = input_units__send__val[2];
  assign input_units__recv__msg[3] = recv__msg[3];
  assign recv__rdy[3] = input_units__recv__rdy[3];
  assign input_units__recv__val[3] = recv__val[3];
  assign route_units__recv__msg[3] = input_units__send__msg[3];
  assign input_units__send__rdy[3] = route_units__recv__rdy[3];
  assign route_units__recv__val[3] = input_units__send__val[3];
  assign switch_units__recv__msg[0][0] = route_units__send__msg[0][0];
  assign route_units__send__rdy[0][0] = switch_units__recv__rdy[0][0];
  assign switch_units__recv__val[0][0] = route_units__send__val[0][0];
  assign switch_units__recv__msg[1][0] = route_units__send__msg[0][1];
  assign route_units__send__rdy[0][1] = switch_units__recv__rdy[1][0];
  assign switch_units__recv__val[1][0] = route_units__send__val[0][1];
  assign switch_units__recv__msg[2][0] = route_units__send__msg[0][2];
  assign route_units__send__rdy[0][2] = switch_units__recv__rdy[2][0];
  assign switch_units__recv__val[2][0] = route_units__send__val[0][2];
  assign switch_units__recv__msg[0][1] = route_units__send__msg[1][0];
  assign route_units__send__rdy[1][0] = switch_units__recv__rdy[0][1];
  assign switch_units__recv__val[0][1] = route_units__send__val[1][0];
  assign switch_units__recv__msg[1][1] = route_units__send__msg[1][1];
  assign route_units__send__rdy[1][1] = switch_units__recv__rdy[1][1];
  assign switch_units__recv__val[1][1] = route_units__send__val[1][1];
  assign switch_units__recv__msg[2][1] = route_units__send__msg[1][2];
  assign route_units__send__rdy[1][2] = switch_units__recv__rdy[2][1];
  assign switch_units__recv__val[2][1] = route_units__send__val[1][2];
  assign switch_units__recv__msg[0][2] = route_units__send__msg[2][0];
  assign route_units__send__rdy[2][0] = switch_units__recv__rdy[0][2];
  assign switch_units__recv__val[0][2] = route_units__send__val[2][0];
  assign switch_units__recv__msg[1][2] = route_units__send__msg[2][1];
  assign route_units__send__rdy[2][1] = switch_units__recv__rdy[1][2];
  assign switch_units__recv__val[1][2] = route_units__send__val[2][1];
  assign switch_units__recv__msg[2][2] = route_units__send__msg[2][2];
  assign route_units__send__rdy[2][2] = switch_units__recv__rdy[2][2];
  assign switch_units__recv__val[2][2] = route_units__send__val[2][2];
  assign switch_units__recv__msg[0][3] = route_units__send__msg[3][0];
  assign route_units__send__rdy[3][0] = switch_units__recv__rdy[0][3];
  assign switch_units__recv__val[0][3] = route_units__send__val[3][0];
  assign switch_units__recv__msg[1][3] = route_units__send__msg[3][1];
  assign route_units__send__rdy[3][1] = switch_units__recv__rdy[1][3];
  assign switch_units__recv__val[1][3] = route_units__send__val[3][1];
  assign switch_units__recv__msg[2][3] = route_units__send__msg[3][2];
  assign route_units__send__rdy[3][2] = switch_units__recv__rdy[2][3];
  assign switch_units__recv__val[2][3] = route_units__send__val[3][2];
  assign output_units__recv__msg[0] = switch_units__send__msg[0];
  assign switch_units__send__rdy[0] = output_units__recv__rdy[0];
  assign output_units__recv__val[0] = switch_units__send__val[0];
  assign send__msg[0] = output_units__send__msg[0];
  assign output_units__send__rdy[0] = send__rdy[0];
  assign send__val[0] = output_units__send__val[0];
  assign output_units__recv__msg[1] = switch_units__send__msg[1];
  assign switch_units__send__rdy[1] = output_units__recv__rdy[1];
  assign output_units__recv__val[1] = switch_units__send__val[1];
  assign send__msg[1] = output_units__send__msg[1];
  assign output_units__send__rdy[1] = send__rdy[1];
  assign send__val[1] = output_units__send__val[1];
  assign output_units__recv__msg[2] = switch_units__send__msg[2];
  assign switch_units__send__rdy[2] = output_units__recv__rdy[2];
  assign output_units__recv__val[2] = switch_units__send__val[2];
  assign send__msg[2] = output_units__send__msg[2];
  assign output_units__send__rdy[2] = send__rdy[2];
  assign send__val[2] = output_units__send__val[2];

endmodule


// PyMTL Component Mux Definition
// At /cgra/venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/arithmetics.py

module Mux__Type_MemAccessPacket_3_4_512__e6eb6c33f0815ad1__ninputs_2
(
  input  logic [0:0] clk ,
  input  MemAccessPacket_3_4_512__e6eb6c33f0815ad1 in_ [0:1],
  output MemAccessPacket_3_4_512__e6eb6c33f0815ad1 out ,
  input  logic [0:0] reset ,
  input  logic [0:0] sel 
);

  // PyMTL Update Block Source
  // At /cgra/venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/arithmetics.py:13
  // @update
  // def up_mux():
  //   s.out @= s.in_[ s.sel ]
  
  always_comb begin : up_mux
    out = in_[sel];
  end

endmodule


// PyMTL Component RegisterFile Definition
// Full name: RegisterFile__Type_MemAccessPacket_3_4_512__e6eb6c33f0815ad1__nregs_2__rd_ports_1__wr_ports_1__const_zero_False
// At /cgra/venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/register_files.py

module RegisterFile__d7c3b6d6e81c749e
(
  input  logic [0:0] clk ,
  input  logic [0:0] raddr [0:0],
  output MemAccessPacket_3_4_512__e6eb6c33f0815ad1 rdata [0:0],
  input  logic [0:0] reset ,
  input  logic [0:0] waddr [0:0],
  input  MemAccessPacket_3_4_512__e6eb6c33f0815ad1 wdata [0:0],
  input  logic [0:0] wen [0:0]
);
  localparam logic [0:0] __const__rd_ports_at_up_rf_read  = 1'd1;
  localparam logic [0:0] __const__wr_ports_at_up_rf_write  = 1'd1;
  MemAccessPacket_3_4_512__e6eb6c33f0815ad1 regs [0:1];

  // PyMTL Update Block Source
  // At /cgra/venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/register_files.py:20
  // @update
  // def up_rf_read():
  //   for i in range( rd_ports ):
  //     s.rdata[i] @= s.regs[ s.raddr[i] ]
  
  always_comb begin : up_rf_read
    for ( int unsigned i = 1'd0; i < 1'( __const__rd_ports_at_up_rf_read ); i += 1'd1 )
      rdata[1'(i)] = regs[raddr[1'(i)]];
  end

  // PyMTL Update Block Source
  // At /cgra/venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/register_files.py:32
  // @update_ff
  // def up_rf_write():
  //   for i in range( wr_ports ):
  //     if s.wen[i]:
  //       s.regs[ s.waddr[i] ] <<= s.wdata[i]
  
  always_ff @(posedge clk) begin : up_rf_write
    for ( int unsigned i = 1'd0; i < 1'( __const__wr_ports_at_up_rf_write ); i += 1'd1 )
      if ( wen[1'(i)] ) begin
        regs[waddr[1'(i)]] <= wdata[1'(i)];
      end
  end

endmodule


// PyMTL Component BypassQueueDpathRTL Definition
// Full name: BypassQueueDpathRTL__EntryType_MemAccessPacket_3_4_512__e6eb6c33f0815ad1__num_entries_2
// At /cgra/VectorCGRA/lib/basic/val_rdy/queues.py

module BypassQueueDpathRTL__73f7de09e257d6ce
(
  input  logic [0:0] clk ,
  input  logic [0:0] mux_sel ,
  input  logic [0:0] raddr ,
  input  MemAccessPacket_3_4_512__e6eb6c33f0815ad1 recv_msg ,
  input  logic [0:0] reset ,
  output MemAccessPacket_3_4_512__e6eb6c33f0815ad1 send_msg ,
  input  logic [0:0] waddr ,
  input  logic [0:0] wen 
);
  //-------------------------------------------------------------
  // Component mux
  //-------------------------------------------------------------

  logic [0:0] mux__clk;
  MemAccessPacket_3_4_512__e6eb6c33f0815ad1 mux__in_ [0:1];
  MemAccessPacket_3_4_512__e6eb6c33f0815ad1 mux__out;
  logic [0:0] mux__reset;
  logic [0:0] mux__sel;

  Mux__Type_MemAccessPacket_3_4_512__e6eb6c33f0815ad1__ninputs_2 mux
  (
    .clk( mux__clk ),
    .in_( mux__in_ ),
    .out( mux__out ),
    .reset( mux__reset ),
    .sel( mux__sel )
  );

  //-------------------------------------------------------------
  // End of component mux
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component rf
  //-------------------------------------------------------------

  logic [0:0] rf__clk;
  logic [0:0] rf__raddr [0:0];
  MemAccessPacket_3_4_512__e6eb6c33f0815ad1 rf__rdata [0:0];
  logic [0:0] rf__reset;
  logic [0:0] rf__waddr [0:0];
  MemAccessPacket_3_4_512__e6eb6c33f0815ad1 rf__wdata [0:0];
  logic [0:0] rf__wen [0:0];

  RegisterFile__d7c3b6d6e81c749e rf
  (
    .clk( rf__clk ),
    .raddr( rf__raddr ),
    .rdata( rf__rdata ),
    .reset( rf__reset ),
    .waddr( rf__waddr ),
    .wdata( rf__wdata ),
    .wen( rf__wen )
  );

  //-------------------------------------------------------------
  // End of component rf
  //-------------------------------------------------------------

  assign rf__clk = clk;
  assign rf__reset = reset;
  assign rf__raddr[0] = raddr;
  assign rf__wen[0] = wen;
  assign rf__waddr[0] = waddr;
  assign rf__wdata[0] = recv_msg;
  assign mux__clk = clk;
  assign mux__reset = reset;
  assign mux__sel = mux_sel;
  assign mux__in_[0] = rf__rdata[0];
  assign mux__in_[1] = recv_msg;
  assign send_msg = mux__out;

endmodule


// PyMTL Component BypassQueueRTL Definition
// Full name: BypassQueueRTL__EntryType_MemAccessPacket_3_4_512__e6eb6c33f0815ad1__num_entries_2
// At /cgra/VectorCGRA/lib/basic/val_rdy/queues.py

module BypassQueueRTL__73f7de09e257d6ce
(
  input  logic [0:0] clk ,
  output logic [1:0] count ,
  input  logic [0:0] reset ,
  input MemAccessPacket_3_4_512__e6eb6c33f0815ad1 recv__msg  ,
  output logic [0:0] recv__rdy  ,
  input logic [0:0] recv__val  ,
  output MemAccessPacket_3_4_512__e6eb6c33f0815ad1 send__msg  ,
  input logic [0:0] send__rdy  ,
  output logic [0:0] send__val  
);
  //-------------------------------------------------------------
  // Component ctrl
  //-------------------------------------------------------------

  logic [0:0] ctrl__clk;
  logic [1:0] ctrl__count;
  logic [0:0] ctrl__mux_sel;
  logic [0:0] ctrl__raddr;
  logic [0:0] ctrl__recv_rdy;
  logic [0:0] ctrl__recv_val;
  logic [0:0] ctrl__reset;
  logic [0:0] ctrl__send_rdy;
  logic [0:0] ctrl__send_val;
  logic [0:0] ctrl__waddr;
  logic [0:0] ctrl__wen;

  BypassQueueCtrlRTL__num_entries_2 ctrl
  (
    .clk( ctrl__clk ),
    .count( ctrl__count ),
    .mux_sel( ctrl__mux_sel ),
    .raddr( ctrl__raddr ),
    .recv_rdy( ctrl__recv_rdy ),
    .recv_val( ctrl__recv_val ),
    .reset( ctrl__reset ),
    .send_rdy( ctrl__send_rdy ),
    .send_val( ctrl__send_val ),
    .waddr( ctrl__waddr ),
    .wen( ctrl__wen )
  );

  //-------------------------------------------------------------
  // End of component ctrl
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component dpath
  //-------------------------------------------------------------

  logic [0:0] dpath__clk;
  logic [0:0] dpath__mux_sel;
  logic [0:0] dpath__raddr;
  MemAccessPacket_3_4_512__e6eb6c33f0815ad1 dpath__recv_msg;
  logic [0:0] dpath__reset;
  MemAccessPacket_3_4_512__e6eb6c33f0815ad1 dpath__send_msg;
  logic [0:0] dpath__waddr;
  logic [0:0] dpath__wen;

  BypassQueueDpathRTL__73f7de09e257d6ce dpath
  (
    .clk( dpath__clk ),
    .mux_sel( dpath__mux_sel ),
    .raddr( dpath__raddr ),
    .recv_msg( dpath__recv_msg ),
    .reset( dpath__reset ),
    .send_msg( dpath__send_msg ),
    .waddr( dpath__waddr ),
    .wen( dpath__wen )
  );

  //-------------------------------------------------------------
  // End of component dpath
  //-------------------------------------------------------------

  assign ctrl__clk = clk;
  assign ctrl__reset = reset;
  assign dpath__clk = clk;
  assign dpath__reset = reset;
  assign dpath__wen = ctrl__wen;
  assign dpath__waddr = ctrl__waddr;
  assign dpath__raddr = ctrl__raddr;
  assign dpath__mux_sel = ctrl__mux_sel;
  assign ctrl__recv_val = recv__val;
  assign recv__rdy = ctrl__recv_rdy;
  assign send__val = ctrl__send_val;
  assign ctrl__send_rdy = send__rdy;
  assign count = ctrl__count;
  assign dpath__recv_msg = recv__msg;
  assign send__msg = dpath__send_msg;

endmodule


// PyMTL Component InputUnitRTL Definition
// Full name: InputUnitRTL__PacketType_MemAccessPacket_3_4_512__e6eb6c33f0815ad1__QueueType_BypassQueueRTL
// At /cgra/VectorCGRA/noc/PyOCN/pymtl3_net/router/InputUnitRTL.py

module InputUnitRTL__1fd757aed6c42e02
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input MemAccessPacket_3_4_512__e6eb6c33f0815ad1 recv__msg  ,
  output logic [0:0] recv__rdy  ,
  input logic [0:0] recv__val  ,
  output MemAccessPacket_3_4_512__e6eb6c33f0815ad1 send__msg  ,
  input logic [0:0] send__rdy  ,
  output logic [0:0] send__val  
);
  //-------------------------------------------------------------
  // Component queue
  //-------------------------------------------------------------

  logic [0:0] queue__clk;
  logic [1:0] queue__count;
  logic [0:0] queue__reset;
  MemAccessPacket_3_4_512__e6eb6c33f0815ad1 queue__recv__msg;
  logic [0:0] queue__recv__rdy;
  logic [0:0] queue__recv__val;
  MemAccessPacket_3_4_512__e6eb6c33f0815ad1 queue__send__msg;
  logic [0:0] queue__send__rdy;
  logic [0:0] queue__send__val;

  BypassQueueRTL__73f7de09e257d6ce queue
  (
    .clk( queue__clk ),
    .count( queue__count ),
    .reset( queue__reset ),
    .recv__msg( queue__recv__msg ),
    .recv__rdy( queue__recv__rdy ),
    .recv__val( queue__recv__val ),
    .send__msg( queue__send__msg ),
    .send__rdy( queue__send__rdy ),
    .send__val( queue__send__val )
  );

  //-------------------------------------------------------------
  // End of component queue
  //-------------------------------------------------------------

  assign queue__clk = clk;
  assign queue__reset = reset;
  assign queue__recv__msg = recv__msg;
  assign recv__rdy = queue__recv__rdy;
  assign queue__recv__val = recv__val;
  assign send__msg = queue__send__msg;
  assign queue__send__rdy = send__rdy;
  assign send__val = queue__send__val;

endmodule


// PyMTL Component OutputUnitRTL Definition
// Full name: OutputUnitRTL__PacketType_MemAccessPacket_3_4_512__e6eb6c33f0815ad1__QueueType_None
// At /cgra/VectorCGRA/noc/PyOCN/pymtl3_net/router/OutputUnitRTL.py

module OutputUnitRTL__091ab0079fe2318d
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input MemAccessPacket_3_4_512__e6eb6c33f0815ad1 recv__msg  ,
  output logic [0:0] recv__rdy  ,
  input logic [0:0] recv__val  ,
  output MemAccessPacket_3_4_512__e6eb6c33f0815ad1 send__msg  ,
  input logic [0:0] send__rdy  ,
  output logic [0:0] send__val  
);

  assign send__msg = recv__msg;
  assign recv__rdy = send__rdy;
  assign send__val = recv__val;

endmodule


// PyMTL Component XbarRouteUnitRTL Definition
// Full name: XbarRouteUnitRTL__PacketType_MemAccessPacket_3_4_512__e6eb6c33f0815ad1__num_outports_4
// At /cgra/VectorCGRA/noc/PyOCN/pymtl3_net/xbar/XbarRouteUnitRTL.py

module XbarRouteUnitRTL__ae7f3e4fa13406f7
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input MemAccessPacket_3_4_512__e6eb6c33f0815ad1 recv__msg  ,
  output logic [0:0] recv__rdy  ,
  input logic [0:0] recv__val  ,
  output MemAccessPacket_3_4_512__e6eb6c33f0815ad1 send__msg [0:3] ,
  input logic [0:0] send__rdy [0:3] ,
  output logic [0:0] send__val [0:3] 
);
  localparam logic [2:0] __const__num_outports_at_up_ru_routing  = 3'd4;
  logic [1:0] out_dir;
  logic [3:0] send_val;

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/noc/PyOCN/pymtl3_net/xbar/XbarRouteUnitRTL.py:51
  // @update
  // def up_ru_recv_rdy():
  //   s.recv.rdy @= s.send[ s.out_dir ].rdy > 0
  
  always_comb begin : up_ru_recv_rdy
    recv__rdy = send__rdy[out_dir] > 1'd0;
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/noc/PyOCN/pymtl3_net/xbar/XbarRouteUnitRTL.py:41
  // @update
  // def up_ru_routing():
  //   s.out_dir @= trunc( s.recv.msg.dst, dir_nbits )
  // 
  //   for i in range( num_outports ):
  //     s.send[i].val @= b1(0)
  // 
  //   if s.recv.val:
  //     s.send[ s.out_dir ].val @= b1(1)
  
  always_comb begin : up_ru_routing
    out_dir = recv__msg.dst;
    for ( int unsigned i = 1'd0; i < 3'( __const__num_outports_at_up_ru_routing ); i += 1'd1 )
      send__val[2'(i)] = 1'd0;
    if ( recv__val ) begin
      send__val[out_dir] = 1'd1;
    end
  end

  assign send__msg[0] = recv__msg;
  assign send_val[0:0] = send__val[0];
  assign send__msg[1] = recv__msg;
  assign send_val[1:1] = send__val[1];
  assign send__msg[2] = recv__msg;
  assign send_val[2:2] = send__val[2];
  assign send__msg[3] = recv__msg;
  assign send_val[3:3] = send__val[3];

endmodule


// PyMTL Component RegEnRst Definition
// At /cgra/venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/registers.py

module RegEnRst__Type_Bits3__reset_value_1
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  input  logic [2:0] in_ ,
  output logic [2:0] out ,
  input  logic [0:0] reset 
);
  localparam logic [0:0] __const__reset_value_at_up_regenrst  = 1'd1;

  // PyMTL Update Block Source
  // At /cgra/venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/registers.py:55
  // @update_ff
  // def up_regenrst():
  //   if s.reset: s.out <<= reset_value
  //   elif s.en:  s.out <<= s.in_
  
  always_ff @(posedge clk) begin : up_regenrst
    if ( reset ) begin
      out <= 3'( __const__reset_value_at_up_regenrst );
    end
    else if ( en ) begin
      out <= in_;
    end
  end

endmodule


// PyMTL Component RoundRobinArbiterEn Definition
// At /cgra/venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/arbiters.py

module RoundRobinArbiterEn__nreqs_3
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  output logic [2:0] grants ,
  input  logic [2:0] reqs ,
  input  logic [0:0] reset 
);
  localparam logic [1:0] __const__nreqs_at_comb_reqs_int  = 2'd3;
  localparam logic [2:0] __const__nreqsX2_at_comb_reqs_int  = 3'd6;
  localparam logic [1:0] __const__nreqs_at_comb_grants  = 2'd3;
  localparam logic [1:0] __const__nreqs_at_comb_priority_int  = 2'd3;
  localparam logic [2:0] __const__nreqsX2_at_comb_priority_int  = 3'd6;
  localparam logic [2:0] __const__nreqsX2_at_comb_kills  = 3'd6;
  localparam logic [2:0] __const__nreqsX2_at_comb_grants_int  = 3'd6;
  logic [5:0] grants_int;
  logic [6:0] kills;
  logic [0:0] priority_en;
  logic [5:0] priority_int;
  logic [5:0] reqs_int;
  //-------------------------------------------------------------
  // Component priority_reg
  //-------------------------------------------------------------

  logic [0:0] priority_reg__clk;
  logic [0:0] priority_reg__en;
  logic [2:0] priority_reg__in_;
  logic [2:0] priority_reg__out;
  logic [0:0] priority_reg__reset;

  RegEnRst__Type_Bits3__reset_value_1 priority_reg
  (
    .clk( priority_reg__clk ),
    .en( priority_reg__en ),
    .in_( priority_reg__in_ ),
    .out( priority_reg__out ),
    .reset( priority_reg__reset )
  );

  //-------------------------------------------------------------
  // End of component priority_reg
  //-------------------------------------------------------------

  // PyMTL Update Block Source
  // At /cgra/venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/arbiters.py:118
  // @update
  // def comb_grants():
  //   for i in range( nreqs ):
  //     s.grants[i] @= s.grants_int[i] | s.grants_int[nreqs+i]
  
  always_comb begin : comb_grants
    for ( int unsigned i = 1'd0; i < 2'( __const__nreqs_at_comb_grants ); i += 1'd1 )
      grants[2'(i)] = grants_int[3'(i)] | grants_int[3'( __const__nreqs_at_comb_grants ) + 3'(i)];
  end

  // PyMTL Update Block Source
  // At /cgra/venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/arbiters.py:141
  // @update
  // def comb_grants_int():
  //   for i in range( nreqsX2 ):
  //     if s.priority_int[i]:
  //       s.grants_int[i] @= s.reqs_int[i]
  //     else:
  //       s.grants_int[i] @= ~s.kills[i] & s.reqs_int[i]
  
  always_comb begin : comb_grants_int
    for ( int unsigned i = 1'd0; i < 3'( __const__nreqsX2_at_comb_grants_int ); i += 1'd1 )
      if ( priority_int[3'(i)] ) begin
        grants_int[3'(i)] = reqs_int[3'(i)];
      end
      else
        grants_int[3'(i)] = ( ~kills[3'(i)] ) & reqs_int[3'(i)];
  end

  // PyMTL Update Block Source
  // At /cgra/venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/arbiters.py:132
  // @update
  // def comb_kills():
  //   s.kills[0] @= 1
  //   for i in range( nreqsX2 ):
  //     if s.priority_int[i]:
  //       s.kills[i+1] @= s.reqs_int[i]
  //     else:
  //       s.kills[i+1] @= s.kills[i] | ( ~s.kills[i] & s.reqs_int[i] )
  
  always_comb begin : comb_kills
    kills[3'd0] = 1'd1;
    for ( int unsigned i = 1'd0; i < 3'( __const__nreqsX2_at_comb_kills ); i += 1'd1 )
      if ( priority_int[3'(i)] ) begin
        kills[3'(i) + 3'd1] = reqs_int[3'(i)];
      end
      else
        kills[3'(i) + 3'd1] = kills[3'(i)] | ( ( ~kills[3'(i)] ) & reqs_int[3'(i)] );
  end

  // PyMTL Update Block Source
  // At /cgra/venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/arbiters.py:123
  // @update
  // def comb_priority_en():
  //   s.priority_en @= ( s.grants != 0 ) & s.en
  
  always_comb begin : comb_priority_en
    priority_en = ( grants != 3'd0 ) & en;
  end

  // PyMTL Update Block Source
  // At /cgra/venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/arbiters.py:127
  // @update
  // def comb_priority_int():
  //   s.priority_int[    0:nreqs  ] @= s.priority_reg.out
  //   s.priority_int[nreqs:nreqsX2] @= 0
  
  always_comb begin : comb_priority_int
    priority_int[3'd2:3'd0] = priority_reg__out;
    priority_int[3'd5:3'( __const__nreqs_at_comb_priority_int )] = 3'd0;
  end

  // PyMTL Update Block Source
  // At /cgra/venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/arbiters.py:113
  // @update
  // def comb_reqs_int():
  //   s.reqs_int [    0:nreqs  ] @= s.reqs
  //   s.reqs_int [nreqs:nreqsX2] @= s.reqs
  
  always_comb begin : comb_reqs_int
    reqs_int[3'd2:3'd0] = reqs;
    reqs_int[3'd5:3'( __const__nreqs_at_comb_reqs_int )] = reqs;
  end

  assign priority_reg__clk = clk;
  assign priority_reg__reset = reset;
  assign priority_reg__en = priority_en;
  assign priority_reg__in_[2:1] = grants[1:0];
  assign priority_reg__in_[0:0] = grants[2:2];

endmodule


// PyMTL Component Encoder Definition
// At /cgra/venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/encoders.py

module Encoder__in_nbits_3__out_nbits_2
(
  input  logic [0:0] clk ,
  input  logic [2:0] in_ ,
  output logic [1:0] out ,
  input  logic [0:0] reset 
);

  // PyMTL Update Block Source
  // At /cgra/venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/encoders.py:28
  // @update
  // def encode():
  //   s.out @= 0
  //   for i in range( s.in_nbits ):
  //     if s.in_[i]:
  //       s.out @= i
  
  always_comb begin : encode
    out = 2'd0;
    for ( int unsigned i = 1'd0; i < 2'd3; i += 1'd1 )
      if ( in_[2'(i)] ) begin
        out = 2'(i);
      end
  end

endmodule


// PyMTL Component Mux Definition
// At /cgra/venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/arithmetics.py

module Mux__Type_MemAccessPacket_3_4_512__e6eb6c33f0815ad1__ninputs_3
(
  input  logic [0:0] clk ,
  input  MemAccessPacket_3_4_512__e6eb6c33f0815ad1 in_ [0:2],
  output MemAccessPacket_3_4_512__e6eb6c33f0815ad1 out ,
  input  logic [0:0] reset ,
  input  logic [1:0] sel 
);

  // PyMTL Update Block Source
  // At /cgra/venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/arithmetics.py:13
  // @update
  // def up_mux():
  //   s.out @= s.in_[ s.sel ]
  
  always_comb begin : up_mux
    out = in_[sel];
  end

endmodule


// PyMTL Component SwitchUnitRTL Definition
// Full name: SwitchUnitRTL__PacketType_MemAccessPacket_3_4_512__e6eb6c33f0815ad1__num_inports_3
// At /cgra/VectorCGRA/noc/PyOCN/pymtl3_net/router/SwitchUnitRTL.py

module SwitchUnitRTL__f3b6b7c5ce4ba502
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input MemAccessPacket_3_4_512__e6eb6c33f0815ad1 recv__msg [0:2] ,
  output logic [0:0] recv__rdy [0:2] ,
  input logic [0:0] recv__val [0:2] ,
  output MemAccessPacket_3_4_512__e6eb6c33f0815ad1 send__msg  ,
  input logic [0:0] send__rdy  ,
  output logic [0:0] send__val  
);
  localparam logic [1:0] __const__num_inports_at_up_get_en  = 2'd3;
  //-------------------------------------------------------------
  // Component arbiter
  //-------------------------------------------------------------

  logic [0:0] arbiter__clk;
  logic [0:0] arbiter__en;
  logic [2:0] arbiter__grants;
  logic [2:0] arbiter__reqs;
  logic [0:0] arbiter__reset;

  RoundRobinArbiterEn__nreqs_3 arbiter
  (
    .clk( arbiter__clk ),
    .en( arbiter__en ),
    .grants( arbiter__grants ),
    .reqs( arbiter__reqs ),
    .reset( arbiter__reset )
  );

  //-------------------------------------------------------------
  // End of component arbiter
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component encoder
  //-------------------------------------------------------------

  logic [0:0] encoder__clk;
  logic [2:0] encoder__in_;
  logic [1:0] encoder__out;
  logic [0:0] encoder__reset;

  Encoder__in_nbits_3__out_nbits_2 encoder
  (
    .clk( encoder__clk ),
    .in_( encoder__in_ ),
    .out( encoder__out ),
    .reset( encoder__reset )
  );

  //-------------------------------------------------------------
  // End of component encoder
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component mux
  //-------------------------------------------------------------

  logic [0:0] mux__clk;
  MemAccessPacket_3_4_512__e6eb6c33f0815ad1 mux__in_ [0:2];
  MemAccessPacket_3_4_512__e6eb6c33f0815ad1 mux__out;
  logic [0:0] mux__reset;
  logic [1:0] mux__sel;

  Mux__Type_MemAccessPacket_3_4_512__e6eb6c33f0815ad1__ninputs_3 mux
  (
    .clk( mux__clk ),
    .in_( mux__in_ ),
    .out( mux__out ),
    .reset( mux__reset ),
    .sel( mux__sel )
  );

  //-------------------------------------------------------------
  // End of component mux
  //-------------------------------------------------------------

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/noc/PyOCN/pymtl3_net/router/SwitchUnitRTL.py:56
  // @update
  // def up_get_en():
  //   for i in range( num_inports ):
  //     s.recv[i].rdy @= s.send.rdy & ( s.mux.sel == i )
  
  always_comb begin : up_get_en
    for ( int unsigned i = 1'd0; i < 2'( __const__num_inports_at_up_get_en ); i += 1'd1 )
      recv__rdy[2'(i)] = send__rdy & ( mux__sel == 2'(i) );
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/noc/PyOCN/pymtl3_net/router/SwitchUnitRTL.py:51
  // @update
  // def up_send_val():
  //   s.send.val @= s.arbiter.grants > 0
  
  always_comb begin : up_send_val
    send__val = arbiter__grants > 3'd0;
  end

  assign arbiter__clk = clk;
  assign arbiter__reset = reset;
  assign arbiter__en = 1'd1;
  assign mux__clk = clk;
  assign mux__reset = reset;
  assign send__msg = mux__out;
  assign encoder__clk = clk;
  assign encoder__reset = reset;
  assign encoder__in_ = arbiter__grants;
  assign mux__sel = encoder__out;
  assign arbiter__reqs[0:0] = recv__val[0];
  assign mux__in_[0] = recv__msg[0];
  assign arbiter__reqs[1:1] = recv__val[1];
  assign mux__in_[1] = recv__msg[1];
  assign arbiter__reqs[2:2] = recv__val[2];
  assign mux__in_[2] = recv__msg[2];

endmodule


// PyMTL Component XbarBypassQueueRTL Definition
// Full name: XbarBypassQueueRTL__PacketType_MemAccessPacket_3_4_512__e6eb6c33f0815ad1__num_inports_3__num_outports_4__InputUnitType_InputUnitRTL__RouteUnitType_XbarRouteUnitRTL__SwitchUnitType_SwitchUnitRTL__OutputUnitType_OutputUnitRTL
// At /cgra/VectorCGRA/noc/PyOCN/pymtl3_net/xbar/XbarBypassQueueRTL.py

module XbarBypassQueueRTL__e81c12edcedd00a7
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input MemAccessPacket_3_4_512__e6eb6c33f0815ad1 recv__msg [0:2] ,
  output logic [0:0] recv__rdy [0:2] ,
  input logic [0:0] recv__val [0:2] ,
  output MemAccessPacket_3_4_512__e6eb6c33f0815ad1 send__msg [0:3] ,
  input logic [0:0] send__rdy [0:3] ,
  output logic [0:0] send__val [0:3] 
);
  //-------------------------------------------------------------
  // Component input_units[0:2]
  //-------------------------------------------------------------

  logic [0:0] input_units__clk [0:2];
  logic [0:0] input_units__reset [0:2];
  MemAccessPacket_3_4_512__e6eb6c33f0815ad1 input_units__recv__msg [0:2];
  logic [0:0] input_units__recv__rdy [0:2];
  logic [0:0] input_units__recv__val [0:2];
  MemAccessPacket_3_4_512__e6eb6c33f0815ad1 input_units__send__msg [0:2];
  logic [0:0] input_units__send__rdy [0:2];
  logic [0:0] input_units__send__val [0:2];

  InputUnitRTL__1fd757aed6c42e02 input_units__0
  (
    .clk( input_units__clk[0] ),
    .reset( input_units__reset[0] ),
    .recv__msg( input_units__recv__msg[0] ),
    .recv__rdy( input_units__recv__rdy[0] ),
    .recv__val( input_units__recv__val[0] ),
    .send__msg( input_units__send__msg[0] ),
    .send__rdy( input_units__send__rdy[0] ),
    .send__val( input_units__send__val[0] )
  );

  InputUnitRTL__1fd757aed6c42e02 input_units__1
  (
    .clk( input_units__clk[1] ),
    .reset( input_units__reset[1] ),
    .recv__msg( input_units__recv__msg[1] ),
    .recv__rdy( input_units__recv__rdy[1] ),
    .recv__val( input_units__recv__val[1] ),
    .send__msg( input_units__send__msg[1] ),
    .send__rdy( input_units__send__rdy[1] ),
    .send__val( input_units__send__val[1] )
  );

  InputUnitRTL__1fd757aed6c42e02 input_units__2
  (
    .clk( input_units__clk[2] ),
    .reset( input_units__reset[2] ),
    .recv__msg( input_units__recv__msg[2] ),
    .recv__rdy( input_units__recv__rdy[2] ),
    .recv__val( input_units__recv__val[2] ),
    .send__msg( input_units__send__msg[2] ),
    .send__rdy( input_units__send__rdy[2] ),
    .send__val( input_units__send__val[2] )
  );

  //-------------------------------------------------------------
  // End of component input_units[0:2]
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component output_units[0:3]
  //-------------------------------------------------------------

  logic [0:0] output_units__clk [0:3];
  logic [0:0] output_units__reset [0:3];
  MemAccessPacket_3_4_512__e6eb6c33f0815ad1 output_units__recv__msg [0:3];
  logic [0:0] output_units__recv__rdy [0:3];
  logic [0:0] output_units__recv__val [0:3];
  MemAccessPacket_3_4_512__e6eb6c33f0815ad1 output_units__send__msg [0:3];
  logic [0:0] output_units__send__rdy [0:3];
  logic [0:0] output_units__send__val [0:3];

  OutputUnitRTL__091ab0079fe2318d output_units__0
  (
    .clk( output_units__clk[0] ),
    .reset( output_units__reset[0] ),
    .recv__msg( output_units__recv__msg[0] ),
    .recv__rdy( output_units__recv__rdy[0] ),
    .recv__val( output_units__recv__val[0] ),
    .send__msg( output_units__send__msg[0] ),
    .send__rdy( output_units__send__rdy[0] ),
    .send__val( output_units__send__val[0] )
  );

  OutputUnitRTL__091ab0079fe2318d output_units__1
  (
    .clk( output_units__clk[1] ),
    .reset( output_units__reset[1] ),
    .recv__msg( output_units__recv__msg[1] ),
    .recv__rdy( output_units__recv__rdy[1] ),
    .recv__val( output_units__recv__val[1] ),
    .send__msg( output_units__send__msg[1] ),
    .send__rdy( output_units__send__rdy[1] ),
    .send__val( output_units__send__val[1] )
  );

  OutputUnitRTL__091ab0079fe2318d output_units__2
  (
    .clk( output_units__clk[2] ),
    .reset( output_units__reset[2] ),
    .recv__msg( output_units__recv__msg[2] ),
    .recv__rdy( output_units__recv__rdy[2] ),
    .recv__val( output_units__recv__val[2] ),
    .send__msg( output_units__send__msg[2] ),
    .send__rdy( output_units__send__rdy[2] ),
    .send__val( output_units__send__val[2] )
  );

  OutputUnitRTL__091ab0079fe2318d output_units__3
  (
    .clk( output_units__clk[3] ),
    .reset( output_units__reset[3] ),
    .recv__msg( output_units__recv__msg[3] ),
    .recv__rdy( output_units__recv__rdy[3] ),
    .recv__val( output_units__recv__val[3] ),
    .send__msg( output_units__send__msg[3] ),
    .send__rdy( output_units__send__rdy[3] ),
    .send__val( output_units__send__val[3] )
  );

  //-------------------------------------------------------------
  // End of component output_units[0:3]
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component route_units[0:2]
  //-------------------------------------------------------------

  logic [0:0] route_units__clk [0:2];
  logic [0:0] route_units__reset [0:2];
  MemAccessPacket_3_4_512__e6eb6c33f0815ad1 route_units__recv__msg [0:2];
  logic [0:0] route_units__recv__rdy [0:2];
  logic [0:0] route_units__recv__val [0:2];
  MemAccessPacket_3_4_512__e6eb6c33f0815ad1 route_units__send__msg [0:2][0:3];
  logic [0:0] route_units__send__rdy [0:2][0:3];
  logic [0:0] route_units__send__val [0:2][0:3];

  XbarRouteUnitRTL__ae7f3e4fa13406f7 route_units__0
  (
    .clk( route_units__clk[0] ),
    .reset( route_units__reset[0] ),
    .recv__msg( route_units__recv__msg[0] ),
    .recv__rdy( route_units__recv__rdy[0] ),
    .recv__val( route_units__recv__val[0] ),
    .send__msg( route_units__send__msg[0] ),
    .send__rdy( route_units__send__rdy[0] ),
    .send__val( route_units__send__val[0] )
  );

  XbarRouteUnitRTL__ae7f3e4fa13406f7 route_units__1
  (
    .clk( route_units__clk[1] ),
    .reset( route_units__reset[1] ),
    .recv__msg( route_units__recv__msg[1] ),
    .recv__rdy( route_units__recv__rdy[1] ),
    .recv__val( route_units__recv__val[1] ),
    .send__msg( route_units__send__msg[1] ),
    .send__rdy( route_units__send__rdy[1] ),
    .send__val( route_units__send__val[1] )
  );

  XbarRouteUnitRTL__ae7f3e4fa13406f7 route_units__2
  (
    .clk( route_units__clk[2] ),
    .reset( route_units__reset[2] ),
    .recv__msg( route_units__recv__msg[2] ),
    .recv__rdy( route_units__recv__rdy[2] ),
    .recv__val( route_units__recv__val[2] ),
    .send__msg( route_units__send__msg[2] ),
    .send__rdy( route_units__send__rdy[2] ),
    .send__val( route_units__send__val[2] )
  );

  //-------------------------------------------------------------
  // End of component route_units[0:2]
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component switch_units[0:3]
  //-------------------------------------------------------------

  logic [0:0] switch_units__clk [0:3];
  logic [0:0] switch_units__reset [0:3];
  MemAccessPacket_3_4_512__e6eb6c33f0815ad1 switch_units__recv__msg [0:3][0:2];
  logic [0:0] switch_units__recv__rdy [0:3][0:2];
  logic [0:0] switch_units__recv__val [0:3][0:2];
  MemAccessPacket_3_4_512__e6eb6c33f0815ad1 switch_units__send__msg [0:3];
  logic [0:0] switch_units__send__rdy [0:3];
  logic [0:0] switch_units__send__val [0:3];

  SwitchUnitRTL__f3b6b7c5ce4ba502 switch_units__0
  (
    .clk( switch_units__clk[0] ),
    .reset( switch_units__reset[0] ),
    .recv__msg( switch_units__recv__msg[0] ),
    .recv__rdy( switch_units__recv__rdy[0] ),
    .recv__val( switch_units__recv__val[0] ),
    .send__msg( switch_units__send__msg[0] ),
    .send__rdy( switch_units__send__rdy[0] ),
    .send__val( switch_units__send__val[0] )
  );

  SwitchUnitRTL__f3b6b7c5ce4ba502 switch_units__1
  (
    .clk( switch_units__clk[1] ),
    .reset( switch_units__reset[1] ),
    .recv__msg( switch_units__recv__msg[1] ),
    .recv__rdy( switch_units__recv__rdy[1] ),
    .recv__val( switch_units__recv__val[1] ),
    .send__msg( switch_units__send__msg[1] ),
    .send__rdy( switch_units__send__rdy[1] ),
    .send__val( switch_units__send__val[1] )
  );

  SwitchUnitRTL__f3b6b7c5ce4ba502 switch_units__2
  (
    .clk( switch_units__clk[2] ),
    .reset( switch_units__reset[2] ),
    .recv__msg( switch_units__recv__msg[2] ),
    .recv__rdy( switch_units__recv__rdy[2] ),
    .recv__val( switch_units__recv__val[2] ),
    .send__msg( switch_units__send__msg[2] ),
    .send__rdy( switch_units__send__rdy[2] ),
    .send__val( switch_units__send__val[2] )
  );

  SwitchUnitRTL__f3b6b7c5ce4ba502 switch_units__3
  (
    .clk( switch_units__clk[3] ),
    .reset( switch_units__reset[3] ),
    .recv__msg( switch_units__recv__msg[3] ),
    .recv__rdy( switch_units__recv__rdy[3] ),
    .recv__val( switch_units__recv__val[3] ),
    .send__msg( switch_units__send__msg[3] ),
    .send__rdy( switch_units__send__rdy[3] ),
    .send__val( switch_units__send__val[3] )
  );

  //-------------------------------------------------------------
  // End of component switch_units[0:3]
  //-------------------------------------------------------------

  assign input_units__clk[0] = clk;
  assign input_units__reset[0] = reset;
  assign input_units__clk[1] = clk;
  assign input_units__reset[1] = reset;
  assign input_units__clk[2] = clk;
  assign input_units__reset[2] = reset;
  assign route_units__clk[0] = clk;
  assign route_units__reset[0] = reset;
  assign route_units__clk[1] = clk;
  assign route_units__reset[1] = reset;
  assign route_units__clk[2] = clk;
  assign route_units__reset[2] = reset;
  assign switch_units__clk[0] = clk;
  assign switch_units__reset[0] = reset;
  assign switch_units__clk[1] = clk;
  assign switch_units__reset[1] = reset;
  assign switch_units__clk[2] = clk;
  assign switch_units__reset[2] = reset;
  assign switch_units__clk[3] = clk;
  assign switch_units__reset[3] = reset;
  assign output_units__clk[0] = clk;
  assign output_units__reset[0] = reset;
  assign output_units__clk[1] = clk;
  assign output_units__reset[1] = reset;
  assign output_units__clk[2] = clk;
  assign output_units__reset[2] = reset;
  assign output_units__clk[3] = clk;
  assign output_units__reset[3] = reset;
  assign input_units__recv__msg[0] = recv__msg[0];
  assign recv__rdy[0] = input_units__recv__rdy[0];
  assign input_units__recv__val[0] = recv__val[0];
  assign route_units__recv__msg[0] = input_units__send__msg[0];
  assign input_units__send__rdy[0] = route_units__recv__rdy[0];
  assign route_units__recv__val[0] = input_units__send__val[0];
  assign input_units__recv__msg[1] = recv__msg[1];
  assign recv__rdy[1] = input_units__recv__rdy[1];
  assign input_units__recv__val[1] = recv__val[1];
  assign route_units__recv__msg[1] = input_units__send__msg[1];
  assign input_units__send__rdy[1] = route_units__recv__rdy[1];
  assign route_units__recv__val[1] = input_units__send__val[1];
  assign input_units__recv__msg[2] = recv__msg[2];
  assign recv__rdy[2] = input_units__recv__rdy[2];
  assign input_units__recv__val[2] = recv__val[2];
  assign route_units__recv__msg[2] = input_units__send__msg[2];
  assign input_units__send__rdy[2] = route_units__recv__rdy[2];
  assign route_units__recv__val[2] = input_units__send__val[2];
  assign switch_units__recv__msg[0][0] = route_units__send__msg[0][0];
  assign route_units__send__rdy[0][0] = switch_units__recv__rdy[0][0];
  assign switch_units__recv__val[0][0] = route_units__send__val[0][0];
  assign switch_units__recv__msg[1][0] = route_units__send__msg[0][1];
  assign route_units__send__rdy[0][1] = switch_units__recv__rdy[1][0];
  assign switch_units__recv__val[1][0] = route_units__send__val[0][1];
  assign switch_units__recv__msg[2][0] = route_units__send__msg[0][2];
  assign route_units__send__rdy[0][2] = switch_units__recv__rdy[2][0];
  assign switch_units__recv__val[2][0] = route_units__send__val[0][2];
  assign switch_units__recv__msg[3][0] = route_units__send__msg[0][3];
  assign route_units__send__rdy[0][3] = switch_units__recv__rdy[3][0];
  assign switch_units__recv__val[3][0] = route_units__send__val[0][3];
  assign switch_units__recv__msg[0][1] = route_units__send__msg[1][0];
  assign route_units__send__rdy[1][0] = switch_units__recv__rdy[0][1];
  assign switch_units__recv__val[0][1] = route_units__send__val[1][0];
  assign switch_units__recv__msg[1][1] = route_units__send__msg[1][1];
  assign route_units__send__rdy[1][1] = switch_units__recv__rdy[1][1];
  assign switch_units__recv__val[1][1] = route_units__send__val[1][1];
  assign switch_units__recv__msg[2][1] = route_units__send__msg[1][2];
  assign route_units__send__rdy[1][2] = switch_units__recv__rdy[2][1];
  assign switch_units__recv__val[2][1] = route_units__send__val[1][2];
  assign switch_units__recv__msg[3][1] = route_units__send__msg[1][3];
  assign route_units__send__rdy[1][3] = switch_units__recv__rdy[3][1];
  assign switch_units__recv__val[3][1] = route_units__send__val[1][3];
  assign switch_units__recv__msg[0][2] = route_units__send__msg[2][0];
  assign route_units__send__rdy[2][0] = switch_units__recv__rdy[0][2];
  assign switch_units__recv__val[0][2] = route_units__send__val[2][0];
  assign switch_units__recv__msg[1][2] = route_units__send__msg[2][1];
  assign route_units__send__rdy[2][1] = switch_units__recv__rdy[1][2];
  assign switch_units__recv__val[1][2] = route_units__send__val[2][1];
  assign switch_units__recv__msg[2][2] = route_units__send__msg[2][2];
  assign route_units__send__rdy[2][2] = switch_units__recv__rdy[2][2];
  assign switch_units__recv__val[2][2] = route_units__send__val[2][2];
  assign switch_units__recv__msg[3][2] = route_units__send__msg[2][3];
  assign route_units__send__rdy[2][3] = switch_units__recv__rdy[3][2];
  assign switch_units__recv__val[3][2] = route_units__send__val[2][3];
  assign output_units__recv__msg[0] = switch_units__send__msg[0];
  assign switch_units__send__rdy[0] = output_units__recv__rdy[0];
  assign output_units__recv__val[0] = switch_units__send__val[0];
  assign send__msg[0] = output_units__send__msg[0];
  assign output_units__send__rdy[0] = send__rdy[0];
  assign send__val[0] = output_units__send__val[0];
  assign output_units__recv__msg[1] = switch_units__send__msg[1];
  assign switch_units__send__rdy[1] = output_units__recv__rdy[1];
  assign output_units__recv__val[1] = switch_units__send__val[1];
  assign send__msg[1] = output_units__send__msg[1];
  assign output_units__send__rdy[1] = send__rdy[1];
  assign send__val[1] = output_units__send__val[1];
  assign output_units__recv__msg[2] = switch_units__send__msg[2];
  assign switch_units__send__rdy[2] = output_units__recv__rdy[2];
  assign output_units__recv__val[2] = switch_units__send__val[2];
  assign send__msg[2] = output_units__send__msg[2];
  assign output_units__send__rdy[2] = send__rdy[2];
  assign send__val[2] = output_units__send__val[2];
  assign output_units__recv__msg[3] = switch_units__send__msg[3];
  assign switch_units__send__rdy[3] = output_units__recv__rdy[3];
  assign output_units__recv__val[3] = switch_units__send__val[3];
  assign send__msg[3] = output_units__send__msg[3];
  assign output_units__send__rdy[3] = send__rdy[3];
  assign send__val[3] = output_units__send__val[3];

endmodule


// PyMTL Component DataMemControllerRTL Definition
// Full name: DataMemControllerRTL__NocPktType_InterCgraPacket_4_4x1_4_8_4_CgraPayload__9d404f857a1e94ff__data_mem_size_global_512__data_mem_size_per_bank_32__num_banks_per_cgra_2__num_rd_tiles_3__num_wr_tiles_3__multi_cgra_rows_1__multi_cgra_columns_4__num_tiles_4__mem_access_is_combinational_False__idTo2d_map_{0: [0, 0], 1: [1, 0], 2: [2, 0], 3: [3, 0]}
// At /cgra/VectorCGRA/mem/data/DataMemControllerRTL.py

module DataMemControllerRTL__ff601aaa934406d0
(
  input  logic [8:0] address_lower ,
  input  logic [8:0] address_upper ,
  input  logic [1:0] cgra_id ,
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input InterCgraPacket_4_4x1_4_8_4_CgraPayload__9d404f857a1e94ff recv_from_noc_load_request__msg  ,
  output logic [0:0] recv_from_noc_load_request__rdy  ,
  input logic [0:0] recv_from_noc_load_request__val  ,
  input InterCgraPacket_4_4x1_4_8_4_CgraPayload__9d404f857a1e94ff recv_from_noc_load_response_pkt__msg  ,
  output logic [0:0] recv_from_noc_load_response_pkt__rdy  ,
  input logic [0:0] recv_from_noc_load_response_pkt__val  ,
  input InterCgraPacket_4_4x1_4_8_4_CgraPayload__9d404f857a1e94ff recv_from_noc_store_request__msg  ,
  output logic [0:0] recv_from_noc_store_request__rdy  ,
  input logic [0:0] recv_from_noc_store_request__val  ,
  input logic [8:0] recv_raddr__msg [0:2] ,
  output logic [0:0] recv_raddr__rdy [0:2] ,
  input logic [0:0] recv_raddr__val [0:2] ,
  input logic [8:0] recv_waddr__msg [0:2] ,
  output logic [0:0] recv_waddr__rdy [0:2] ,
  input logic [0:0] recv_waddr__val [0:2] ,
  input CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 recv_wdata__msg [0:2] ,
  output logic [0:0] recv_wdata__rdy [0:2] ,
  input logic [0:0] recv_wdata__val [0:2] ,
  output CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 send_rdata__msg [0:2] ,
  input logic [0:0] send_rdata__rdy [0:2] ,
  output logic [0:0] send_rdata__val [0:2] ,
  output InterCgraPacket_4_4x1_4_8_4_CgraPayload__9d404f857a1e94ff send_to_noc_load_request_pkt__msg  ,
  input logic [0:0] send_to_noc_load_request_pkt__rdy  ,
  output logic [0:0] send_to_noc_load_request_pkt__val  ,
  output InterCgraPacket_4_4x1_4_8_4_CgraPayload__9d404f857a1e94ff send_to_noc_load_response_pkt__msg  ,
  input logic [0:0] send_to_noc_load_response_pkt__rdy  ,
  output logic [0:0] send_to_noc_load_response_pkt__val  ,
  output InterCgraPacket_4_4x1_4_8_4_CgraPayload__9d404f857a1e94ff send_to_noc_store_pkt__msg  ,
  input logic [0:0] send_to_noc_store_pkt__rdy  ,
  output logic [0:0] send_to_noc_store_pkt__val  
);
  localparam logic [2:0] __const__num_xbar_in_rd_ports_at_assemble_xbar_pkt  = 3'd4;
  localparam logic [2:0] __const__num_xbar_in_wr_ports_at_assemble_xbar_pkt  = 3'd4;
  localparam logic [1:0] __const__num_rd_tiles_at_assemble_xbar_pkt  = 2'd3;
  localparam logic [2:0] __const__per_bank_addr_nbits_at_assemble_xbar_pkt  = 3'd5;
  localparam logic [1:0] __const__num_banks_per_cgra_at_assemble_xbar_pkt  = 2'd2;
  localparam logic [1:0] __const__num_wr_tiles_at_assemble_xbar_pkt  = 2'd3;
  localparam logic [1:0] __const__num_rd_tiles_at_update_all  = 2'd3;
  localparam logic [1:0] __const__num_wr_tiles_at_update_all  = 2'd3;
  localparam logic [2:0] __const__num_xbar_in_rd_ports_at_update_all  = 3'd4;
  localparam logic [2:0] __const__num_xbar_in_wr_ports_at_update_all  = 3'd4;
  localparam logic [3:0] __const__CMD_LOAD_RESPONSE  = 4'd11;
  localparam logic [1:0] __const__num_banks_per_cgra_at_update_all  = 2'd2;
  localparam logic [3:0] __const__CMD_LOAD_REQUEST  = 4'd10;
  localparam logic [3:0] __const__CMD_STORE_REQUEST  = 4'd12;
  logic [1:0] idTo2d_x_lut [0:3];
  logic [0:0] idTo2d_y_lut [0:3];
  MemAccessPacket_4_3_512__e6eb6c33f0815ad1 rd_pkt [0:3];
  MemAccessPacket_4_3_512__e6eb6c33f0815ad1 wr_pkt [0:3];
  //-------------------------------------------------------------
  // Component memory_wrapper[0:1]
  //-------------------------------------------------------------

  logic [0:0] memory_wrapper__clk [0:1];
  logic [0:0] memory_wrapper__reset [0:1];
  MemAccessPacket_4_3_512__e6eb6c33f0815ad1 memory_wrapper__recv_rd__msg [0:1];
  logic [0:0] memory_wrapper__recv_rd__rdy [0:1];
  logic [0:0] memory_wrapper__recv_rd__val [0:1];
  MemAccessPacket_4_3_512__e6eb6c33f0815ad1 memory_wrapper__recv_wr__msg [0:1];
  logic [0:0] memory_wrapper__recv_wr__rdy [0:1];
  logic [0:0] memory_wrapper__recv_wr__val [0:1];
  MemAccessPacket_3_4_512__e6eb6c33f0815ad1 memory_wrapper__send__msg [0:1];
  logic [0:0] memory_wrapper__send__rdy [0:1];
  logic [0:0] memory_wrapper__send__val [0:1];

  DataMemWrapperRTL__32d61ad0410ab3a5 memory_wrapper__0
  (
    .clk( memory_wrapper__clk[0] ),
    .reset( memory_wrapper__reset[0] ),
    .recv_rd__msg( memory_wrapper__recv_rd__msg[0] ),
    .recv_rd__rdy( memory_wrapper__recv_rd__rdy[0] ),
    .recv_rd__val( memory_wrapper__recv_rd__val[0] ),
    .recv_wr__msg( memory_wrapper__recv_wr__msg[0] ),
    .recv_wr__rdy( memory_wrapper__recv_wr__rdy[0] ),
    .recv_wr__val( memory_wrapper__recv_wr__val[0] ),
    .send__msg( memory_wrapper__send__msg[0] ),
    .send__rdy( memory_wrapper__send__rdy[0] ),
    .send__val( memory_wrapper__send__val[0] )
  );

  DataMemWrapperRTL__32d61ad0410ab3a5 memory_wrapper__1
  (
    .clk( memory_wrapper__clk[1] ),
    .reset( memory_wrapper__reset[1] ),
    .recv_rd__msg( memory_wrapper__recv_rd__msg[1] ),
    .recv_rd__rdy( memory_wrapper__recv_rd__rdy[1] ),
    .recv_rd__val( memory_wrapper__recv_rd__val[1] ),
    .recv_wr__msg( memory_wrapper__recv_wr__msg[1] ),
    .recv_wr__rdy( memory_wrapper__recv_wr__rdy[1] ),
    .recv_wr__val( memory_wrapper__recv_wr__val[1] ),
    .send__msg( memory_wrapper__send__msg[1] ),
    .send__rdy( memory_wrapper__send__rdy[1] ),
    .send__val( memory_wrapper__send__val[1] )
  );

  //-------------------------------------------------------------
  // End of component memory_wrapper[0:1]
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component read_crossbar
  //-------------------------------------------------------------

  logic [0:0] read_crossbar__clk;
  logic [0:0] read_crossbar__reset;
  MemAccessPacket_4_3_512__e6eb6c33f0815ad1 read_crossbar__recv__msg [0:3];
  logic [0:0] read_crossbar__recv__rdy [0:3];
  logic [0:0] read_crossbar__recv__val [0:3];
  MemAccessPacket_4_3_512__e6eb6c33f0815ad1 read_crossbar__send__msg [0:2];
  logic [0:0] read_crossbar__send__rdy [0:2];
  logic [0:0] read_crossbar__send__val [0:2];

  XbarBypassQueueRTL__5326d7b10201b6e9 read_crossbar
  (
    .clk( read_crossbar__clk ),
    .reset( read_crossbar__reset ),
    .recv__msg( read_crossbar__recv__msg ),
    .recv__rdy( read_crossbar__recv__rdy ),
    .recv__val( read_crossbar__recv__val ),
    .send__msg( read_crossbar__send__msg ),
    .send__rdy( read_crossbar__send__rdy ),
    .send__val( read_crossbar__send__val )
  );

  //-------------------------------------------------------------
  // End of component read_crossbar
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component response_crossbar
  //-------------------------------------------------------------

  logic [0:0] response_crossbar__clk;
  logic [0:0] response_crossbar__reset;
  MemAccessPacket_3_4_512__e6eb6c33f0815ad1 response_crossbar__recv__msg [0:2];
  logic [0:0] response_crossbar__recv__rdy [0:2];
  logic [0:0] response_crossbar__recv__val [0:2];
  MemAccessPacket_3_4_512__e6eb6c33f0815ad1 response_crossbar__send__msg [0:3];
  logic [0:0] response_crossbar__send__rdy [0:3];
  logic [0:0] response_crossbar__send__val [0:3];

  XbarBypassQueueRTL__e81c12edcedd00a7 response_crossbar
  (
    .clk( response_crossbar__clk ),
    .reset( response_crossbar__reset ),
    .recv__msg( response_crossbar__recv__msg ),
    .recv__rdy( response_crossbar__recv__rdy ),
    .recv__val( response_crossbar__recv__val ),
    .send__msg( response_crossbar__send__msg ),
    .send__rdy( response_crossbar__send__rdy ),
    .send__val( response_crossbar__send__val )
  );

  //-------------------------------------------------------------
  // End of component response_crossbar
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component write_crossbar
  //-------------------------------------------------------------

  logic [0:0] write_crossbar__clk;
  logic [0:0] write_crossbar__reset;
  MemAccessPacket_4_3_512__e6eb6c33f0815ad1 write_crossbar__recv__msg [0:3];
  logic [0:0] write_crossbar__recv__rdy [0:3];
  logic [0:0] write_crossbar__recv__val [0:3];
  MemAccessPacket_4_3_512__e6eb6c33f0815ad1 write_crossbar__send__msg [0:2];
  logic [0:0] write_crossbar__send__rdy [0:2];
  logic [0:0] write_crossbar__send__val [0:2];

  XbarBypassQueueRTL__5326d7b10201b6e9 write_crossbar
  (
    .clk( write_crossbar__clk ),
    .reset( write_crossbar__reset ),
    .recv__msg( write_crossbar__recv__msg ),
    .recv__rdy( write_crossbar__recv__rdy ),
    .recv__val( write_crossbar__recv__val ),
    .send__msg( write_crossbar__send__msg ),
    .send__rdy( write_crossbar__send__rdy ),
    .send__val( write_crossbar__send__val )
  );

  //-------------------------------------------------------------
  // End of component write_crossbar
  //-------------------------------------------------------------
  logic [8:0] __tmpvar__assemble_xbar_pkt_recv_raddr;
  logic [1:0] __tmpvar__assemble_xbar_pkt_bank_index_load_local;
  logic [8:0] __tmpvar__assemble_xbar_pkt_recv_raddr_from_noc;
  logic [1:0] __tmpvar__assemble_xbar_pkt_bank_index_load_from_noc;
  logic [8:0] __tmpvar__assemble_xbar_pkt_recv_waddr;
  logic [1:0] __tmpvar__assemble_xbar_pkt_bank_index_store_local;
  logic [8:0] __tmpvar__assemble_xbar_pkt_recv_waddr_from_noc;
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 __tmpvar__assemble_xbar_pkt_recv_wdata_from_noc;
  logic [1:0] __tmpvar__assemble_xbar_pkt_bank_index_store_from_noc;
  logic [1:0] __tmpvar__update_all_from_cgra_id;
  logic [2:0] __tmpvar__update_all_from_tile_id;

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/mem/data/DataMemControllerRTL.py:159
  // @update
  // def assemble_xbar_pkt():
  //   for i in range(num_xbar_in_rd_ports):
  //     s.rd_pkt[i] @= MemReadPktType(i, 0, 0, DataType(0, 0, 0, 0), 0, 0, i)
  // 
  //   for i in range(num_xbar_in_wr_ports):
  //     s.wr_pkt[i] @= MemWritePktType(i, 0, 0, DataType(0, 0, 0, 0), 0, 0, i)
  // 
  //   for i in range(num_rd_tiles):
  //     recv_raddr = s.recv_raddr[i].msg
  //     # Calculates the target bank index for load.
  //     if (recv_raddr >= s.address_lower) & (recv_raddr <= s.address_upper):
  //       bank_index_load_local = trunc((recv_raddr - s.address_lower) >> per_bank_addr_nbits, XbarOutRdType)
  //     else:
  //       bank_index_load_local = XbarOutRdType(num_banks_per_cgra)
  //     # FIXME: change to exact tile id.
  //     s.rd_pkt[i] @= MemReadPktType(i,                       # src
  //                                   bank_index_load_local,   # dst
  //                                   recv_raddr,              # addr
  //                                   DataType(0, 0, 0, 0),    # data
  //                                   s.cgra_id,               # src_cgra
  //                                   0,                       # src_tile
  //                                   i)                       # remote_src_port
  // 
  //   recv_raddr_from_noc = s.recv_from_noc_load_request.msg.payload.data_addr
  //   # Calculates the target bank index.
  //   if (recv_raddr_from_noc >= s.address_lower) & (recv_raddr_from_noc <= s.address_upper):
  //     bank_index_load_from_noc = trunc((recv_raddr_from_noc - s.address_lower) >> per_bank_addr_nbits, XbarOutRdType)
  //   else:
  //     bank_index_load_from_noc = XbarOutRdType(num_banks_per_cgra)
  //   s.rd_pkt[num_rd_tiles] @= MemReadPktType(num_rd_tiles,                                     # src
  //                                            bank_index_load_from_noc,                         # dst
  //                                            recv_raddr_from_noc,                              # addr
  //                                            DataType(0, 0, 0, 0),                             # data
  //                                            s.recv_from_noc_load_request.msg.src,             # src_cgra
  //                                            s.recv_from_noc_load_request.msg.src_tile_id,     # src_tile
  //                                            s.recv_from_noc_load_request.msg.remote_src_port) # remote_src_port   
  // 
  //   for i in range(num_wr_tiles):
  //     recv_waddr = s.recv_waddr[i].msg
  //     # Calculates the target bank index for store.
  //     if (recv_waddr >= s.address_lower) & (recv_waddr <= s.address_upper):
  //       bank_index_store_local = trunc((recv_waddr - s.address_lower) >> per_bank_addr_nbits, XbarOutWrType)
  //     else:
  //       bank_index_store_local = XbarOutWrType(num_banks_per_cgra)
  //     s.wr_pkt[i] @= MemWritePktType(i,                       # src
  //                                    bank_index_store_local,  # dst
  //                                    recv_waddr,              # addr
  //                                    s.recv_wdata[i].msg,     # data
  //                                    0,                       # src_cgra
  //                                    0,                       # src_tile
  //                                    i)                       # remote_src_port
  // 
  //   recv_waddr_from_noc = s.recv_from_noc_store_request.msg.payload.data_addr
  //   recv_wdata_from_noc = s.recv_from_noc_store_request.msg.payload.data
  //   if (recv_waddr_from_noc >= s.address_lower) & (recv_waddr_from_noc <= s.address_upper):
  //     bank_index_store_from_noc = trunc((recv_waddr_from_noc - s.address_lower) >> per_bank_addr_nbits, XbarOutWrType)
  //   else:
  //     bank_index_store_from_noc = XbarOutWrType(num_banks_per_cgra)
  //   s.wr_pkt[num_wr_tiles] @= MemWritePktType(num_wr_tiles,               # src
  //                                             bank_index_store_from_noc,  # dst
  //                                             recv_waddr_from_noc,        # addr
  //                                             recv_wdata_from_noc,        # data
  //                                             0,                          # src_cgra
  //                                             0,                          # src_tile
  //                                             num_wr_tiles)               # remote_src_port
  
  always_comb begin : assemble_xbar_pkt
    for ( int unsigned i = 1'd0; i < 3'( __const__num_xbar_in_rd_ports_at_assemble_xbar_pkt ); i += 1'd1 )
      rd_pkt[2'(i)] = { 2'(i), 2'd0, 9'd0, { 32'd0, 1'd0, 1'd0, 1'd0 }, 2'd0, 3'd0, 2'(i) };
    for ( int unsigned i = 1'd0; i < 3'( __const__num_xbar_in_wr_ports_at_assemble_xbar_pkt ); i += 1'd1 )
      wr_pkt[2'(i)] = { 2'(i), 2'd0, 9'd0, { 32'd0, 1'd0, 1'd0, 1'd0 }, 2'd0, 3'd0, 2'(i) };
    for ( int unsigned i = 1'd0; i < 2'( __const__num_rd_tiles_at_assemble_xbar_pkt ); i += 1'd1 ) begin
      __tmpvar__assemble_xbar_pkt_recv_raddr = recv_raddr__msg[2'(i)];
      if ( ( __tmpvar__assemble_xbar_pkt_recv_raddr >= address_lower ) & ( __tmpvar__assemble_xbar_pkt_recv_raddr <= address_upper ) ) begin
        __tmpvar__assemble_xbar_pkt_bank_index_load_local = 2'(( __tmpvar__assemble_xbar_pkt_recv_raddr - address_lower ) >> 3'( __const__per_bank_addr_nbits_at_assemble_xbar_pkt ));
      end
      else
        __tmpvar__assemble_xbar_pkt_bank_index_load_local = 2'd2;
      rd_pkt[2'(i)] = { 2'(i), __tmpvar__assemble_xbar_pkt_bank_index_load_local, __tmpvar__assemble_xbar_pkt_recv_raddr, { 32'd0, 1'd0, 1'd0, 1'd0 }, cgra_id, 3'd0, 2'(i) };
    end
    __tmpvar__assemble_xbar_pkt_recv_raddr_from_noc = recv_from_noc_load_request__msg.payload.data_addr;
    if ( ( __tmpvar__assemble_xbar_pkt_recv_raddr_from_noc >= address_lower ) & ( __tmpvar__assemble_xbar_pkt_recv_raddr_from_noc <= address_upper ) ) begin
      __tmpvar__assemble_xbar_pkt_bank_index_load_from_noc = 2'(( __tmpvar__assemble_xbar_pkt_recv_raddr_from_noc - address_lower ) >> 3'( __const__per_bank_addr_nbits_at_assemble_xbar_pkt ));
    end
    else
      __tmpvar__assemble_xbar_pkt_bank_index_load_from_noc = 2'd2;
    rd_pkt[2'( __const__num_rd_tiles_at_assemble_xbar_pkt )] = { 2'( __const__num_rd_tiles_at_assemble_xbar_pkt ), __tmpvar__assemble_xbar_pkt_bank_index_load_from_noc, __tmpvar__assemble_xbar_pkt_recv_raddr_from_noc, { 32'd0, 1'd0, 1'd0, 1'd0 }, recv_from_noc_load_request__msg.src, recv_from_noc_load_request__msg.src_tile_id, recv_from_noc_load_request__msg.remote_src_port };
    for ( int unsigned i = 1'd0; i < 2'( __const__num_wr_tiles_at_assemble_xbar_pkt ); i += 1'd1 ) begin
      __tmpvar__assemble_xbar_pkt_recv_waddr = recv_waddr__msg[2'(i)];
      if ( ( __tmpvar__assemble_xbar_pkt_recv_waddr >= address_lower ) & ( __tmpvar__assemble_xbar_pkt_recv_waddr <= address_upper ) ) begin
        __tmpvar__assemble_xbar_pkt_bank_index_store_local = 2'(( __tmpvar__assemble_xbar_pkt_recv_waddr - address_lower ) >> 3'( __const__per_bank_addr_nbits_at_assemble_xbar_pkt ));
      end
      else
        __tmpvar__assemble_xbar_pkt_bank_index_store_local = 2'd2;
      wr_pkt[2'(i)] = { 2'(i), __tmpvar__assemble_xbar_pkt_bank_index_store_local, __tmpvar__assemble_xbar_pkt_recv_waddr, recv_wdata__msg[2'(i)], 2'd0, 3'd0, 2'(i) };
    end
    __tmpvar__assemble_xbar_pkt_recv_waddr_from_noc = recv_from_noc_store_request__msg.payload.data_addr;
    __tmpvar__assemble_xbar_pkt_recv_wdata_from_noc = recv_from_noc_store_request__msg.payload.data;
    if ( ( __tmpvar__assemble_xbar_pkt_recv_waddr_from_noc >= address_lower ) & ( __tmpvar__assemble_xbar_pkt_recv_waddr_from_noc <= address_upper ) ) begin
      __tmpvar__assemble_xbar_pkt_bank_index_store_from_noc = 2'(( __tmpvar__assemble_xbar_pkt_recv_waddr_from_noc - address_lower ) >> 3'( __const__per_bank_addr_nbits_at_assemble_xbar_pkt ));
    end
    else
      __tmpvar__assemble_xbar_pkt_bank_index_store_from_noc = 2'd2;
    wr_pkt[2'( __const__num_wr_tiles_at_assemble_xbar_pkt )] = { 2'( __const__num_wr_tiles_at_assemble_xbar_pkt ), __tmpvar__assemble_xbar_pkt_bank_index_store_from_noc, __tmpvar__assemble_xbar_pkt_recv_waddr_from_noc, __tmpvar__assemble_xbar_pkt_recv_wdata_from_noc, 2'd0, 3'd0, 2'( __const__num_wr_tiles_at_assemble_xbar_pkt ) };
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/mem/data/DataMemControllerRTL.py:227
  // @update
  // def update_all():
  //   # Initializes the signals.
  //   for i in range(num_rd_tiles):
  //     s.recv_raddr[i].rdy @= 0
  //   s.recv_from_noc_load_request.rdy @= 0
  // 
  //   for i in range(num_wr_tiles):
  //     s.recv_waddr[i].rdy @= 0
  //     # s.recv_wdata_bypass_q[i].send.rdy @= 0
  //   s.recv_from_noc_store_request.rdy @= 0
  //   # s.recv_wdata_bypass_q[num_wr_tiles].send.rdy @= 0
  // 
  //   for i in range(num_rd_tiles):
  //     s.send_rdata[i].val @= 0
  //     s.send_rdata[i].msg @= DataType()
  //   s.send_to_noc_load_response_pkt.val @= 0
  // 
  //   s.send_to_noc_load_response_pkt.msg @= \
  //       NocPktType(0, # src
  //                  0, # dst
  //                  0, # src_x
  //                  0, # src_y
  //                  0, # dst_x
  //                  0, # dst_y
  //                  0, # src_tile_id
  //                  0, # dst_tile_id
  //                  0, # remote_src_port
  //                  0, # opaque
  //                  0, # vc_id
  //                  CgraPayloadType(0, 0, 0, 0, 0))
  // 
  // 
  //   for i in range(num_wr_tiles):
  //     s.recv_wdata[i].rdy @= 0
  // 
  //   s.send_to_noc_store_pkt.msg @= \
  //       NocPktType(0, # src
  //                  0, # dst
  //                  0, # src_x
  //                  0, # src_y
  //                  0, # dst_x
  //                  0, # dst_y
  //                  0, # src_tile_id
  //                  0, # dst_tile_id
  //                  0, # remote_src_port
  //                  0, # opaque
  //                  0, # vc_id
  //                  CgraPayloadType(0, 0, 0, 0, 0))
  // 
  //   s.send_to_noc_store_pkt.val @= 0
  // 
  //   for i in range(num_xbar_in_rd_ports):
  //     s.read_crossbar.recv[i].val @= 0
  //     s.read_crossbar.recv[i].msg @= MemReadPktType(0, 0, 0, DataType(0, 0, 0, 0), 0, 0, 0)
  // 
  //   s.recv_from_noc_load_response_pkt.rdy @= 0
  // 
  //   for i in range(num_xbar_in_wr_ports):
  //     s.write_crossbar.recv[i].val @= 0
  //     s.write_crossbar.recv[i].msg @= MemWritePktType(0, 0, 0, DataType(0, 0, 0, 0), 0, 0, 0)
  // 
  //   s.send_to_noc_load_request_pkt.msg @= \
  //       NocPktType(0, # src
  //                  0, # dst
  //                  0, # src_x
  //                  0, # src_y
  //                  0, # dst_x
  //                  0, # dst_y
  //                  0, # src_tile_id
  //                  0, # dst_tile_id
  //                  0, # remote_src_port
  //                  0, # opaque
  //                  0, # vc_id
  //                  CgraPayloadType(0, 0, 0, 0, 0))
  // 
  //   s.send_to_noc_load_request_pkt.val @= 0
  // 
  //   # Connects the load request ports (from tiles and NoC) to the xbar targetting memory and NoC.
  //   for i in range(num_rd_tiles):
  //       s.read_crossbar.recv[i].val @= s.recv_raddr[i].val
  //       s.read_crossbar.recv[i].msg @= s.rd_pkt[i]
  //       s.recv_raddr[i].rdy @= s.read_crossbar.recv[i].rdy
  //   s.read_crossbar.recv[num_rd_tiles].val @= s.recv_from_noc_load_request.val
  //   s.read_crossbar.recv[num_rd_tiles].msg @= s.rd_pkt[num_rd_tiles]
  //   s.recv_from_noc_load_request.rdy @= s.read_crossbar.recv[num_rd_tiles].rdy
  //   
  //   # Connects the store request ports (from tiles and NoC) to the xbar targetting memory and NoC.
  //   for i in range(num_wr_tiles):
  //     s.write_crossbar.recv[i].val @= s.recv_waddr[i].val
  //     s.write_crossbar.recv[i].msg @= s.wr_pkt[i]
  //     s.recv_waddr[i].rdy @= s.write_crossbar.recv[i].rdy
  //     s.recv_wdata[i].rdy @= s.write_crossbar.recv[i].rdy
  //   s.write_crossbar.recv[num_wr_tiles].val @= s.recv_from_noc_store_request.val
  //   s.write_crossbar.recv[num_wr_tiles].msg @= s.wr_pkt[num_wr_tiles]
  //   s.recv_from_noc_store_request.rdy @= s.write_crossbar.recv[num_wr_tiles].rdy
  // 
  //   # Connects the response ports to tiles and NoC from the xbar.
  //   # Number of load responses is expected to be the same as the number of load requests.
  //   for i in range(num_xbar_in_rd_ports):
  //     if i < num_rd_tiles:
  //       s.send_rdata[RdTileIdType(i)].msg @= s.response_crossbar.send[i].msg.data
  //       s.send_rdata[RdTileIdType(i)].val @= s.response_crossbar.send[i].val
  //       s.response_crossbar.send[i].rdy @= s.send_rdata[RdTileIdType(i)].rdy
  //     else:
  //       from_cgra_id = s.response_crossbar.send[i].msg.src_cgra
  //       from_tile_id = s.response_crossbar.send[i].msg.src_tile
  //       s.send_to_noc_load_response_pkt.msg @= \
  //             NocPktType(
  //                 s.cgra_id, # src_cgra_id
  //                 from_cgra_id, # dst_cgra_id
  //                 s.idTo2d_x_lut[s.cgra_id], # src_cgra_x
  //                 s.idTo2d_y_lut[s.cgra_id], # src_cgra_y
  //                 s.idTo2d_x_lut[from_cgra_id], # dst_cgra_x
  //                 s.idTo2d_y_lut[from_cgra_id], # dst_cgra_y
  //                 0, # src_tile_id set as 0 as it is from memory rather than a specific tile.
  //                 from_tile_id, # dst_tile_id
  //                 s.response_crossbar.send[i].msg.remote_src_port, # remote_src_port, carries the original source port id towards the src.
  //                 0, # opaque
  //                 0, # vc_id
  //                 CgraPayloadType(
  //                     CMD_LOAD_RESPONSE,
  //                     s.response_crossbar.send[i].msg.data,
  //                     s.response_crossbar.send[i].msg.addr, 0, 0))
  // 
  //       s.send_to_noc_load_response_pkt.val @= s.response_crossbar.send[i].val
  //       s.response_crossbar.send[i].rdy @= s.send_to_noc_load_response_pkt.rdy
  // 
  //   # Handles the request (not response) towards the others via the NoC. The dst would be
  //   # updated in the controller.
  //   s.send_to_noc_load_request_pkt.msg @= \
  //       NocPktType(s.cgra_id, # src
  //                   0, # dst
  //                   s.idTo2d_x_lut[s.cgra_id], # src_x
  //                   s.idTo2d_y_lut[s.cgra_id], # src_y
  //                   0, # dst_x
  //                   0, # dst_y
  //                   0, # src_tile_id
  //                   0, # dst_tile_id
  //                   s.read_crossbar.send[num_banks_per_cgra].msg.src, # remote_src_port
  //                   0, # opaque
  //                   0, # vc_id
  //                   CgraPayloadType(
  //                       CMD_LOAD_REQUEST,
  //                       0,
  //                       s.read_crossbar.send[num_banks_per_cgra].msg.addr, 0, 0))
  // 
  //   s.send_to_noc_load_request_pkt.val @= s.read_crossbar.send[num_banks_per_cgra].val 
  //   # TODO: https://github.com/tancheng/VectorCGRA/issues/26 -- Modify this part for non-blocking access.
  //   # 'val` indicates the data is arbitrated successfully.
  //   s.recv_from_noc_load_response_pkt.rdy @= s.response_crossbar.recv[num_banks_per_cgra].rdy
  //   s.response_crossbar.recv[num_banks_per_cgra].val @= s.recv_from_noc_load_response_pkt.val
  //   s.response_crossbar.recv[num_banks_per_cgra].msg @= \
  //       MemResponsePktType(num_banks_per_cgra,
  //                          s.recv_from_noc_load_response_pkt.msg.remote_src_port,
  //                          s.recv_from_noc_load_response_pkt.msg.payload.data_addr,
  //                          s.recv_from_noc_load_response_pkt.msg.payload.data,
  //                          s.recv_from_noc_load_response_pkt.msg.src,
  //                          s.recv_from_noc_load_response_pkt.msg.src_tile_id,
  //                          0)
  // 
  //   # Allows other load request towards NoC when the previous one is not responded. There
  //   # could be out-of-order load response, i.e., potential consistency issue.
  //   s.read_crossbar.send[num_banks_per_cgra].rdy @= s.send_to_noc_load_request_pkt.rdy
  // 
  //   # Handles the write port towards the NoC.
  //   s.send_to_noc_store_pkt.msg @= \
  //       NocPktType(s.cgra_id, # src
  //                   0, # dst
  //                   s.idTo2d_x_lut[s.cgra_id], # src_x
  //                   s.idTo2d_y_lut[s.cgra_id], # src_y
  //                   0, # dst_x
  //                   0, # dst_y
  //                   0, # src_tile_id
  //                   0, # dst_tile_id
  //                   s.write_crossbar.send[num_banks_per_cgra].msg.src, # remote_src_port
  //                   0, # opaque
  //                   0, # vc_id
  //                   CgraPayloadType(
  //                       CMD_STORE_REQUEST,
  //                       s.write_crossbar.send[num_banks_per_cgra].msg.data,
  //                       s.write_crossbar.send[num_banks_per_cgra].msg.addr, 0, 0))
  // 
  //   s.send_to_noc_store_pkt.val @= s.write_crossbar.send[num_banks_per_cgra].val
  //   s.write_crossbar.send[num_banks_per_cgra].rdy @= s.send_to_noc_store_pkt.rdy
  
  always_comb begin : update_all
    for ( int unsigned i = 1'd0; i < 2'( __const__num_rd_tiles_at_update_all ); i += 1'd1 )
      recv_raddr__rdy[2'(i)] = 1'd0;
    recv_from_noc_load_request__rdy = 1'd0;
    for ( int unsigned i = 1'd0; i < 2'( __const__num_wr_tiles_at_update_all ); i += 1'd1 )
      recv_waddr__rdy[2'(i)] = 1'd0;
    recv_from_noc_store_request__rdy = 1'd0;
    for ( int unsigned i = 1'd0; i < 2'( __const__num_rd_tiles_at_update_all ); i += 1'd1 ) begin
      send_rdata__val[2'(i)] = 1'd0;
      send_rdata__msg[2'(i)] = { 32'd0, 1'd0, 1'd0, 1'd0 };
    end
    send_to_noc_load_response_pkt__val = 1'd0;
    send_to_noc_load_response_pkt__msg = { 2'd0, 2'd0, 2'd0, 1'd0, 2'd0, 1'd0, 3'd0, 3'd0, 2'd0, 8'd0, 2'd0, { 5'd0, 35'd0, 9'd0, 139'd0, 3'd0 } };
    for ( int unsigned i = 1'd0; i < 2'( __const__num_wr_tiles_at_update_all ); i += 1'd1 )
      recv_wdata__rdy[2'(i)] = 1'd0;
    send_to_noc_store_pkt__msg = { 2'd0, 2'd0, 2'd0, 1'd0, 2'd0, 1'd0, 3'd0, 3'd0, 2'd0, 8'd0, 2'd0, { 5'd0, 35'd0, 9'd0, 139'd0, 3'd0 } };
    send_to_noc_store_pkt__val = 1'd0;
    for ( int unsigned i = 1'd0; i < 3'( __const__num_xbar_in_rd_ports_at_update_all ); i += 1'd1 ) begin
      read_crossbar__recv__val[2'(i)] = 1'd0;
      read_crossbar__recv__msg[2'(i)] = { 2'd0, 2'd0, 9'd0, { 32'd0, 1'd0, 1'd0, 1'd0 }, 2'd0, 3'd0, 2'd0 };
    end
    recv_from_noc_load_response_pkt__rdy = 1'd0;
    for ( int unsigned i = 1'd0; i < 3'( __const__num_xbar_in_wr_ports_at_update_all ); i += 1'd1 ) begin
      write_crossbar__recv__val[2'(i)] = 1'd0;
      write_crossbar__recv__msg[2'(i)] = { 2'd0, 2'd0, 9'd0, { 32'd0, 1'd0, 1'd0, 1'd0 }, 2'd0, 3'd0, 2'd0 };
    end
    send_to_noc_load_request_pkt__msg = { 2'd0, 2'd0, 2'd0, 1'd0, 2'd0, 1'd0, 3'd0, 3'd0, 2'd0, 8'd0, 2'd0, { 5'd0, 35'd0, 9'd0, 139'd0, 3'd0 } };
    send_to_noc_load_request_pkt__val = 1'd0;
    for ( int unsigned i = 1'd0; i < 2'( __const__num_rd_tiles_at_update_all ); i += 1'd1 ) begin
      read_crossbar__recv__val[2'(i)] = recv_raddr__val[2'(i)];
      read_crossbar__recv__msg[2'(i)] = rd_pkt[2'(i)];
      recv_raddr__rdy[2'(i)] = read_crossbar__recv__rdy[2'(i)];
    end
    read_crossbar__recv__val[2'( __const__num_rd_tiles_at_update_all )] = recv_from_noc_load_request__val;
    read_crossbar__recv__msg[2'( __const__num_rd_tiles_at_update_all )] = rd_pkt[2'( __const__num_rd_tiles_at_update_all )];
    recv_from_noc_load_request__rdy = read_crossbar__recv__rdy[2'( __const__num_rd_tiles_at_update_all )];
    for ( int unsigned i = 1'd0; i < 2'( __const__num_wr_tiles_at_update_all ); i += 1'd1 ) begin
      write_crossbar__recv__val[2'(i)] = recv_waddr__val[2'(i)];
      write_crossbar__recv__msg[2'(i)] = wr_pkt[2'(i)];
      recv_waddr__rdy[2'(i)] = write_crossbar__recv__rdy[2'(i)];
      recv_wdata__rdy[2'(i)] = write_crossbar__recv__rdy[2'(i)];
    end
    write_crossbar__recv__val[2'( __const__num_wr_tiles_at_update_all )] = recv_from_noc_store_request__val;
    write_crossbar__recv__msg[2'( __const__num_wr_tiles_at_update_all )] = wr_pkt[2'( __const__num_wr_tiles_at_update_all )];
    recv_from_noc_store_request__rdy = write_crossbar__recv__rdy[2'( __const__num_wr_tiles_at_update_all )];
    for ( int unsigned i = 1'd0; i < 3'( __const__num_xbar_in_rd_ports_at_update_all ); i += 1'd1 )
      if ( 2'(i) < 2'( __const__num_rd_tiles_at_update_all ) ) begin
        send_rdata__msg[2'( 2'(i) )] = response_crossbar__send__msg[2'(i)].data;
        send_rdata__val[2'( 2'(i) )] = response_crossbar__send__val[2'(i)];
        response_crossbar__send__rdy[2'(i)] = send_rdata__rdy[2'( 2'(i) )];
      end
      else begin
        __tmpvar__update_all_from_cgra_id = response_crossbar__send__msg[2'(i)].src_cgra;
        __tmpvar__update_all_from_tile_id = response_crossbar__send__msg[2'(i)].src_tile;
        send_to_noc_load_response_pkt__msg = { cgra_id, __tmpvar__update_all_from_cgra_id, idTo2d_x_lut[cgra_id], idTo2d_y_lut[cgra_id], idTo2d_x_lut[__tmpvar__update_all_from_cgra_id], idTo2d_y_lut[__tmpvar__update_all_from_cgra_id], 3'd0, __tmpvar__update_all_from_tile_id, response_crossbar__send__msg[2'(i)].remote_src_port, 8'd0, 2'd0, { 5'( __const__CMD_LOAD_RESPONSE ), response_crossbar__send__msg[2'(i)].data, response_crossbar__send__msg[2'(i)].addr, 139'd0, 3'd0 } };
        send_to_noc_load_response_pkt__val = response_crossbar__send__val[2'(i)];
        response_crossbar__send__rdy[2'(i)] = send_to_noc_load_response_pkt__rdy;
      end
    send_to_noc_load_request_pkt__msg = { cgra_id, 2'd0, idTo2d_x_lut[cgra_id], idTo2d_y_lut[cgra_id], 2'd0, 1'd0, 3'd0, 3'd0, read_crossbar__send__msg[2'( __const__num_banks_per_cgra_at_update_all )].src, 8'd0, 2'd0, { 5'( __const__CMD_LOAD_REQUEST ), 35'd0, read_crossbar__send__msg[2'( __const__num_banks_per_cgra_at_update_all )].addr, 139'd0, 3'd0 } };
    send_to_noc_load_request_pkt__val = read_crossbar__send__val[2'( __const__num_banks_per_cgra_at_update_all )];
    recv_from_noc_load_response_pkt__rdy = response_crossbar__recv__rdy[2'( __const__num_banks_per_cgra_at_update_all )];
    response_crossbar__recv__val[2'( __const__num_banks_per_cgra_at_update_all )] = recv_from_noc_load_response_pkt__val;
    response_crossbar__recv__msg[2'( __const__num_banks_per_cgra_at_update_all )] = { 2'( __const__num_banks_per_cgra_at_update_all ), recv_from_noc_load_response_pkt__msg.remote_src_port, recv_from_noc_load_response_pkt__msg.payload.data_addr, recv_from_noc_load_response_pkt__msg.payload.data, recv_from_noc_load_response_pkt__msg.src, recv_from_noc_load_response_pkt__msg.src_tile_id, 2'd0 };
    read_crossbar__send__rdy[2'( __const__num_banks_per_cgra_at_update_all )] = send_to_noc_load_request_pkt__rdy;
    send_to_noc_store_pkt__msg = { cgra_id, 2'd0, idTo2d_x_lut[cgra_id], idTo2d_y_lut[cgra_id], 2'd0, 1'd0, 3'd0, 3'd0, write_crossbar__send__msg[2'( __const__num_banks_per_cgra_at_update_all )].src, 8'd0, 2'd0, { 5'( __const__CMD_STORE_REQUEST ), write_crossbar__send__msg[2'( __const__num_banks_per_cgra_at_update_all )].data, write_crossbar__send__msg[2'( __const__num_banks_per_cgra_at_update_all )].addr, 139'd0, 3'd0 } };
    send_to_noc_store_pkt__val = write_crossbar__send__val[2'( __const__num_banks_per_cgra_at_update_all )];
    write_crossbar__send__rdy[2'( __const__num_banks_per_cgra_at_update_all )] = send_to_noc_store_pkt__rdy;
  end

  assign memory_wrapper__clk[0] = clk;
  assign memory_wrapper__reset[0] = reset;
  assign memory_wrapper__clk[1] = clk;
  assign memory_wrapper__reset[1] = reset;
  assign read_crossbar__clk = clk;
  assign read_crossbar__reset = reset;
  assign write_crossbar__clk = clk;
  assign write_crossbar__reset = reset;
  assign response_crossbar__clk = clk;
  assign response_crossbar__reset = reset;
  assign idTo2d_x_lut[0] = 2'd0;
  assign idTo2d_y_lut[0] = 1'd0;
  assign idTo2d_x_lut[1] = 2'd1;
  assign idTo2d_y_lut[1] = 1'd0;
  assign idTo2d_x_lut[2] = 2'd2;
  assign idTo2d_y_lut[2] = 1'd0;
  assign idTo2d_x_lut[3] = 2'd3;
  assign idTo2d_y_lut[3] = 1'd0;
  assign memory_wrapper__recv_rd__msg[0] = read_crossbar__send__msg[0];
  assign read_crossbar__send__rdy[0] = memory_wrapper__recv_rd__rdy[0];
  assign memory_wrapper__recv_rd__val[0] = read_crossbar__send__val[0];
  assign memory_wrapper__recv_wr__msg[0] = write_crossbar__send__msg[0];
  assign write_crossbar__send__rdy[0] = memory_wrapper__recv_wr__rdy[0];
  assign memory_wrapper__recv_wr__val[0] = write_crossbar__send__val[0];
  assign response_crossbar__recv__msg[0] = memory_wrapper__send__msg[0];
  assign memory_wrapper__send__rdy[0] = response_crossbar__recv__rdy[0];
  assign response_crossbar__recv__val[0] = memory_wrapper__send__val[0];
  assign memory_wrapper__recv_rd__msg[1] = read_crossbar__send__msg[1];
  assign read_crossbar__send__rdy[1] = memory_wrapper__recv_rd__rdy[1];
  assign memory_wrapper__recv_rd__val[1] = read_crossbar__send__val[1];
  assign memory_wrapper__recv_wr__msg[1] = write_crossbar__send__msg[1];
  assign write_crossbar__send__rdy[1] = memory_wrapper__recv_wr__rdy[1];
  assign memory_wrapper__recv_wr__val[1] = write_crossbar__send__val[1];
  assign response_crossbar__recv__msg[1] = memory_wrapper__send__msg[1];
  assign memory_wrapper__send__rdy[1] = response_crossbar__recv__rdy[1];
  assign response_crossbar__recv__val[1] = memory_wrapper__send__val[1];

endmodule


// PyMTL Component RegisterFile Definition
// Full name: RegisterFile__Type_CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1__nregs_8__rd_ports_1__wr_ports_1__const_zero_False
// At /cgra/venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/register_files.py

module RegisterFile__14fb828f022f9b03
(
  input  logic [0:0] clk ,
  input  logic [2:0] raddr [0:0],
  output CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 rdata [0:0],
  input  logic [0:0] reset ,
  input  logic [2:0] waddr [0:0],
  input  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 wdata [0:0],
  input  logic [0:0] wen [0:0]
);
  localparam logic [0:0] __const__rd_ports_at_up_rf_read  = 1'd1;
  localparam logic [0:0] __const__wr_ports_at_up_rf_write  = 1'd1;
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 regs [0:7];

  // PyMTL Update Block Source
  // At /cgra/venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/register_files.py:20
  // @update
  // def up_rf_read():
  //   for i in range( rd_ports ):
  //     s.rdata[i] @= s.regs[ s.raddr[i] ]
  
  always_comb begin : up_rf_read
    for ( int unsigned i = 1'd0; i < 1'( __const__rd_ports_at_up_rf_read ); i += 1'd1 )
      rdata[1'(i)] = regs[raddr[1'(i)]];
  end

  // PyMTL Update Block Source
  // At /cgra/venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/register_files.py:32
  // @update_ff
  // def up_rf_write():
  //   for i in range( wr_ports ):
  //     if s.wen[i]:
  //       s.regs[ s.waddr[i] ] <<= s.wdata[i]
  
  always_ff @(posedge clk) begin : up_rf_write
    for ( int unsigned i = 1'd0; i < 1'( __const__wr_ports_at_up_rf_write ); i += 1'd1 )
      if ( wen[1'(i)] ) begin
        regs[waddr[1'(i)]] <= wdata[1'(i)];
      end
  end

endmodule


// PyMTL Component ConstQueueDynamicRTL Definition
// Full name: ConstQueueDynamicRTL__DataType_CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1__const_mem_size_8
// At /cgra/VectorCGRA/mem/const/ConstQueueDynamicRTL.py

module ConstQueueDynamicRTL__04942ff39dc493d7
(
  input  logic [0:0] clear ,
  input  logic [0:0] clk ,
  input  logic [0:0] ctrl_proceed ,
  input  logic [0:0] reset ,
  input CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 recv_const__msg  ,
  output logic [0:0] recv_const__rdy  ,
  input logic [0:0] recv_const__val  ,
  output CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 send_const__msg  ,
  input logic [0:0] send_const__rdy  ,
  output logic [0:0] send_const__val  
);
  localparam logic [3:0] __const__const_mem_size_at_load_const  = 4'd8;
  localparam logic [3:0] __const__const_mem_size_at_update_wr_cur  = 4'd8;
  logic [2:0] rd_cur;
  logic [3:0] wr_cur;
  //-------------------------------------------------------------
  // Component reg_file
  //-------------------------------------------------------------

  logic [0:0] reg_file__clk;
  logic [2:0] reg_file__raddr [0:0];
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 reg_file__rdata [0:0];
  logic [0:0] reg_file__reset;
  logic [2:0] reg_file__waddr [0:0];
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 reg_file__wdata [0:0];
  logic [0:0] reg_file__wen [0:0];

  RegisterFile__14fb828f022f9b03 reg_file
  (
    .clk( reg_file__clk ),
    .raddr( reg_file__raddr ),
    .rdata( reg_file__rdata ),
    .reset( reg_file__reset ),
    .waddr( reg_file__waddr ),
    .wdata( reg_file__wdata ),
    .wen( reg_file__wen )
  );

  //-------------------------------------------------------------
  // End of component reg_file
  //-------------------------------------------------------------
  logic [0:0] __tmpvar__load_const_not_full;
  logic [0:0] __tmpvar__update_wr_cur_not_full;

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/mem/const/ConstQueueDynamicRTL.py:56
  // @update
  // def load_const():
  //   # Initializes signals.
  //   s.reg_file.waddr[0] @= AddrType()
  //   s.reg_file.wdata[0] @= DataType()
  //   s.reg_file.wen[0] @= 0
  // 
  //   not_full = s.wr_cur < const_mem_size
  //   s.recv_const.rdy @= not_full
  // 
  //   if s.recv_const.val & not_full:
  //     s.reg_file.waddr[0] @= trunc(s.wr_cur, AddrType)
  //     s.reg_file.wdata[0] @= s.recv_const.msg
  //     s.reg_file.wen[0] @= 1
  
  always_comb begin : load_const
    reg_file__waddr[1'd0] = 3'd0;
    reg_file__wdata[1'd0] = { 32'd0, 1'd0, 1'd0, 1'd0 };
    reg_file__wen[1'd0] = 1'd0;
    __tmpvar__load_const_not_full = wr_cur < 4'( __const__const_mem_size_at_load_const );
    recv_const__rdy = __tmpvar__load_const_not_full;
    if ( recv_const__val & __tmpvar__load_const_not_full ) begin
      reg_file__waddr[1'd0] = 3'(wr_cur);
      reg_file__wdata[1'd0] = recv_const__msg;
      reg_file__wen[1'd0] = 1'd1;
    end
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/mem/const/ConstQueueDynamicRTL.py:83
  // @update
  // def update_send_val():
  //   # Checks if read cursor is in front of write cursor.
  //   if (zext(s.rd_cur, WrCurType) < s.wr_cur):
  //     s.send_const.val @= 1
  //   else:
  //     s.send_const.val @= 0
  
  always_comb begin : update_send_val
    if ( { { 1 { 1'b0 } }, rd_cur } < wr_cur ) begin
      send_const__val = 1'd1;
    end
    else
      send_const__val = 1'd0;
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/mem/const/ConstQueueDynamicRTL.py:92
  // @update_ff
  // def update_rd_cur():
  //   if s.reset | s.clear:
  //     s.rd_cur <<= 0
  //   else:
  //     # Checks whether the "reader" successfully read the data at rd_cur,
  //     # and proceed rd_cur accordingly.
  //     if s.send_const.rdy & s.ctrl_proceed:
  //       if zext((s.rd_cur), WrCurType) < (s.wr_cur - 1):
  //         s.rd_cur <<= s.rd_cur + 1
  //       else:
  //         s.rd_cur <<= 0
  
  always_ff @(posedge clk) begin : update_rd_cur
    if ( reset | clear ) begin
      rd_cur <= 3'd0;
    end
    else if ( send_const__rdy & ctrl_proceed ) begin
      if ( { { 1 { 1'b0 } }, rd_cur } < ( wr_cur - 4'd1 ) ) begin
        rd_cur <= rd_cur + 3'd1;
      end
      else
        rd_cur <= 3'd0;
    end
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/mem/const/ConstQueueDynamicRTL.py:72
  // @update_ff
  // def update_wr_cur():
  //   not_full = (s.wr_cur < const_mem_size)
  //   if s.reset | s.clear:
  //     s.wr_cur <<= 0
  //   # Checks if there's a valid const (from producer) to be written.
  //   else:
  //     if s.recv_const.val & not_full:
  //       s.wr_cur <<= s.wr_cur + 1
  
  always_ff @(posedge clk) begin : update_wr_cur
    __tmpvar__update_wr_cur_not_full = wr_cur < 4'( __const__const_mem_size_at_update_wr_cur );
    if ( reset | clear ) begin
      wr_cur <= 4'd0;
    end
    else if ( recv_const__val & __tmpvar__update_wr_cur_not_full ) begin
      wr_cur <= wr_cur + 4'd1;
    end
  end

  assign reg_file__clk = clk;
  assign reg_file__reset = reset;
  assign send_const__msg = reg_file__rdata[0];
  assign reg_file__raddr[0] = rd_cur;

endmodule


// PyMTL Component RegisterFile Definition
// Full name: RegisterFile__Type_MultiCgraPayload_Cmd_Data_DataAddr_Ctrl_CtrlAddr__a0427cd98cfcae6f__nregs_2__rd_ports_1__wr_ports_1__const_zero_False
// At /cgra/venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/register_files.py

module RegisterFile__a48380321b2771c3
(
  input  logic [0:0] clk ,
  input  logic [0:0] raddr [0:0],
  output MultiCgraPayload_Cmd_Data_DataAddr_Ctrl_CtrlAddr__a0427cd98cfcae6f rdata [0:0],
  input  logic [0:0] reset ,
  input  logic [0:0] waddr [0:0],
  input  MultiCgraPayload_Cmd_Data_DataAddr_Ctrl_CtrlAddr__a0427cd98cfcae6f wdata [0:0],
  input  logic [0:0] wen [0:0]
);
  localparam logic [0:0] __const__rd_ports_at_up_rf_read  = 1'd1;
  localparam logic [0:0] __const__wr_ports_at_up_rf_write  = 1'd1;
  MultiCgraPayload_Cmd_Data_DataAddr_Ctrl_CtrlAddr__a0427cd98cfcae6f regs [0:1];

  // PyMTL Update Block Source
  // At /cgra/venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/register_files.py:20
  // @update
  // def up_rf_read():
  //   for i in range( rd_ports ):
  //     s.rdata[i] @= s.regs[ s.raddr[i] ]
  
  always_comb begin : up_rf_read
    for ( int unsigned i = 1'd0; i < 1'( __const__rd_ports_at_up_rf_read ); i += 1'd1 )
      rdata[1'(i)] = regs[raddr[1'(i)]];
  end

  // PyMTL Update Block Source
  // At /cgra/venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/register_files.py:32
  // @update_ff
  // def up_rf_write():
  //   for i in range( wr_ports ):
  //     if s.wen[i]:
  //       s.regs[ s.waddr[i] ] <<= s.wdata[i]
  
  always_ff @(posedge clk) begin : up_rf_write
    for ( int unsigned i = 1'd0; i < 1'( __const__wr_ports_at_up_rf_write ); i += 1'd1 )
      if ( wen[1'(i)] ) begin
        regs[waddr[1'(i)]] <= wdata[1'(i)];
      end
  end

endmodule


// PyMTL Component NormalQueueDpathRTL Definition
// Full name: NormalQueueDpathRTL__EntryType_MultiCgraPayload_Cmd_Data_DataAddr_Ctrl_CtrlAddr__a0427cd98cfcae6f__num_entries_2
// At /cgra/VectorCGRA/lib/basic/val_rdy/queues.py

module NormalQueueDpathRTL__2d36eadf4911a62a
(
  input  logic [0:0] clk ,
  input  logic [0:0] raddr ,
  input  MultiCgraPayload_Cmd_Data_DataAddr_Ctrl_CtrlAddr__a0427cd98cfcae6f recv_msg ,
  input  logic [0:0] reset ,
  output MultiCgraPayload_Cmd_Data_DataAddr_Ctrl_CtrlAddr__a0427cd98cfcae6f send_msg ,
  input  logic [0:0] waddr ,
  input  logic [0:0] wen 
);
  //-------------------------------------------------------------
  // Component rf
  //-------------------------------------------------------------

  logic [0:0] rf__clk;
  logic [0:0] rf__raddr [0:0];
  MultiCgraPayload_Cmd_Data_DataAddr_Ctrl_CtrlAddr__a0427cd98cfcae6f rf__rdata [0:0];
  logic [0:0] rf__reset;
  logic [0:0] rf__waddr [0:0];
  MultiCgraPayload_Cmd_Data_DataAddr_Ctrl_CtrlAddr__a0427cd98cfcae6f rf__wdata [0:0];
  logic [0:0] rf__wen [0:0];

  RegisterFile__a48380321b2771c3 rf
  (
    .clk( rf__clk ),
    .raddr( rf__raddr ),
    .rdata( rf__rdata ),
    .reset( rf__reset ),
    .waddr( rf__waddr ),
    .wdata( rf__wdata ),
    .wen( rf__wen )
  );

  //-------------------------------------------------------------
  // End of component rf
  //-------------------------------------------------------------

  assign rf__clk = clk;
  assign rf__reset = reset;
  assign rf__raddr[0] = raddr;
  assign send_msg = rf__rdata[0];
  assign rf__wen[0] = wen;
  assign rf__waddr[0] = waddr;
  assign rf__wdata[0] = recv_msg;

endmodule


// PyMTL Component NormalQueueRTL Definition
// Full name: NormalQueueRTL__EntryType_MultiCgraPayload_Cmd_Data_DataAddr_Ctrl_CtrlAddr__a0427cd98cfcae6f__num_entries_2
// At /cgra/VectorCGRA/lib/basic/val_rdy/queues.py

module NormalQueueRTL__2d36eadf4911a62a
(
  input  logic [0:0] clk ,
  output logic [1:0] count ,
  input  logic [0:0] reset ,
  input MultiCgraPayload_Cmd_Data_DataAddr_Ctrl_CtrlAddr__a0427cd98cfcae6f recv__msg  ,
  output logic [0:0] recv__rdy  ,
  input logic [0:0] recv__val  ,
  output MultiCgraPayload_Cmd_Data_DataAddr_Ctrl_CtrlAddr__a0427cd98cfcae6f send__msg  ,
  input logic [0:0] send__rdy  ,
  output logic [0:0] send__val  
);
  //-------------------------------------------------------------
  // Component ctrl
  //-------------------------------------------------------------

  logic [0:0] ctrl__clk;
  logic [1:0] ctrl__count;
  logic [0:0] ctrl__raddr;
  logic [0:0] ctrl__recv_rdy;
  logic [0:0] ctrl__recv_val;
  logic [0:0] ctrl__reset;
  logic [0:0] ctrl__send_rdy;
  logic [0:0] ctrl__send_val;
  logic [0:0] ctrl__waddr;
  logic [0:0] ctrl__wen;

  NormalQueueCtrlRTL__num_entries_2 ctrl
  (
    .clk( ctrl__clk ),
    .count( ctrl__count ),
    .raddr( ctrl__raddr ),
    .recv_rdy( ctrl__recv_rdy ),
    .recv_val( ctrl__recv_val ),
    .reset( ctrl__reset ),
    .send_rdy( ctrl__send_rdy ),
    .send_val( ctrl__send_val ),
    .waddr( ctrl__waddr ),
    .wen( ctrl__wen )
  );

  //-------------------------------------------------------------
  // End of component ctrl
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component dpath
  //-------------------------------------------------------------

  logic [0:0] dpath__clk;
  logic [0:0] dpath__raddr;
  MultiCgraPayload_Cmd_Data_DataAddr_Ctrl_CtrlAddr__a0427cd98cfcae6f dpath__recv_msg;
  logic [0:0] dpath__reset;
  MultiCgraPayload_Cmd_Data_DataAddr_Ctrl_CtrlAddr__a0427cd98cfcae6f dpath__send_msg;
  logic [0:0] dpath__waddr;
  logic [0:0] dpath__wen;

  NormalQueueDpathRTL__2d36eadf4911a62a dpath
  (
    .clk( dpath__clk ),
    .raddr( dpath__raddr ),
    .recv_msg( dpath__recv_msg ),
    .reset( dpath__reset ),
    .send_msg( dpath__send_msg ),
    .waddr( dpath__waddr ),
    .wen( dpath__wen )
  );

  //-------------------------------------------------------------
  // End of component dpath
  //-------------------------------------------------------------

  assign ctrl__clk = clk;
  assign ctrl__reset = reset;
  assign dpath__clk = clk;
  assign dpath__reset = reset;
  assign dpath__wen = ctrl__wen;
  assign dpath__waddr = ctrl__waddr;
  assign dpath__raddr = ctrl__raddr;
  assign ctrl__recv_val = recv__val;
  assign recv__rdy = ctrl__recv_rdy;
  assign dpath__recv_msg = recv__msg;
  assign send__val = ctrl__send_val;
  assign ctrl__send_rdy = send__rdy;
  assign send__msg = dpath__send_msg;
  assign count = ctrl__count;

endmodule


// PyMTL Component RegisterFile Definition
// Full name: RegisterFile__Type_CGRAConfig_7_4_2_8_8_3__603a41f5d0e2436f__nregs_8__rd_ports_1__wr_ports_1__const_zero_False
// At /cgra/venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/register_files.py

module RegisterFile__1d4e07673f8d2d02
(
  input  logic [0:0] clk ,
  input  logic [2:0] raddr [0:0],
  output CGRAConfig_7_4_2_8_8_3__603a41f5d0e2436f rdata [0:0],
  input  logic [0:0] reset ,
  input  logic [2:0] waddr [0:0],
  input  CGRAConfig_7_4_2_8_8_3__603a41f5d0e2436f wdata [0:0],
  input  logic [0:0] wen [0:0]
);
  localparam logic [0:0] __const__rd_ports_at_up_rf_read  = 1'd1;
  localparam logic [0:0] __const__wr_ports_at_up_rf_write  = 1'd1;
  CGRAConfig_7_4_2_8_8_3__603a41f5d0e2436f regs [0:7];

  // PyMTL Update Block Source
  // At /cgra/venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/register_files.py:20
  // @update
  // def up_rf_read():
  //   for i in range( rd_ports ):
  //     s.rdata[i] @= s.regs[ s.raddr[i] ]
  
  always_comb begin : up_rf_read
    for ( int unsigned i = 1'd0; i < 1'( __const__rd_ports_at_up_rf_read ); i += 1'd1 )
      rdata[1'(i)] = regs[raddr[1'(i)]];
  end

  // PyMTL Update Block Source
  // At /cgra/venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/register_files.py:32
  // @update_ff
  // def up_rf_write():
  //   for i in range( wr_ports ):
  //     if s.wen[i]:
  //       s.regs[ s.waddr[i] ] <<= s.wdata[i]
  
  always_ff @(posedge clk) begin : up_rf_write
    for ( int unsigned i = 1'd0; i < 1'( __const__wr_ports_at_up_rf_write ); i += 1'd1 )
      if ( wen[1'(i)] ) begin
        regs[waddr[1'(i)]] <= wdata[1'(i)];
      end
  end

endmodule


// PyMTL Component CtrlMemDynamicRTL Definition
// Full name: CtrlMemDynamicRTL__IntraCgraPktType_IntraCgraPacket_4_4x1_4_8_2_CgraPayload__11cd3f8c0d91825c__ctrl_mem_size_8__num_fu_inports_4__num_fu_outports_2__num_tile_inports_8__num_tile_outports_8__num_cgras_4__num_tiles_4__ctrl_count_per_iter_8__total_ctrl_steps_8
// At /cgra/VectorCGRA/mem/ctrl/CtrlMemDynamicRTL.py

module CtrlMemDynamicRTL__06f86f060b697c96
(
  input  logic [1:0] cgra_id ,
  input  logic [0:0] clk ,
  output logic [2:0] ctrl_addr_outport ,
  output logic [2:0] prologue_count_outport_fu ,
  output logic [2:0] prologue_count_outport_fu_crossbar [0:7][0:1],
  output logic [2:0] prologue_count_outport_routing_crossbar [0:7][0:7],
  input  logic [0:0] reset ,
  input  logic [2:0] tile_id ,
  input MultiCgraPayload_Cmd_Data_DataAddr_Ctrl_CtrlAddr__a0427cd98cfcae6f recv_from_element__msg  ,
  output logic [0:0] recv_from_element__rdy  ,
  input logic [0:0] recv_from_element__val  ,
  input IntraCgraPacket_4_4x1_4_8_2_CgraPayload__11cd3f8c0d91825c recv_pkt_from_controller__msg  ,
  output logic [0:0] recv_pkt_from_controller__rdy  ,
  input logic [0:0] recv_pkt_from_controller__val  ,
  output CGRAConfig_7_4_2_8_8_3__603a41f5d0e2436f send_ctrl__msg  ,
  input logic [0:0] send_ctrl__rdy  ,
  output logic [0:0] send_ctrl__val  ,
  output IntraCgraPacket_4_4x1_4_8_2_CgraPayload__11cd3f8c0d91825c send_pkt_to_controller__msg  ,
  input logic [0:0] send_pkt_to_controller__rdy  ,
  output logic [0:0] send_pkt_to_controller__val  ,
  output MultiCgraPayload_Cmd_Data_DataAddr_Ctrl_CtrlAddr__a0427cd98cfcae6f send_to_element__msg  ,
  input logic [0:0] send_to_element__rdy  ,
  output logic [0:0] send_to_element__val  
);
  localparam logic [2:0] __const__num_fu_inports_at_update_msg  = 3'd4;
  localparam logic [3:0] __const__num_routing_outports_at_update_msg  = 4'd12;
  localparam logic [1:0] __const__CMD_CONFIG  = 2'd3;
  localparam logic [4:0] __const__CMD_GLOBAL_REDUCE_ADD_RESPONSE  = 5'd20;
  localparam logic [4:0] __const__CMD_GLOBAL_REDUCE_MUL_RESPONSE  = 5'd21;
  localparam logic [4:0] __const__CMD_CONFIG_LOOP_LOWER  = 5'd28;
  localparam logic [4:0] __const__CMD_CONFIG_LOOP_UPPER  = 5'd29;
  localparam logic [4:0] __const__CMD_CONFIG_LOOP_STEP  = 5'd30;
  localparam logic [4:0] __const__CMD_UPDATE_COUNTER_SHADOW_VALUE  = 5'd26;
  localparam logic [4:0] __const__CMD_RESET_LEAF_COUNTER  = 5'd27;
  localparam logic [2:0] __const__CMD_CONFIG_PROLOGUE_FU  = 3'd4;
  localparam logic [2:0] __const__CMD_CONFIG_PROLOGUE_FU_CROSSBAR  = 3'd5;
  localparam logic [2:0] __const__CMD_CONFIG_PROLOGUE_ROUTING_CROSSBAR  = 3'd6;
  localparam logic [0:0] __const__CMD_LAUNCH  = 1'd0;
  localparam logic [1:0] __const__CMD_TERMINATE  = 2'd2;
  localparam logic [0:0] __const__CMD_PAUSE  = 1'd1;
  localparam logic [4:0] __const__CMD_PRESERVE  = 5'd22;
  localparam logic [3:0] __const__CMD_RESUME  = 4'd15;
  localparam logic [2:0] __const__CMD_CONFIG_TOTAL_CTRL_COUNT  = 3'd7;
  localparam logic [3:0] __const__CMD_CONFIG_COUNT_PER_ITER  = 4'd8;
  localparam logic [3:0] __const__CMD_CONFIG_CTRL_LOWER_BOUND  = 4'd9;
  localparam logic [4:0] __const__CMD_RECORD_PHI_ADDR  = 5'd16;
  localparam logic [4:0] __const__CMD_CONFIG_STREAMING_LD_START_ADDR  = 5'd23;
  localparam logic [4:0] __const__CMD_CONFIG_STREAMING_LD_STRIDE  = 5'd24;
  localparam logic [4:0] __const__CMD_CONFIG_STREAMING_LD_END_ADDR  = 5'd25;
  localparam logic [2:0] __const__num_tiles_at_update_send_pkt_to_controller  = 3'd4;
  localparam logic [3:0] __const__CMD_COMPLETE  = 4'd14;
  localparam logic [6:0] __const__OPT_START  = 7'd0;
  localparam logic [3:0] __const__ctrl_mem_size_at_update_raddr_and_fu_prologue  = 4'd8;
  localparam logic [3:0] __const__ctrl_mem_size_at_update_prologue_outport  = 4'd8;
  localparam logic [3:0] __const__num_tile_inports_at_update_prologue_outport  = 4'd8;
  localparam logic [1:0] __const__num_fu_outports_at_update_prologue_outport  = 2'd2;
  localparam logic [3:0] __const__ctrl_mem_size_at_update_prologue_reg  = 4'd8;
  localparam logic [3:0] __const__num_tile_inports_at_update_prologue_reg  = 4'd8;
  localparam logic [1:0] __const__num_fu_outports_at_update_prologue_reg  = 2'd2;
  localparam logic [3:0] __const__ctrl_count_per_iter_at_update_ctrl_count_per_iter  = 4'd8;
  localparam logic [3:0] __const__total_ctrl_steps_at_update_total_ctrl_steps  = 4'd8;
  logic [2:0] ctrl_count_lower_bound;
  logic [3:0] ctrl_count_per_iter_val;
  logic [3:0] ctrl_count_upper_bound;
  logic [2:0] prologue_count_reg_fu [0:7];
  logic [2:0] prologue_count_reg_fu_crossbar [0:7][0:1];
  logic [2:0] prologue_count_reg_routing_crossbar [0:7][0:7];
  logic [0:0] sent_complete;
  logic [0:0] start_iterate_ctrl;
  logic [10:0] times;
  logic [10:0] total_ctrl_steps_val;
  //-------------------------------------------------------------
  // Component recv_from_element_queue
  //-------------------------------------------------------------

  logic [0:0] recv_from_element_queue__clk;
  logic [1:0] recv_from_element_queue__count;
  logic [0:0] recv_from_element_queue__reset;
  MultiCgraPayload_Cmd_Data_DataAddr_Ctrl_CtrlAddr__a0427cd98cfcae6f recv_from_element_queue__recv__msg;
  logic [0:0] recv_from_element_queue__recv__rdy;
  logic [0:0] recv_from_element_queue__recv__val;
  MultiCgraPayload_Cmd_Data_DataAddr_Ctrl_CtrlAddr__a0427cd98cfcae6f recv_from_element_queue__send__msg;
  logic [0:0] recv_from_element_queue__send__rdy;
  logic [0:0] recv_from_element_queue__send__val;

  NormalQueueRTL__2d36eadf4911a62a recv_from_element_queue
  (
    .clk( recv_from_element_queue__clk ),
    .count( recv_from_element_queue__count ),
    .reset( recv_from_element_queue__reset ),
    .recv__msg( recv_from_element_queue__recv__msg ),
    .recv__rdy( recv_from_element_queue__recv__rdy ),
    .recv__val( recv_from_element_queue__recv__val ),
    .send__msg( recv_from_element_queue__send__msg ),
    .send__rdy( recv_from_element_queue__send__rdy ),
    .send__val( recv_from_element_queue__send__val )
  );

  //-------------------------------------------------------------
  // End of component recv_from_element_queue
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component recv_pkt_from_controller_queue
  //-------------------------------------------------------------

  logic [0:0] recv_pkt_from_controller_queue__clk;
  logic [1:0] recv_pkt_from_controller_queue__count;
  logic [0:0] recv_pkt_from_controller_queue__reset;
  IntraCgraPacket_4_4x1_4_8_2_CgraPayload__11cd3f8c0d91825c recv_pkt_from_controller_queue__recv__msg;
  logic [0:0] recv_pkt_from_controller_queue__recv__rdy;
  logic [0:0] recv_pkt_from_controller_queue__recv__val;
  IntraCgraPacket_4_4x1_4_8_2_CgraPayload__11cd3f8c0d91825c recv_pkt_from_controller_queue__send__msg;
  logic [0:0] recv_pkt_from_controller_queue__send__rdy;
  logic [0:0] recv_pkt_from_controller_queue__send__val;

  NormalQueueRTL__4d91d5ee0229de22 recv_pkt_from_controller_queue
  (
    .clk( recv_pkt_from_controller_queue__clk ),
    .count( recv_pkt_from_controller_queue__count ),
    .reset( recv_pkt_from_controller_queue__reset ),
    .recv__msg( recv_pkt_from_controller_queue__recv__msg ),
    .recv__rdy( recv_pkt_from_controller_queue__recv__rdy ),
    .recv__val( recv_pkt_from_controller_queue__recv__val ),
    .send__msg( recv_pkt_from_controller_queue__send__msg ),
    .send__rdy( recv_pkt_from_controller_queue__send__rdy ),
    .send__val( recv_pkt_from_controller_queue__send__val )
  );

  //-------------------------------------------------------------
  // End of component recv_pkt_from_controller_queue
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component reg_file
  //-------------------------------------------------------------

  logic [0:0] reg_file__clk;
  logic [2:0] reg_file__raddr [0:0];
  CGRAConfig_7_4_2_8_8_3__603a41f5d0e2436f reg_file__rdata [0:0];
  logic [0:0] reg_file__reset;
  logic [2:0] reg_file__waddr [0:0];
  CGRAConfig_7_4_2_8_8_3__603a41f5d0e2436f reg_file__wdata [0:0];
  logic [0:0] reg_file__wen [0:0];

  RegisterFile__1d4e07673f8d2d02 reg_file
  (
    .clk( reg_file__clk ),
    .raddr( reg_file__raddr ),
    .rdata( reg_file__rdata ),
    .reset( reg_file__reset ),
    .waddr( reg_file__waddr ),
    .wdata( reg_file__wdata ),
    .wen( reg_file__wen )
  );

  //-------------------------------------------------------------
  // End of component reg_file
  //-------------------------------------------------------------
  logic [3:0] __tmpvar__update_prologue_reg_temp_routing_crossbar_in;
  logic [1:0] __tmpvar__update_prologue_reg_temp_fu_crossbar_in;

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/mem/ctrl/CtrlMemDynamicRTL.py:170
  // @update
  // def update_ctrl_addr_outport():
  //   s.ctrl_addr_outport @= s.reg_file.raddr[0]
  
  always_comb begin : update_ctrl_addr_outport
    ctrl_addr_outport = reg_file__raddr[1'd0];
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/mem/ctrl/CtrlMemDynamicRTL.py:94
  // @update
  // def update_msg():
  //   s.recv_pkt_from_controller_queue.send.rdy @= 0
  //   s.send_to_element.msg @= CgraPayloadType(0, 0, 0, 0, 0)
  //   s.send_to_element.val @= 0
  //   s.reg_file.wen[0] @= 0
  //   s.reg_file.waddr[0] @= s.recv_pkt_from_controller_queue.send.msg.payload.ctrl_addr
  //   # Initializes the fields of the control signal.
  //   s.reg_file.wdata[0].operation @= 0
  //   for i in range(num_fu_inports):
  //     s.reg_file.wdata[0].fu_in[i] @= 0
  //     s.reg_file.wdata[0].write_reg_from[i] @= s.recv_pkt_from_controller_queue.send.msg.payload.ctrl.write_reg_from[i]
  //     s.reg_file.wdata[0].write_reg_idx[i] @= s.recv_pkt_from_controller_queue.send.msg.payload.ctrl.write_reg_idx[i]
  //     s.reg_file.wdata[0].read_reg_from[i] @= s.recv_pkt_from_controller_queue.send.msg.payload.ctrl.read_reg_from[i]
  //     s.reg_file.wdata[0].read_reg_idx[i] @= s.recv_pkt_from_controller_queue.send.msg.payload.ctrl.read_reg_idx[i]
  //   for i in range(num_routing_outports):
  //     s.reg_file.wdata[0].routing_xbar_outport[i] @= 0
  //     s.reg_file.wdata[0].fu_xbar_outport[i] @= 0
  //   s.reg_file.wdata[0].vector_factor_power @= s.recv_pkt_from_controller_queue.send.msg.payload.ctrl.vector_factor_power
  //   s.reg_file.wdata[0].is_last_ctrl @= 0
  // 
  //   if s.recv_pkt_from_controller_queue.send.val & (s.recv_pkt_from_controller_queue.send.msg.payload.cmd == CMD_CONFIG):
  //     s.reg_file.wen[0] @= 1
  //     s.reg_file.waddr[0] @= s.recv_pkt_from_controller_queue.send.msg.payload.ctrl_addr
  //     # Fills the fields of the control signal.
  //     s.reg_file.wdata[0].operation @= s.recv_pkt_from_controller_queue.send.msg.payload.ctrl.operation
  //     for i in range(num_fu_inports):
  //       s.reg_file.wdata[0].fu_in[i] @= s.recv_pkt_from_controller_queue.send.msg.payload.ctrl.fu_in[i]
  //       s.reg_file.wdata[0].write_reg_from[i] @= s.recv_pkt_from_controller_queue.send.msg.payload.ctrl.write_reg_from[i]
  //       s.reg_file.wdata[0].write_reg_idx[i] @= s.recv_pkt_from_controller_queue.send.msg.payload.ctrl.write_reg_idx[i]
  //       s.reg_file.wdata[0].read_reg_from[i] @= s.recv_pkt_from_controller_queue.send.msg.payload.ctrl.read_reg_from[i]
  //       s.reg_file.wdata[0].read_reg_idx[i] @= s.recv_pkt_from_controller_queue.send.msg.payload.ctrl.read_reg_idx[i]
  //     for i in range(num_routing_outports):
  //       s.reg_file.wdata[0].routing_xbar_outport[i] @= s.recv_pkt_from_controller_queue.send.msg.payload.ctrl.routing_xbar_outport[i]
  //       s.reg_file.wdata[0].fu_xbar_outport[i] @= s.recv_pkt_from_controller_queue.send.msg.payload.ctrl.fu_xbar_outport[i]
  //     s.reg_file.wdata[0].vector_factor_power @= s.recv_pkt_from_controller_queue.send.msg.payload.ctrl.vector_factor_power
  //     s.reg_file.wdata[0].is_last_ctrl @= s.recv_pkt_from_controller_queue.send.msg.payload.ctrl.is_last_ctrl
  //   elif s.recv_pkt_from_controller_queue.send.val & \
  //        ((s.recv_pkt_from_controller_queue.send.msg.payload.cmd == CMD_GLOBAL_REDUCE_ADD_RESPONSE) | \
  //         (s.recv_pkt_from_controller_queue.send.msg.payload.cmd == CMD_GLOBAL_REDUCE_MUL_RESPONSE) | \
  //         (s.recv_pkt_from_controller_queue.send.msg.payload.cmd == CMD_CONFIG_LOOP_LOWER) | \
  //         (s.recv_pkt_from_controller_queue.send.msg.payload.cmd == CMD_CONFIG_LOOP_UPPER) | \
  //         (s.recv_pkt_from_controller_queue.send.msg.payload.cmd == CMD_CONFIG_LOOP_STEP) | \
  //         (s.recv_pkt_from_controller_queue.send.msg.payload.cmd == CMD_UPDATE_COUNTER_SHADOW_VALUE) | \
  //         (s.recv_pkt_from_controller_queue.send.msg.payload.cmd == CMD_RESET_LEAF_COUNTER)):
  //     s.send_to_element.msg @= s.recv_pkt_from_controller_queue.send.msg.payload
  //     s.send_to_element.val @= 1
  // 
  //   if (s.recv_pkt_from_controller_queue.send.msg.payload.cmd == CMD_CONFIG) | \
  //      (s.recv_pkt_from_controller_queue.send.msg.payload.cmd == CMD_CONFIG_PROLOGUE_FU) | \
  //      (s.recv_pkt_from_controller_queue.send.msg.payload.cmd == CMD_CONFIG_PROLOGUE_FU_CROSSBAR) | \
  //      (s.recv_pkt_from_controller_queue.send.msg.payload.cmd == CMD_CONFIG_PROLOGUE_ROUTING_CROSSBAR) | \
  //      (s.recv_pkt_from_controller_queue.send.msg.payload.cmd == CMD_LAUNCH) | \
  //      (s.recv_pkt_from_controller_queue.send.msg.payload.cmd == CMD_TERMINATE) | \
  //      (s.recv_pkt_from_controller_queue.send.msg.payload.cmd == CMD_PAUSE) | \
  //      (s.recv_pkt_from_controller_queue.send.msg.payload.cmd == CMD_PRESERVE) | \
  //      (s.recv_pkt_from_controller_queue.send.msg.payload.cmd == CMD_RESUME) | \
  //      (s.recv_pkt_from_controller_queue.send.msg.payload.cmd == CMD_CONFIG_TOTAL_CTRL_COUNT) | \
  //      (s.recv_pkt_from_controller_queue.send.msg.payload.cmd == CMD_CONFIG_COUNT_PER_ITER) | \
  //      (s.recv_pkt_from_controller_queue.send.msg.payload.cmd == CMD_CONFIG_CTRL_LOWER_BOUND) | \
  //      (s.recv_pkt_from_controller_queue.send.msg.payload.cmd == CMD_RECORD_PHI_ADDR) | \
  //      (s.recv_pkt_from_controller_queue.send.msg.payload.cmd == CMD_GLOBAL_REDUCE_ADD_RESPONSE) | \
  //      (s.recv_pkt_from_controller_queue.send.msg.payload.cmd == CMD_CONFIG_STREAMING_LD_START_ADDR) | \
  //      (s.recv_pkt_from_controller_queue.send.msg.payload.cmd == CMD_CONFIG_STREAMING_LD_STRIDE) | \
  //      (s.recv_pkt_from_controller_queue.send.msg.payload.cmd == CMD_CONFIG_STREAMING_LD_END_ADDR) | \
  //      (s.recv_pkt_from_controller_queue.send.msg.payload.cmd == CMD_GLOBAL_REDUCE_MUL_RESPONSE) | \
  //      (s.recv_pkt_from_controller_queue.send.msg.payload.cmd == CMD_CONFIG_LOOP_LOWER) | \
  //      (s.recv_pkt_from_controller_queue.send.msg.payload.cmd == CMD_CONFIG_LOOP_UPPER) | \
  //      (s.recv_pkt_from_controller_queue.send.msg.payload.cmd == CMD_CONFIG_LOOP_STEP) | \
  //      (s.recv_pkt_from_controller_queue.send.msg.payload.cmd == CMD_UPDATE_COUNTER_SHADOW_VALUE) | \
  //      (s.recv_pkt_from_controller_queue.send.msg.payload.cmd == CMD_RESET_LEAF_COUNTER):
  //     s.recv_pkt_from_controller_queue.send.rdy @= 1
  //   # TODO: Extend for the other commands. Maybe another queue to
  //   # handle complicated actions.
  //   # else:
  
  always_comb begin : update_msg
    recv_pkt_from_controller_queue__send__rdy = 1'd0;
    send_to_element__msg = { 5'd0, 35'd0, 9'd0, 139'd0, 3'd0 };
    send_to_element__val = 1'd0;
    reg_file__wen[1'd0] = 1'd0;
    reg_file__waddr[1'd0] = recv_pkt_from_controller_queue__send__msg.payload.ctrl_addr;
    reg_file__wdata[1'd0].operation = 7'd0;
    for ( int unsigned i = 1'd0; i < 3'( __const__num_fu_inports_at_update_msg ); i += 1'd1 ) begin
      reg_file__wdata[1'd0].fu_in[2'(i)] = 3'd0;
      reg_file__wdata[1'd0].write_reg_from[2'(i)] = recv_pkt_from_controller_queue__send__msg.payload.ctrl.write_reg_from[2'(i)];
      reg_file__wdata[1'd0].write_reg_idx[2'(i)] = recv_pkt_from_controller_queue__send__msg.payload.ctrl.write_reg_idx[2'(i)];
      reg_file__wdata[1'd0].read_reg_from[2'(i)] = recv_pkt_from_controller_queue__send__msg.payload.ctrl.read_reg_from[2'(i)];
      reg_file__wdata[1'd0].read_reg_idx[2'(i)] = recv_pkt_from_controller_queue__send__msg.payload.ctrl.read_reg_idx[2'(i)];
    end
    for ( int unsigned i = 1'd0; i < 4'( __const__num_routing_outports_at_update_msg ); i += 1'd1 ) begin
      reg_file__wdata[1'd0].routing_xbar_outport[4'(i)] = 4'd0;
      reg_file__wdata[1'd0].fu_xbar_outport[4'(i)] = 2'd0;
    end
    reg_file__wdata[1'd0].vector_factor_power = recv_pkt_from_controller_queue__send__msg.payload.ctrl.vector_factor_power;
    reg_file__wdata[1'd0].is_last_ctrl = 1'd0;
    if ( recv_pkt_from_controller_queue__send__val & ( recv_pkt_from_controller_queue__send__msg.payload.cmd == 5'( __const__CMD_CONFIG ) ) ) begin
      reg_file__wen[1'd0] = 1'd1;
      reg_file__waddr[1'd0] = recv_pkt_from_controller_queue__send__msg.payload.ctrl_addr;
      reg_file__wdata[1'd0].operation = recv_pkt_from_controller_queue__send__msg.payload.ctrl.operation;
      for ( int unsigned i = 1'd0; i < 3'( __const__num_fu_inports_at_update_msg ); i += 1'd1 ) begin
        reg_file__wdata[1'd0].fu_in[2'(i)] = recv_pkt_from_controller_queue__send__msg.payload.ctrl.fu_in[2'(i)];
        reg_file__wdata[1'd0].write_reg_from[2'(i)] = recv_pkt_from_controller_queue__send__msg.payload.ctrl.write_reg_from[2'(i)];
        reg_file__wdata[1'd0].write_reg_idx[2'(i)] = recv_pkt_from_controller_queue__send__msg.payload.ctrl.write_reg_idx[2'(i)];
        reg_file__wdata[1'd0].read_reg_from[2'(i)] = recv_pkt_from_controller_queue__send__msg.payload.ctrl.read_reg_from[2'(i)];
        reg_file__wdata[1'd0].read_reg_idx[2'(i)] = recv_pkt_from_controller_queue__send__msg.payload.ctrl.read_reg_idx[2'(i)];
      end
      for ( int unsigned i = 1'd0; i < 4'( __const__num_routing_outports_at_update_msg ); i += 1'd1 ) begin
        reg_file__wdata[1'd0].routing_xbar_outport[4'(i)] = recv_pkt_from_controller_queue__send__msg.payload.ctrl.routing_xbar_outport[4'(i)];
        reg_file__wdata[1'd0].fu_xbar_outport[4'(i)] = recv_pkt_from_controller_queue__send__msg.payload.ctrl.fu_xbar_outport[4'(i)];
      end
      reg_file__wdata[1'd0].vector_factor_power = recv_pkt_from_controller_queue__send__msg.payload.ctrl.vector_factor_power;
      reg_file__wdata[1'd0].is_last_ctrl = recv_pkt_from_controller_queue__send__msg.payload.ctrl.is_last_ctrl;
    end
    else if ( recv_pkt_from_controller_queue__send__val & ( ( ( ( ( ( ( recv_pkt_from_controller_queue__send__msg.payload.cmd == 5'( __const__CMD_GLOBAL_REDUCE_ADD_RESPONSE ) ) | ( recv_pkt_from_controller_queue__send__msg.payload.cmd == 5'( __const__CMD_GLOBAL_REDUCE_MUL_RESPONSE ) ) ) | ( recv_pkt_from_controller_queue__send__msg.payload.cmd == 5'( __const__CMD_CONFIG_LOOP_LOWER ) ) ) | ( recv_pkt_from_controller_queue__send__msg.payload.cmd == 5'( __const__CMD_CONFIG_LOOP_UPPER ) ) ) | ( recv_pkt_from_controller_queue__send__msg.payload.cmd == 5'( __const__CMD_CONFIG_LOOP_STEP ) ) ) | ( recv_pkt_from_controller_queue__send__msg.payload.cmd == 5'( __const__CMD_UPDATE_COUNTER_SHADOW_VALUE ) ) ) | ( recv_pkt_from_controller_queue__send__msg.payload.cmd == 5'( __const__CMD_RESET_LEAF_COUNTER ) ) ) ) begin
      send_to_element__msg = recv_pkt_from_controller_queue__send__msg.payload;
      send_to_element__val = 1'd1;
    end
    if ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( recv_pkt_from_controller_queue__send__msg.payload.cmd == 5'( __const__CMD_CONFIG ) ) | ( recv_pkt_from_controller_queue__send__msg.payload.cmd == 5'( __const__CMD_CONFIG_PROLOGUE_FU ) ) ) | ( recv_pkt_from_controller_queue__send__msg.payload.cmd == 5'( __const__CMD_CONFIG_PROLOGUE_FU_CROSSBAR ) ) ) | ( recv_pkt_from_controller_queue__send__msg.payload.cmd == 5'( __const__CMD_CONFIG_PROLOGUE_ROUTING_CROSSBAR ) ) ) | ( recv_pkt_from_controller_queue__send__msg.payload.cmd == 5'( __const__CMD_LAUNCH ) ) ) | ( recv_pkt_from_controller_queue__send__msg.payload.cmd == 5'( __const__CMD_TERMINATE ) ) ) | ( recv_pkt_from_controller_queue__send__msg.payload.cmd == 5'( __const__CMD_PAUSE ) ) ) | ( recv_pkt_from_controller_queue__send__msg.payload.cmd == 5'( __const__CMD_PRESERVE ) ) ) | ( recv_pkt_from_controller_queue__send__msg.payload.cmd == 5'( __const__CMD_RESUME ) ) ) | ( recv_pkt_from_controller_queue__send__msg.payload.cmd == 5'( __const__CMD_CONFIG_TOTAL_CTRL_COUNT ) ) ) | ( recv_pkt_from_controller_queue__send__msg.payload.cmd == 5'( __const__CMD_CONFIG_COUNT_PER_ITER ) ) ) | ( recv_pkt_from_controller_queue__send__msg.payload.cmd == 5'( __const__CMD_CONFIG_CTRL_LOWER_BOUND ) ) ) | ( recv_pkt_from_controller_queue__send__msg.payload.cmd == 5'( __const__CMD_RECORD_PHI_ADDR ) ) ) | ( recv_pkt_from_controller_queue__send__msg.payload.cmd == 5'( __const__CMD_GLOBAL_REDUCE_ADD_RESPONSE ) ) ) | ( recv_pkt_from_controller_queue__send__msg.payload.cmd == 5'( __const__CMD_CONFIG_STREAMING_LD_START_ADDR ) ) ) | ( recv_pkt_from_controller_queue__send__msg.payload.cmd == 5'( __const__CMD_CONFIG_STREAMING_LD_STRIDE ) ) ) | ( recv_pkt_from_controller_queue__send__msg.payload.cmd == 5'( __const__CMD_CONFIG_STREAMING_LD_END_ADDR ) ) ) | ( recv_pkt_from_controller_queue__send__msg.payload.cmd == 5'( __const__CMD_GLOBAL_REDUCE_MUL_RESPONSE ) ) ) | ( recv_pkt_from_controller_queue__send__msg.payload.cmd == 5'( __const__CMD_CONFIG_LOOP_LOWER ) ) ) | ( recv_pkt_from_controller_queue__send__msg.payload.cmd == 5'( __const__CMD_CONFIG_LOOP_UPPER ) ) ) | ( recv_pkt_from_controller_queue__send__msg.payload.cmd == 5'( __const__CMD_CONFIG_LOOP_STEP ) ) ) | ( recv_pkt_from_controller_queue__send__msg.payload.cmd == 5'( __const__CMD_UPDATE_COUNTER_SHADOW_VALUE ) ) ) | ( recv_pkt_from_controller_queue__send__msg.payload.cmd == 5'( __const__CMD_RESET_LEAF_COUNTER ) ) ) begin
      recv_pkt_from_controller_queue__send__rdy = 1'd1;
    end
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/mem/ctrl/CtrlMemDynamicRTL.py:268
  // @update
  // def update_prologue_outport():
  //   s.prologue_count_outport_fu @= s.prologue_count_reg_fu[s.reg_file.raddr[0]]
  //   for addr in range(ctrl_mem_size):
  //     for i in range(num_tile_inports):
  //       s.prologue_count_outport_routing_crossbar[addr][i] @= \
  //           s.prologue_count_reg_routing_crossbar[addr][i]
  //     for i in range(num_fu_outports):
  //       s.prologue_count_outport_fu_crossbar[addr][i] @= \
  //           s.prologue_count_reg_fu_crossbar[addr][i]
  
  always_comb begin : update_prologue_outport
    prologue_count_outport_fu = prologue_count_reg_fu[reg_file__raddr[1'd0]];
    for ( int unsigned addr = 1'd0; addr < 4'( __const__ctrl_mem_size_at_update_prologue_outport ); addr += 1'd1 ) begin
      for ( int unsigned i = 1'd0; i < 4'( __const__num_tile_inports_at_update_prologue_outport ); i += 1'd1 )
        prologue_count_outport_routing_crossbar[3'(addr)][3'(i)] = prologue_count_reg_routing_crossbar[3'(addr)][3'(i)];
      for ( int unsigned i = 1'd0; i < 2'( __const__num_fu_outports_at_update_prologue_outport ); i += 1'd1 )
        prologue_count_outport_fu_crossbar[3'(addr)][1'(i)] = prologue_count_reg_fu_crossbar[3'(addr)][1'(i)];
    end
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/mem/ctrl/CtrlMemDynamicRTL.py:194
  // @update
  // def update_send_ctrl():
  //   s.send_ctrl.val @= 0
  //   if s.start_iterate_ctrl == b1(1):
  //     if s.sent_complete:
  //       s.send_ctrl.val @= 0
  //     elif ((s.total_ctrl_steps_val > 0) & (s.times == s.total_ctrl_steps_val)) | \
  //        (s.reg_file.rdata[0].operation == OPT_START):
  //       s.send_ctrl.val @= b1(0)
  //     else:
  //       s.send_ctrl.val @= 1
  //   if s.recv_pkt_from_controller_queue.send.val & \
  //       (s.recv_pkt_from_controller_queue.send.msg.payload.cmd == CMD_TERMINATE):
  //     s.send_ctrl.val @= b1(0)
  
  always_comb begin : update_send_ctrl
    send_ctrl__val = 1'd0;
    if ( start_iterate_ctrl == 1'd1 ) begin
      if ( sent_complete ) begin
        send_ctrl__val = 1'd0;
      end
      else if ( ( ( total_ctrl_steps_val > 11'd0 ) & ( times == total_ctrl_steps_val ) ) | ( reg_file__rdata[1'd0].operation == 7'( __const__OPT_START ) ) ) begin
        send_ctrl__val = 1'd0;
      end
      else
        send_ctrl__val = 1'd1;
    end
    if ( recv_pkt_from_controller_queue__send__val & ( recv_pkt_from_controller_queue__send__msg.payload.cmd == 5'( __const__CMD_TERMINATE ) ) ) begin
      send_ctrl__val = 1'd0;
    end
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/mem/ctrl/CtrlMemDynamicRTL.py:174
  // @update
  // def update_send_pkt_to_controller():
  //   s.send_pkt_to_controller.val @= 0
  //   s.send_pkt_to_controller.msg @= IntraCgraPktType(0, num_tiles, 0, 0, 0, 0, 0, 0, 0, 0, CgraPayloadType(CMD_COMPLETE, 0, 0, 0, 0))
  //   s.recv_from_element_queue.send.rdy @= 0
  //   if s.start_iterate_ctrl == b1(1):
  //     if s.recv_from_element_queue.send.val & (~s.sent_complete):
  //       s.send_pkt_to_controller.msg @= \
  //           IntraCgraPktType(s.tile_id, num_tiles, 0, 0, 0, 0, 0, 0, 0, 0,
  //                            s.recv_from_element_queue.send.msg)
  //       s.send_pkt_to_controller.val @= 1
  //       s.recv_from_element_queue.send.rdy @= s.send_pkt_to_controller.rdy
  //     elif ((s.total_ctrl_steps_val > 0) & (s.times == s.total_ctrl_steps_val)) | \
  //        (s.reg_file.rdata[0].operation == OPT_START):
  //       # Sends COMPLETE signal to Controller when the last ctrl signal is done.
  //       if ~s.sent_complete & (s.total_ctrl_steps_val > 0) & (s.times == s.total_ctrl_steps_val) & s.start_iterate_ctrl:
  //         s.send_pkt_to_controller.msg @= \
  //             IntraCgraPktType(s.tile_id, num_tiles, 0, 0, 0, 0, 0, 0, 0, 0, CgraPayloadType(CMD_COMPLETE, 0, 0, 0, 0))
  //         s.send_pkt_to_controller.val @= 1
  
  always_comb begin : update_send_pkt_to_controller
    send_pkt_to_controller__val = 1'd0;
    send_pkt_to_controller__msg = { 3'd0, 3'( __const__num_tiles_at_update_send_pkt_to_controller ), 2'd0, 2'd0, 2'd0, 1'd0, 2'd0, 1'd0, 8'd0, 1'd0, { 5'( __const__CMD_COMPLETE ), 35'd0, 9'd0, 139'd0, 3'd0 } };
    recv_from_element_queue__send__rdy = 1'd0;
    if ( start_iterate_ctrl == 1'd1 ) begin
      if ( recv_from_element_queue__send__val & ( ~sent_complete ) ) begin
        send_pkt_to_controller__msg = { tile_id, 3'( __const__num_tiles_at_update_send_pkt_to_controller ), 2'd0, 2'd0, 2'd0, 1'd0, 2'd0, 1'd0, 8'd0, 1'd0, recv_from_element_queue__send__msg };
        send_pkt_to_controller__val = 1'd1;
        recv_from_element_queue__send__rdy = send_pkt_to_controller__rdy;
      end
      else if ( ( ( total_ctrl_steps_val > 11'd0 ) & ( times == total_ctrl_steps_val ) ) | ( reg_file__rdata[1'd0].operation == 7'( __const__OPT_START ) ) ) begin
        if ( ( ( ( ~sent_complete ) & ( total_ctrl_steps_val > 11'd0 ) ) & ( times == total_ctrl_steps_val ) ) & start_iterate_ctrl ) begin
          send_pkt_to_controller__msg = { tile_id, 3'( __const__num_tiles_at_update_send_pkt_to_controller ), 2'd0, 2'd0, 2'd0, 1'd0, 2'd0, 1'd0, 8'd0, 1'd0, { 5'( __const__CMD_COMPLETE ), 35'd0, 9'd0, 139'd0, 3'd0 } };
          send_pkt_to_controller__val = 1'd1;
        end
      end
    end
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/mem/ctrl/CtrlMemDynamicRTL.py:313
  // @update
  // def update_upper_bound():
  //   s.ctrl_count_upper_bound @= zext(s.ctrl_count_lower_bound, UpperBoundType) + zext(s.ctrl_count_per_iter_val, UpperBoundType)
  
  always_comb begin : update_upper_bound
    ctrl_count_upper_bound = { { 1 { 1'b0 } }, ctrl_count_lower_bound } + ctrl_count_per_iter_val;
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/mem/ctrl/CtrlMemDynamicRTL.py:223
  // @update_ff
  // def issue_complete():
  //   if s.reset:
  //     s.sent_complete <<= 0
  //   else:
  //     if s.send_pkt_to_controller.val & \
  //        s.send_pkt_to_controller.rdy & \
  //        (s.send_pkt_to_controller.msg.payload.cmd == CMD_COMPLETE):
  //       s.sent_complete <<= 1
  //     elif s.recv_pkt_from_controller_queue.send.val & ( (s.recv_pkt_from_controller_queue.send.msg.payload.cmd == CMD_LAUNCH) | \
  //             (s.recv_pkt_from_controller_queue.send.msg.payload.cmd == CMD_RESUME) ):
  //       s.sent_complete <<= 0
  
  always_ff @(posedge clk) begin : issue_complete
    if ( reset ) begin
      sent_complete <= 1'd0;
    end
    else if ( ( send_pkt_to_controller__val & send_pkt_to_controller__rdy ) & ( send_pkt_to_controller__msg.payload.cmd == 5'( __const__CMD_COMPLETE ) ) ) begin
      sent_complete <= 1'd1;
    end
    else if ( recv_pkt_from_controller_queue__send__val & ( ( recv_pkt_from_controller_queue__send__msg.payload.cmd == 5'( __const__CMD_LAUNCH ) ) | ( recv_pkt_from_controller_queue__send__msg.payload.cmd == 5'( __const__CMD_RESUME ) ) ) ) begin
      sent_complete <= 1'd0;
    end
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/mem/ctrl/CtrlMemDynamicRTL.py:299
  // @update_ff
  // def update_ctrl_count_per_iter():
  //   if s.reset:
  //     s.ctrl_count_per_iter_val <<= PCType(ctrl_count_per_iter)
  //   elif s.recv_pkt_from_controller_queue.send.val & (s.recv_pkt_from_controller_queue.send.msg.payload.cmd == CMD_CONFIG_COUNT_PER_ITER):
  //     s.ctrl_count_per_iter_val <<= trunc(s.recv_pkt_from_controller_queue.send.msg.payload.data.payload, PCType)
  
  always_ff @(posedge clk) begin : update_ctrl_count_per_iter
    if ( reset ) begin
      ctrl_count_per_iter_val <= 4'd8;
    end
    else if ( recv_pkt_from_controller_queue__send__val & ( recv_pkt_from_controller_queue__send__msg.payload.cmd == 5'( __const__CMD_CONFIG_COUNT_PER_ITER ) ) ) begin
      ctrl_count_per_iter_val <= 4'(recv_pkt_from_controller_queue__send__msg.payload.data.payload);
    end
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/mem/ctrl/CtrlMemDynamicRTL.py:306
  // @update_ff
  // def update_lower_bound():
  //   if s.reset:
  //     s.ctrl_count_lower_bound <<= CtrlAddrType(0)
  //   elif s.recv_pkt_from_controller_queue.send.val & (s.recv_pkt_from_controller_queue.send.msg.payload.cmd == CMD_CONFIG_CTRL_LOWER_BOUND):
  //     s.ctrl_count_lower_bound <<= trunc(s.recv_pkt_from_controller_queue.send.msg.payload.data.payload, CtrlAddrType)
  
  always_ff @(posedge clk) begin : update_lower_bound
    if ( reset ) begin
      ctrl_count_lower_bound <= 3'd0;
    end
    else if ( recv_pkt_from_controller_queue__send__val & ( recv_pkt_from_controller_queue__send__msg.payload.cmd == 5'( __const__CMD_CONFIG_CTRL_LOWER_BOUND ) ) ) begin
      ctrl_count_lower_bound <= 3'(recv_pkt_from_controller_queue__send__msg.payload.data.payload);
    end
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/mem/ctrl/CtrlMemDynamicRTL.py:279
  // @update_ff
  // def update_prologue_reg():
  //   if s.reset:
  //     for addr in range(ctrl_mem_size):
  //       for i in range(num_tile_inports):
  //         s.prologue_count_reg_routing_crossbar[addr][i] <<= 0
  //       for i in range(num_fu_outports):
  //         s.prologue_count_reg_fu_crossbar[addr][i] <<= 0
  //   else:
  //     if s.recv_pkt_from_controller_queue.send.val & \
  //        (s.recv_pkt_from_controller_queue.send.msg.payload.cmd == CMD_CONFIG_PROLOGUE_ROUTING_CROSSBAR):
  //       temp_routing_crossbar_in = s.recv_pkt_from_controller_queue.send.msg.payload.ctrl.routing_xbar_outport[0]
  //       # Subtract 1 to convert from TileInType(1-8) to array index (0-7), consistent with normal crossbar routing
  //       if temp_routing_crossbar_in > 0:
  //         s.prologue_count_reg_routing_crossbar[s.recv_pkt_from_controller_queue.send.msg.payload.ctrl_addr][trunc(temp_routing_crossbar_in - 1, TileInPortType)] <<= trunc(s.recv_pkt_from_controller_queue.send.msg.payload.data.payload, PrologueCountType)
  //     elif s.recv_pkt_from_controller_queue.send.val & \
  //        (s.recv_pkt_from_controller_queue.send.msg.payload.cmd == CMD_CONFIG_PROLOGUE_FU_CROSSBAR):
  //       temp_fu_crossbar_in = s.recv_pkt_from_controller_queue.send.msg.payload.ctrl.fu_xbar_outport[0]
  //       s.prologue_count_reg_fu_crossbar[s.recv_pkt_from_controller_queue.send.msg.payload.ctrl_addr][trunc(temp_fu_crossbar_in, FuOutPortType)] <<= trunc(s.recv_pkt_from_controller_queue.send.msg.payload.data.payload, PrologueCountType)
  
  always_ff @(posedge clk) begin : update_prologue_reg
    if ( reset ) begin
      for ( int unsigned addr = 1'd0; addr < 4'( __const__ctrl_mem_size_at_update_prologue_reg ); addr += 1'd1 ) begin
        for ( int unsigned i = 1'd0; i < 4'( __const__num_tile_inports_at_update_prologue_reg ); i += 1'd1 )
          prologue_count_reg_routing_crossbar[3'(addr)][3'(i)] <= 3'd0;
        for ( int unsigned i = 1'd0; i < 2'( __const__num_fu_outports_at_update_prologue_reg ); i += 1'd1 )
          prologue_count_reg_fu_crossbar[3'(addr)][1'(i)] <= 3'd0;
      end
    end
    else if ( recv_pkt_from_controller_queue__send__val & ( recv_pkt_from_controller_queue__send__msg.payload.cmd == 5'( __const__CMD_CONFIG_PROLOGUE_ROUTING_CROSSBAR ) ) ) begin
      __tmpvar__update_prologue_reg_temp_routing_crossbar_in = recv_pkt_from_controller_queue__send__msg.payload.ctrl.routing_xbar_outport[4'd0];
      if ( __tmpvar__update_prologue_reg_temp_routing_crossbar_in > 4'd0 ) begin
        prologue_count_reg_routing_crossbar[recv_pkt_from_controller_queue__send__msg.payload.ctrl_addr][3'(__tmpvar__update_prologue_reg_temp_routing_crossbar_in - 4'd1)] <= 3'(recv_pkt_from_controller_queue__send__msg.payload.data.payload);
      end
    end
    else if ( recv_pkt_from_controller_queue__send__val & ( recv_pkt_from_controller_queue__send__msg.payload.cmd == 5'( __const__CMD_CONFIG_PROLOGUE_FU_CROSSBAR ) ) ) begin
      __tmpvar__update_prologue_reg_temp_fu_crossbar_in = recv_pkt_from_controller_queue__send__msg.payload.ctrl.fu_xbar_outport[4'd0];
      prologue_count_reg_fu_crossbar[recv_pkt_from_controller_queue__send__msg.payload.ctrl_addr][1'(__tmpvar__update_prologue_reg_temp_fu_crossbar_in)] <= 3'(recv_pkt_from_controller_queue__send__msg.payload.data.payload);
    end
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/mem/ctrl/CtrlMemDynamicRTL.py:236
  // @update_ff
  // def update_raddr_and_fu_prologue():
  //   if s.reset:
  //     s.times <<= 0
  //     s.reg_file.raddr[0] <<= 0
  //     for i in range(ctrl_mem_size):
  //       s.prologue_count_reg_fu[i] <<= 0
  //   elif s.recv_pkt_from_controller_queue.send.val & (s.recv_pkt_from_controller_queue.send.msg.payload.cmd == CMD_CONFIG_CTRL_LOWER_BOUND):
  //     s.reg_file.raddr[0] <<= trunc(s.recv_pkt_from_controller_queue.send.msg.payload.data.payload, CtrlAddrType)
  //   elif s.recv_pkt_from_controller_queue.send.val & (s.recv_pkt_from_controller_queue.send.msg.payload.cmd == CMD_TERMINATE):
  //     s.times <<= TimeType(0)
  //   else:
  //     if s.recv_pkt_from_controller_queue.send.val & \
  //        (s.recv_pkt_from_controller_queue.send.msg.payload.cmd == CMD_CONFIG_PROLOGUE_FU):
  //       s.prologue_count_reg_fu[s.recv_pkt_from_controller_queue.send.msg.payload.ctrl_addr] <<= \
  //           trunc(s.recv_pkt_from_controller_queue.send.msg.payload.data.payload, PrologueCountType)
  // 
  //     if s.start_iterate_ctrl == b1(1):
  //       if ((s.total_ctrl_steps_val == 0) | \
  //           (s.times < s.total_ctrl_steps_val)) & \
  //          s.send_ctrl.rdy & s.send_ctrl.val:
  //         s.times <<= s.times + TimeType(1)
  // 
  //       # Reads the next ctrl signal only when the current one is done.
  //       if s.send_ctrl.rdy & s.send_ctrl.val:
  //         if zext(s.reg_file.raddr[0], UpperBoundType) == s.ctrl_count_upper_bound - UpperBoundType(1):
  //           s.reg_file.raddr[0] <<= s.ctrl_count_lower_bound
  //         else:
  //           s.reg_file.raddr[0] <<= s.reg_file.raddr[0] + CtrlAddrType(1)
  //         if s.prologue_count_reg_fu[s.reg_file.raddr[0]] > 0:
  //           s.prologue_count_reg_fu[s.reg_file.raddr[0]] <<= s.prologue_count_reg_fu[s.reg_file.raddr[0]] - 1
  
  always_ff @(posedge clk) begin : update_raddr_and_fu_prologue
    if ( reset ) begin
      times <= 11'd0;
      reg_file__raddr[1'd0] <= 3'd0;
      for ( int unsigned i = 1'd0; i < 4'( __const__ctrl_mem_size_at_update_raddr_and_fu_prologue ); i += 1'd1 )
        prologue_count_reg_fu[3'(i)] <= 3'd0;
    end
    else if ( recv_pkt_from_controller_queue__send__val & ( recv_pkt_from_controller_queue__send__msg.payload.cmd == 5'( __const__CMD_CONFIG_CTRL_LOWER_BOUND ) ) ) begin
      reg_file__raddr[1'd0] <= 3'(recv_pkt_from_controller_queue__send__msg.payload.data.payload);
    end
    else if ( recv_pkt_from_controller_queue__send__val & ( recv_pkt_from_controller_queue__send__msg.payload.cmd == 5'( __const__CMD_TERMINATE ) ) ) begin
      times <= 11'd0;
    end
    else begin
      if ( recv_pkt_from_controller_queue__send__val & ( recv_pkt_from_controller_queue__send__msg.payload.cmd == 5'( __const__CMD_CONFIG_PROLOGUE_FU ) ) ) begin
        prologue_count_reg_fu[recv_pkt_from_controller_queue__send__msg.payload.ctrl_addr] <= 3'(recv_pkt_from_controller_queue__send__msg.payload.data.payload);
      end
      if ( start_iterate_ctrl == 1'd1 ) begin
        if ( ( ( ( total_ctrl_steps_val == 11'd0 ) | ( times < total_ctrl_steps_val ) ) & send_ctrl__rdy ) & send_ctrl__val ) begin
          times <= times + 11'd1;
        end
        if ( send_ctrl__rdy & send_ctrl__val ) begin
          if ( { { 1 { 1'b0 } }, reg_file__raddr[1'd0] } == ( ctrl_count_upper_bound - 4'd1 ) ) begin
            reg_file__raddr[1'd0] <= ctrl_count_lower_bound;
          end
          else
            reg_file__raddr[1'd0] <= reg_file__raddr[1'd0] + 3'd1;
          if ( prologue_count_reg_fu[reg_file__raddr[1'd0]] > 3'd0 ) begin
            prologue_count_reg_fu[reg_file__raddr[1'd0]] <= prologue_count_reg_fu[reg_file__raddr[1'd0]] - 3'd1;
          end
        end
      end
    end
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/mem/ctrl/CtrlMemDynamicRTL.py:317
  // @update_ff
  // def update_total_ctrl_steps():
  //   if s.reset:
  //     s.total_ctrl_steps_val <<= TimeType(total_ctrl_steps)
  //   elif s.recv_pkt_from_controller_queue.send.val & (s.recv_pkt_from_controller_queue.send.msg.payload.cmd == CMD_CONFIG_TOTAL_CTRL_COUNT):
  //     s.total_ctrl_steps_val <<= trunc(s.recv_pkt_from_controller_queue.send.msg.payload.data.payload, TimeType)
  
  always_ff @(posedge clk) begin : update_total_ctrl_steps
    if ( reset ) begin
      total_ctrl_steps_val <= 11'd8;
    end
    else if ( recv_pkt_from_controller_queue__send__val & ( recv_pkt_from_controller_queue__send__msg.payload.cmd == 5'( __const__CMD_CONFIG_TOTAL_CTRL_COUNT ) ) ) begin
      total_ctrl_steps_val <= 11'(recv_pkt_from_controller_queue__send__msg.payload.data.payload);
    end
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/mem/ctrl/CtrlMemDynamicRTL.py:209
  // @update_ff
  // def update_whether_we_can_iterate_ctrl():
  //   if s.reset:
  //     s.start_iterate_ctrl <<= 0
  //   else:
  //     if s.recv_pkt_from_controller_queue.send.val:
  //       if (s.recv_pkt_from_controller_queue.send.msg.payload.cmd == CMD_LAUNCH) | \
  //               (s.recv_pkt_from_controller_queue.send.msg.payload.cmd == CMD_RESUME):
  //         s.start_iterate_ctrl <<= 1
  // # TODO: issue #191, stop iterate ctrl after 10 cycels during pausing status, 
  // # so as to clear channels safely.
  //       elif s.recv_pkt_from_controller_queue.send.msg.payload.cmd == CMD_TERMINATE:
  //         s.start_iterate_ctrl <<= 0
  
  always_ff @(posedge clk) begin : update_whether_we_can_iterate_ctrl
    if ( reset ) begin
      start_iterate_ctrl <= 1'd0;
    end
    else if ( recv_pkt_from_controller_queue__send__val ) begin
      if ( ( recv_pkt_from_controller_queue__send__msg.payload.cmd == 5'( __const__CMD_LAUNCH ) ) | ( recv_pkt_from_controller_queue__send__msg.payload.cmd == 5'( __const__CMD_RESUME ) ) ) begin
        start_iterate_ctrl <= 1'd1;
      end
      else if ( recv_pkt_from_controller_queue__send__msg.payload.cmd == 5'( __const__CMD_TERMINATE ) ) begin
        start_iterate_ctrl <= 1'd0;
      end
    end
  end

  assign reg_file__clk = clk;
  assign reg_file__reset = reset;
  assign recv_pkt_from_controller_queue__clk = clk;
  assign recv_pkt_from_controller_queue__reset = reset;
  assign recv_from_element_queue__clk = clk;
  assign recv_from_element_queue__reset = reset;
  assign send_ctrl__msg = reg_file__rdata[0];
  assign recv_pkt_from_controller_queue__recv__msg = recv_pkt_from_controller__msg;
  assign recv_pkt_from_controller__rdy = recv_pkt_from_controller_queue__recv__rdy;
  assign recv_pkt_from_controller_queue__recv__val = recv_pkt_from_controller__val;
  assign recv_from_element_queue__recv__msg = recv_from_element__msg;
  assign recv_from_element__rdy = recv_from_element_queue__recv__rdy;
  assign recv_from_element_queue__recv__val = recv_from_element__val;

endmodule


// PyMTL Component SelRTL Definition
// Full name: SelRTL__CtrlPktType_IntraCgraPacket_4_4x1_4_8_2_CgraPayload__11cd3f8c0d91825c__num_inports_4__num_outports_2__vector_factor_power_0
// At /cgra/VectorCGRA/fu/single/SelRTL.py

module SelRTL__1a7eacb70e3ca1c4
(
  input  logic [0:0] clear ,
  input  logic [0:0] clk ,
  input  logic [2:0] ctrl_addr_inport ,
  input  logic [0:0] reset ,
  input CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 from_mem_rdata__msg  ,
  output logic [0:0] from_mem_rdata__rdy  ,
  input logic [0:0] from_mem_rdata__val  ,
  input CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 recv_const__msg  ,
  output logic [0:0] recv_const__rdy  ,
  input logic [0:0] recv_const__val  ,
  input MultiCgraPayload_Cmd_Data_DataAddr_Ctrl_CtrlAddr__a0427cd98cfcae6f recv_from_ctrl_mem__msg  ,
  output logic [0:0] recv_from_ctrl_mem__rdy  ,
  input logic [0:0] recv_from_ctrl_mem__val  ,
  input CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 recv_in__msg [0:3] ,
  output logic [0:0] recv_in__rdy [0:3] ,
  input logic [0:0] recv_in__val [0:3] ,
  input CGRAConfig_7_4_2_8_8_3__603a41f5d0e2436f recv_opt__msg  ,
  output logic [0:0] recv_opt__rdy  ,
  input logic [0:0] recv_opt__val  ,
  output CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 send_out__msg [0:1] ,
  input logic [0:0] send_out__rdy [0:1] ,
  output logic [0:0] send_out__val [0:1] ,
  output MultiCgraPayload_Cmd_Data_DataAddr_Ctrl_CtrlAddr__a0427cd98cfcae6f send_to_ctrl_mem__msg  ,
  input logic [0:0] send_to_ctrl_mem__rdy  ,
  output logic [0:0] send_to_ctrl_mem__val  ,
  output logic [8:0] to_mem_raddr__msg  ,
  input logic [0:0] to_mem_raddr__rdy  ,
  output logic [0:0] to_mem_raddr__val  ,
  output logic [8:0] to_mem_waddr__msg  ,
  input logic [0:0] to_mem_waddr__rdy  ,
  output logic [0:0] to_mem_waddr__val  ,
  output CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 to_mem_wdata__msg  ,
  input logic [0:0] to_mem_wdata__rdy  ,
  output logic [0:0] to_mem_wdata__val  
);
  localparam CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 const_zero  = { 32'd0, 1'd0, 1'd0, 1'd0 };
  localparam logic [2:0] __const__num_inports_at_comb_logic  = 3'd4;
  localparam logic [1:0] __const__num_outports_at_comb_logic  = 2'd2;
  localparam logic [6:0] __const__OPT_SEL  = 7'd27;
  logic [2:0] in0;
  logic [1:0] in0_idx;
  logic [2:0] in1;
  logic [1:0] in1_idx;
  logic [2:0] in2;
  logic [1:0] in2_idx;
  logic [0:0] reached_vector_factor;
  logic [0:0] recv_all_val;
  logic [7:0] vector_factor_counter;
  logic [2:0] vector_factor_power;

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/fu/single/SelRTL.py:89
  // @update
  // def comb_logic():
  // 
  //   s.recv_all_val @= 0
  //   # For pick input register, Selector needs at least 3 inputs
  //   s.in0 @= FuInType(0)
  //   s.in1 @= FuInType(0)
  //   s.in2 @= FuInType(0)
  //   for i in range(num_inports):
  //     s.recv_in[i].rdy @= b1(0)
  // 
  //   s.recv_const.rdy @= 0
  //   s.recv_opt.rdy @= s.send_out[0].rdy
  // 
  //   for i in range(num_outports):
  //     s.send_out[i].val @= 0
  //     s.send_out[i].msg @= DataType()
  // 
  //   s.send_to_ctrl_mem.val @= 0
  //   s.send_to_ctrl_mem.msg @= s.CgraPayloadType(0, 0, 0, 0, 0)
  //   s.recv_from_ctrl_mem.rdy @= 0
  // 
  //   if s.recv_opt.val:
  //     if s.recv_opt.msg.fu_in[0] != FuInType(0):
  //       s.in0 @= s.recv_opt.msg.fu_in[0] - FuInType(1)
  //     if s.recv_opt.msg.fu_in[1] != FuInType(0):
  //       s.in1 @= s.recv_opt.msg.fu_in[1] - FuInType(1)
  //     if s.recv_opt.msg.fu_in[2] != FuInType(0):
  //       s.in2 @= s.recv_opt.msg.fu_in[2] - FuInType(1)
  // 
  //   if s.recv_opt.val:
  //     if s.recv_opt.msg.operation == OPT_SEL:
  //       if s.recv_in[s.in0_idx].msg.payload == s.true.payload:
  //         s.send_out[0].msg @= s.recv_in[s.in1_idx].msg
  //       else:
  //         s.send_out[0].msg @= s.recv_in[s.in2_idx].msg
  //       s.send_out[0].msg.predicate @= s.recv_in[s.in0_idx].msg.predicate & \
  //                                      s.recv_in[s.in1_idx].msg.predicate & \
  //                                      s.recv_in[s.in2_idx].msg.predicate & \
  //                                      s.reached_vector_factor
  //       s.recv_all_val @= s.recv_in[s.in0_idx].val & \
  //                         s.recv_in[s.in1_idx].val & \
  //                         s.recv_in[s.in2_idx].val
  //       s.send_out[0].val @= s.recv_all_val
  //       s.recv_in[s.in0_idx].rdy @= s.recv_all_val & s.send_out[0].rdy
  //       s.recv_in[s.in1_idx].rdy @= s.recv_all_val & s.send_out[0].rdy
  //       s.recv_in[s.in2_idx].rdy @= s.recv_all_val & s.send_out[0].rdy
  //       s.recv_opt.rdy @= s.recv_all_val & s.send_out[0].rdy
  //     else:
  //       for j in range(num_outports):
  //         s.send_out[j].val @= b1(0)
  //       s.recv_opt.rdy @= 0
  //       s.recv_in[s.in0_idx].rdy @= 0
  //       s.recv_in[s.in1_idx].rdy @= 0
  //       s.recv_in[s.in2_idx].rdy @= 0
  
  always_comb begin : comb_logic
    recv_all_val = 1'd0;
    in0 = 3'd0;
    in1 = 3'd0;
    in2 = 3'd0;
    for ( int unsigned i = 1'd0; i < 3'( __const__num_inports_at_comb_logic ); i += 1'd1 )
      recv_in__rdy[2'(i)] = 1'd0;
    recv_const__rdy = 1'd0;
    recv_opt__rdy = send_out__rdy[1'd0];
    for ( int unsigned i = 1'd0; i < 2'( __const__num_outports_at_comb_logic ); i += 1'd1 ) begin
      send_out__val[1'(i)] = 1'd0;
      send_out__msg[1'(i)] = { 32'd0, 1'd0, 1'd0, 1'd0 };
    end
    send_to_ctrl_mem__val = 1'd0;
    send_to_ctrl_mem__msg = { 5'd0, 35'd0, 9'd0, 139'd0, 3'd0 };
    recv_from_ctrl_mem__rdy = 1'd0;
    if ( recv_opt__val ) begin
      if ( recv_opt__msg.fu_in[2'd0] != 3'd0 ) begin
        in0 = recv_opt__msg.fu_in[2'd0] - 3'd1;
      end
      if ( recv_opt__msg.fu_in[2'd1] != 3'd0 ) begin
        in1 = recv_opt__msg.fu_in[2'd1] - 3'd1;
      end
      if ( recv_opt__msg.fu_in[2'd2] != 3'd0 ) begin
        in2 = recv_opt__msg.fu_in[2'd2] - 3'd1;
      end
    end
    if ( recv_opt__val ) begin
      if ( recv_opt__msg.operation == 7'( __const__OPT_SEL ) ) begin
        if ( recv_in__msg[in0_idx].payload == 32'd1 ) begin
          send_out__msg[1'd0] = recv_in__msg[in1_idx];
        end
        else
          send_out__msg[1'd0] = recv_in__msg[in2_idx];
        send_out__msg[1'd0].predicate = ( ( recv_in__msg[in0_idx].predicate & recv_in__msg[in1_idx].predicate ) & recv_in__msg[in2_idx].predicate ) & reached_vector_factor;
        recv_all_val = ( recv_in__val[in0_idx] & recv_in__val[in1_idx] ) & recv_in__val[in2_idx];
        send_out__val[1'd0] = recv_all_val;
        recv_in__rdy[in0_idx] = recv_all_val & send_out__rdy[1'd0];
        recv_in__rdy[in1_idx] = recv_all_val & send_out__rdy[1'd0];
        recv_in__rdy[in2_idx] = recv_all_val & send_out__rdy[1'd0];
        recv_opt__rdy = recv_all_val & send_out__rdy[1'd0];
      end
      else begin
        for ( int unsigned j = 1'd0; j < 2'( __const__num_outports_at_comb_logic ); j += 1'd1 )
          send_out__val[1'(j)] = 1'd0;
        recv_opt__rdy = 1'd0;
        recv_in__rdy[in0_idx] = 1'd0;
        recv_in__rdy[in1_idx] = 1'd0;
        recv_in__rdy[in2_idx] = 1'd0;
      end
    end
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/fu/single/SelRTL.py:79
  // @update
  // def update_mem():
  //   s.to_mem_waddr.val @= b1(0)
  //   s.to_mem_wdata.val @= b1(0)
  //   s.to_mem_wdata.msg @= s.const_zero
  //   s.to_mem_waddr.msg @= AddrType(0)
  //   s.to_mem_raddr.msg @= AddrType(0)
  //   s.to_mem_raddr.val @= b1(0)
  //   s.from_mem_rdata.rdy @= b1(0)
  
  always_comb begin : update_mem
    to_mem_waddr__val = 1'd0;
    to_mem_wdata__val = 1'd0;
    to_mem_wdata__msg = const_zero;
    to_mem_waddr__msg = 9'd0;
    to_mem_raddr__msg = 9'd0;
    to_mem_raddr__val = 1'd0;
    from_mem_rdata__rdy = 1'd0;
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/fu/single/SelRTL.py:145
  // @update
  // def update_reached_vector_factor():
  //   s.reached_vector_factor @= 0
  //   if s.recv_opt.val & (s.vector_factor_counter + \
  //                        (VectorFactorType(1) << zext(s.vector_factor_power, VectorFactorType)) >= \
  //                        (VectorFactorType(1) << zext(s.recv_opt.msg.vector_factor_power, VectorFactorType))):
  //     s.reached_vector_factor @= 1
  
  always_comb begin : update_reached_vector_factor
    reached_vector_factor = 1'd0;
    if ( recv_opt__val & ( ( vector_factor_counter + ( 8'd1 << { { 5 { 1'b0 } }, vector_factor_power } ) ) >= ( 8'd1 << { { 5 { 1'b0 } }, recv_opt__msg.vector_factor_power } ) ) ) begin
      reached_vector_factor = 1'd1;
    end
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/fu/single/SelRTL.py:153
  // @update_ff
  // def update_vector_factor_counter():
  //   if s.reset:
  //     s.vector_factor_counter <<= 0
  //   else:
  //     if s.recv_opt.val:
  //       if s.recv_opt.msg.is_last_ctrl & \
  //          (s.vector_factor_counter + \
  //           (VectorFactorType(1) << zext(s.vector_factor_power, VectorFactorType)) < \
  //          (VectorFactorType(1) << zext(s.recv_opt.msg.vector_factor_power, VectorFactorType))):
  //         s.vector_factor_counter <<= s.vector_factor_counter + \
  //                                     (VectorFactorType(1) << zext(s.vector_factor_power, \
  //                                                                  VectorFactorType))
  //       elif s.recv_opt.msg.is_last_ctrl & s.reached_vector_factor:
  //         s.vector_factor_counter <<= 0
  
  always_ff @(posedge clk) begin : update_vector_factor_counter
    if ( reset ) begin
      vector_factor_counter <= 8'd0;
    end
    else if ( recv_opt__val ) begin
      if ( recv_opt__msg.is_last_ctrl & ( ( vector_factor_counter + ( 8'd1 << { { 5 { 1'b0 } }, vector_factor_power } ) ) < ( 8'd1 << { { 5 { 1'b0 } }, recv_opt__msg.vector_factor_power } ) ) ) begin
        vector_factor_counter <= vector_factor_counter + ( 8'd1 << { { 5 { 1'b0 } }, vector_factor_power } );
      end
      else if ( recv_opt__msg.is_last_ctrl & reached_vector_factor ) begin
        vector_factor_counter <= 8'd0;
      end
    end
  end

  assign in0_idx = in0[1:0];
  assign in1_idx = in1[1:0];
  assign in2_idx = in2[1:0];
  assign vector_factor_power = 3'd0;

endmodule


// PyMTL Component CompRTL Definition
// Full name: CompRTL__CtrlPktType_IntraCgraPacket_4_4x1_4_8_2_CgraPayload__11cd3f8c0d91825c__num_inports_4__num_outports_2__vector_factor_power_0
// At /cgra/VectorCGRA/fu/single/CompRTL.py

module CompRTL__1a7eacb70e3ca1c4
(
  input  logic [0:0] clear ,
  input  logic [0:0] clk ,
  input  logic [2:0] ctrl_addr_inport ,
  input  logic [0:0] reset ,
  input CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 from_mem_rdata__msg  ,
  output logic [0:0] from_mem_rdata__rdy  ,
  input logic [0:0] from_mem_rdata__val  ,
  input CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 recv_const__msg  ,
  output logic [0:0] recv_const__rdy  ,
  input logic [0:0] recv_const__val  ,
  input MultiCgraPayload_Cmd_Data_DataAddr_Ctrl_CtrlAddr__a0427cd98cfcae6f recv_from_ctrl_mem__msg  ,
  output logic [0:0] recv_from_ctrl_mem__rdy  ,
  input logic [0:0] recv_from_ctrl_mem__val  ,
  input CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 recv_in__msg [0:3] ,
  output logic [0:0] recv_in__rdy [0:3] ,
  input logic [0:0] recv_in__val [0:3] ,
  input CGRAConfig_7_4_2_8_8_3__603a41f5d0e2436f recv_opt__msg  ,
  output logic [0:0] recv_opt__rdy  ,
  input logic [0:0] recv_opt__val  ,
  output CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 send_out__msg [0:1] ,
  input logic [0:0] send_out__rdy [0:1] ,
  output logic [0:0] send_out__val [0:1] ,
  output MultiCgraPayload_Cmd_Data_DataAddr_Ctrl_CtrlAddr__a0427cd98cfcae6f send_to_ctrl_mem__msg  ,
  input logic [0:0] send_to_ctrl_mem__rdy  ,
  output logic [0:0] send_to_ctrl_mem__val  ,
  output logic [8:0] to_mem_raddr__msg  ,
  input logic [0:0] to_mem_raddr__rdy  ,
  output logic [0:0] to_mem_raddr__val  ,
  output logic [8:0] to_mem_waddr__msg  ,
  input logic [0:0] to_mem_waddr__rdy  ,
  output logic [0:0] to_mem_waddr__val  ,
  output CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 to_mem_wdata__msg  ,
  input logic [0:0] to_mem_wdata__rdy  ,
  output logic [0:0] to_mem_wdata__val  
);
  localparam CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 const_one  = { 32'd1, 1'd0, 1'd0, 1'd0 };
  localparam CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 const_zero  = { 32'd0, 1'd0, 1'd0, 1'd0 };
  localparam logic [6:0] __const__OPT_START  = 7'd0;
  localparam logic [0:0] __const__latency_at_proceed_latency  = 1'd1;
  localparam logic [2:0] __const__num_inports_at_read_reg  = 3'd4;
  localparam logic [1:0] __const__num_outports_at_read_reg  = 2'd2;
  localparam logic [6:0] __const__OPT_EQ  = 7'd14;
  localparam logic [6:0] __const__OPT_NE  = 7'd45;
  localparam logic [6:0] __const__OPT_EQ_CONST  = 7'd33;
  localparam logic [6:0] __const__OPT_NE_CONST  = 7'd46;
  localparam logic [6:0] __const__OPT_LT  = 7'd60;
  logic [2:0] in0;
  logic [1:0] in0_idx;
  logic [2:0] in1;
  logic [1:0] in1_idx;
  logic [0:0] latency;
  logic [0:0] reached_vector_factor;
  logic [0:0] recv_all_val;
  logic [7:0] vector_factor_counter;
  logic [2:0] vector_factor_power;

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/fu/single/CompRTL.py:41
  // @update
  // def read_reg():
  // 
  //   s.recv_all_val @= 0
  //   # For pick input register
  //   s.in0 @= FuInType(0)
  //   s.in1 @= FuInType(0)
  //   for i in range(num_inports):
  //     s.recv_in[i].rdy @= b1(0)
  //   for i in range(num_outports):
  //     s.send_out[i].val @= 0
  //     s.send_out[i].msg @= s.DataType()
  // 
  //   s.recv_const.rdy @= 0
  //   s.recv_opt.rdy @= 0
  // 
  //   s.send_to_ctrl_mem.val @= 0
  //   s.send_to_ctrl_mem.msg @= s.CgraPayloadType(0, 0, 0, 0, 0)
  //   s.recv_from_ctrl_mem.rdy @= 0
  // 
  //   if s.recv_opt.val:
  //     if s.recv_opt.msg.fu_in[0] != FuInType( 0 ):
  //       s.in0 @= s.recv_opt.msg.fu_in[0] - FuInType(1)
  //     if s.recv_opt.msg.fu_in[1] != FuInType(0):
  //       s.in1 @= s.recv_opt.msg.fu_in[1] - FuInType(1)
  // 
  //   if s.recv_opt.val:
  //     if (s.recv_opt.msg.operation == OPT_EQ) | (s.recv_opt.msg.operation == OPT_NE):
  //       if (s.recv_opt.msg.operation == OPT_EQ) & \
  //          (s.recv_in[s.in0_idx].msg.payload == s.recv_in[s.in1_idx].msg.payload):
  //         s.send_out[0].msg @= s.const_one
  //       elif (s.recv_opt.msg.operation == OPT_NE) & \
  //            (s.recv_in[s.in0_idx].msg.payload != s.recv_in[s.in1_idx].msg.payload):
  //         s.send_out[0].msg @= s.const_one
  //       else:
  //         s.send_out[0].msg @= s.const_zero
  //       s.send_out[0].msg.predicate @= s.recv_in[s.in0_idx].msg.predicate & \
  //                                      s.recv_in[s.in1_idx].msg.predicate & \
  //                                      s.reached_vector_factor
  //       s.recv_all_val @= s.recv_in[s.in0_idx].val & s.recv_in[s.in1_idx].val
  //       s.send_out[0].val @= s.recv_all_val
  //       s.recv_in[s.in0_idx].rdy @= s.recv_all_val & s.send_out[0].rdy
  //       s.recv_in[s.in1_idx].rdy @= s.recv_all_val & s.send_out[0].rdy
  //       s.recv_opt.rdy @= s.recv_all_val & s.send_out[0].rdy
  // 
  //     elif (s.recv_opt.msg.operation == OPT_EQ_CONST) | (s.recv_opt.msg.operation == OPT_NE_CONST):
  //       if (s.recv_opt.msg.operation == OPT_EQ_CONST) & \
  //          (s.recv_in[s.in0_idx].msg.payload == s.recv_const.msg.payload):
  //         s.send_out[0].msg @= s.const_one
  //       elif (s.recv_opt.msg.operation == OPT_NE_CONST) & \
  //            (s.recv_in[s.in0_idx].msg.payload != s.recv_const.msg.payload):
  //         s.send_out[0].msg @= s.const_one
  //       else:
  //         s.send_out[0].msg @= s.const_zero
  //       s.send_out[0].msg.predicate @= s.recv_in[s.in0_idx].msg.predicate & \
  //                                      s.reached_vector_factor
  //       s.recv_all_val @= s.recv_in[s.in0_idx].val & s.recv_const.val
  //       s.send_out[0].val @= s.recv_all_val
  //       s.recv_in[s.in0_idx].rdy @= s.recv_all_val & s.send_out[0].rdy
  //       s.recv_const.rdy @= s.recv_all_val & s.send_out[0].rdy
  //       s.recv_opt.rdy @= s.recv_all_val & s.send_out[0].rdy
  // 
  //     elif s.recv_opt.msg.operation == OPT_LT:
  //       if s.recv_in[s.in0_idx].msg.payload < s.recv_in[s.in1_idx].msg.payload:
  //         s.send_out[0].msg @= s.const_one
  //       else:
  //         s.send_out[0].msg @= s.const_zero
  //       s.send_out[0].msg.predicate @= s.recv_in[s.in0_idx].msg.predicate & \
  //                                      s.recv_in[s.in1_idx].msg.predicate & \
  //                                      s.reached_vector_factor
  //       s.recv_all_val @= s.recv_in[s.in0_idx].val & s.recv_in[s.in1_idx].val
  //       s.send_out[0].val @= s.recv_all_val
  //       s.recv_in[s.in0_idx].rdy @= s.recv_all_val & s.send_out[0].rdy
  //       s.recv_in[s.in1_idx].rdy @= s.recv_all_val & s.send_out[0].rdy
  //       s.recv_opt.rdy @= s.recv_all_val & s.send_out[0].rdy
  // 
  //     else:
  //       for j in range(num_outports):
  //         s.send_out[j].val @= b1(0)
  //       s.recv_opt.rdy @= 0
  //       s.recv_in[s.in0_idx].rdy @= 0
  //       s.recv_in[s.in1_idx].rdy @= 0
  
  always_comb begin : read_reg
    recv_all_val = 1'd0;
    in0 = 3'd0;
    in1 = 3'd0;
    for ( int unsigned i = 1'd0; i < 3'( __const__num_inports_at_read_reg ); i += 1'd1 )
      recv_in__rdy[2'(i)] = 1'd0;
    for ( int unsigned i = 1'd0; i < 2'( __const__num_outports_at_read_reg ); i += 1'd1 ) begin
      send_out__val[1'(i)] = 1'd0;
      send_out__msg[1'(i)] = { 32'd0, 1'd0, 1'd0, 1'd0 };
    end
    recv_const__rdy = 1'd0;
    recv_opt__rdy = 1'd0;
    send_to_ctrl_mem__val = 1'd0;
    send_to_ctrl_mem__msg = { 5'd0, 35'd0, 9'd0, 139'd0, 3'd0 };
    recv_from_ctrl_mem__rdy = 1'd0;
    if ( recv_opt__val ) begin
      if ( recv_opt__msg.fu_in[2'd0] != 3'd0 ) begin
        in0 = recv_opt__msg.fu_in[2'd0] - 3'd1;
      end
      if ( recv_opt__msg.fu_in[2'd1] != 3'd0 ) begin
        in1 = recv_opt__msg.fu_in[2'd1] - 3'd1;
      end
    end
    if ( recv_opt__val ) begin
      if ( ( recv_opt__msg.operation == 7'( __const__OPT_EQ ) ) | ( recv_opt__msg.operation == 7'( __const__OPT_NE ) ) ) begin
        if ( ( recv_opt__msg.operation == 7'( __const__OPT_EQ ) ) & ( recv_in__msg[in0_idx].payload == recv_in__msg[in1_idx].payload ) ) begin
          send_out__msg[1'd0] = const_one;
        end
        else if ( ( recv_opt__msg.operation == 7'( __const__OPT_NE ) ) & ( recv_in__msg[in0_idx].payload != recv_in__msg[in1_idx].payload ) ) begin
          send_out__msg[1'd0] = const_one;
        end
        else
          send_out__msg[1'd0] = const_zero;
        send_out__msg[1'd0].predicate = ( recv_in__msg[in0_idx].predicate & recv_in__msg[in1_idx].predicate ) & reached_vector_factor;
        recv_all_val = recv_in__val[in0_idx] & recv_in__val[in1_idx];
        send_out__val[1'd0] = recv_all_val;
        recv_in__rdy[in0_idx] = recv_all_val & send_out__rdy[1'd0];
        recv_in__rdy[in1_idx] = recv_all_val & send_out__rdy[1'd0];
        recv_opt__rdy = recv_all_val & send_out__rdy[1'd0];
      end
      else if ( ( recv_opt__msg.operation == 7'( __const__OPT_EQ_CONST ) ) | ( recv_opt__msg.operation == 7'( __const__OPT_NE_CONST ) ) ) begin
        if ( ( recv_opt__msg.operation == 7'( __const__OPT_EQ_CONST ) ) & ( recv_in__msg[in0_idx].payload == recv_const__msg.payload ) ) begin
          send_out__msg[1'd0] = const_one;
        end
        else if ( ( recv_opt__msg.operation == 7'( __const__OPT_NE_CONST ) ) & ( recv_in__msg[in0_idx].payload != recv_const__msg.payload ) ) begin
          send_out__msg[1'd0] = const_one;
        end
        else
          send_out__msg[1'd0] = const_zero;
        send_out__msg[1'd0].predicate = recv_in__msg[in0_idx].predicate & reached_vector_factor;
        recv_all_val = recv_in__val[in0_idx] & recv_const__val;
        send_out__val[1'd0] = recv_all_val;
        recv_in__rdy[in0_idx] = recv_all_val & send_out__rdy[1'd0];
        recv_const__rdy = recv_all_val & send_out__rdy[1'd0];
        recv_opt__rdy = recv_all_val & send_out__rdy[1'd0];
      end
      else if ( recv_opt__msg.operation == 7'( __const__OPT_LT ) ) begin
        if ( recv_in__msg[in0_idx].payload < recv_in__msg[in1_idx].payload ) begin
          send_out__msg[1'd0] = const_one;
        end
        else
          send_out__msg[1'd0] = const_zero;
        send_out__msg[1'd0].predicate = ( recv_in__msg[in0_idx].predicate & recv_in__msg[in1_idx].predicate ) & reached_vector_factor;
        recv_all_val = recv_in__val[in0_idx] & recv_in__val[in1_idx];
        send_out__val[1'd0] = recv_all_val;
        recv_in__rdy[in0_idx] = recv_all_val & send_out__rdy[1'd0];
        recv_in__rdy[in1_idx] = recv_all_val & send_out__rdy[1'd0];
        recv_opt__rdy = recv_all_val & send_out__rdy[1'd0];
      end
      else begin
        for ( int unsigned j = 1'd0; j < 2'( __const__num_outports_at_read_reg ); j += 1'd1 )
          send_out__val[1'(j)] = 1'd0;
        recv_opt__rdy = 1'd0;
        recv_in__rdy[in0_idx] = 1'd0;
        recv_in__rdy[in1_idx] = 1'd0;
      end
    end
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/fu/basic/Fu.py:68
  // @update
  // def update_mem():
  //   s.to_mem_waddr.val @= b1(0)
  //   s.to_mem_wdata.val @= b1(0)
  //   s.to_mem_wdata.msg @= s.const_zero
  //   s.to_mem_waddr.msg @= s.DataAddrType(0)
  //   s.to_mem_raddr.msg @= s.DataAddrType(0)
  //   s.to_mem_raddr.val @= b1(0)
  //   s.from_mem_rdata.rdy @= b1(0)
  
  always_comb begin : update_mem
    to_mem_waddr__val = 1'd0;
    to_mem_wdata__val = 1'd0;
    to_mem_wdata__msg = const_zero;
    to_mem_waddr__msg = 9'd0;
    to_mem_raddr__msg = 9'd0;
    to_mem_raddr__val = 1'd0;
    from_mem_rdata__rdy = 1'd0;
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/fu/basic/Fu.py:87
  // @update
  // def update_reached_vector_factor():
  //   s.reached_vector_factor @= 0
  //   if s.recv_opt.val & (s.vector_factor_counter + \
  //                        (VectorFactorType(1) << zext(s.vector_factor_power, VectorFactorType)) >= \
  //                        (VectorFactorType(1) << zext(s.recv_opt.msg.vector_factor_power, VectorFactorType))):
  //     s.reached_vector_factor @= 1
  
  always_comb begin : update_reached_vector_factor
    reached_vector_factor = 1'd0;
    if ( recv_opt__val & ( ( vector_factor_counter + ( 8'd1 << { { 5 { 1'b0 } }, vector_factor_power } ) ) >= ( 8'd1 << { { 5 { 1'b0 } }, recv_opt__msg.vector_factor_power } ) ) ) begin
      reached_vector_factor = 1'd1;
    end
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/fu/basic/Fu.py:78
  // @update_ff
  // def proceed_latency():
  //   if s.recv_opt.msg.operation == OPT_START:
  //     s.latency <<= LatencyType(0)
  //   elif s.latency == latency - 1:
  //     s.latency <<= LatencyType(0)
  //   else:
  //     s.latency <<= s.latency + LatencyType(1)
  
  always_ff @(posedge clk) begin : proceed_latency
    if ( recv_opt__msg.operation == 7'( __const__OPT_START ) ) begin
      latency <= 1'd0;
    end
    else if ( latency == ( 1'( __const__latency_at_proceed_latency ) - 1'd1 ) ) begin
      latency <= 1'd0;
    end
    else
      latency <= latency + 1'd1;
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/fu/basic/Fu.py:95
  // @update_ff
  // def update_vector_factor_counter():
  //   if s.reset:
  //     s.vector_factor_counter <<= 0
  //   else:
  //     if s.recv_opt.val:
  //       if s.recv_opt.msg.is_last_ctrl & \
  //          (s.vector_factor_counter + \
  //           (VectorFactorType(1) << zext(s.vector_factor_power, VectorFactorType)) < \
  //           (VectorFactorType(1) << zext(s.recv_opt.msg.vector_factor_power, VectorFactorType))):
  //         s.vector_factor_counter <<= s.vector_factor_counter + \
  //                                     (VectorFactorType(1) << zext(s.vector_factor_power, \
  //                                                                  VectorFactorType))
  //       elif s.recv_opt.msg.is_last_ctrl & s.reached_vector_factor:
  //         s.vector_factor_counter <<= 0
  
  always_ff @(posedge clk) begin : update_vector_factor_counter
    if ( reset ) begin
      vector_factor_counter <= 8'd0;
    end
    else if ( recv_opt__val ) begin
      if ( recv_opt__msg.is_last_ctrl & ( ( vector_factor_counter + ( 8'd1 << { { 5 { 1'b0 } }, vector_factor_power } ) ) < ( 8'd1 << { { 5 { 1'b0 } }, recv_opt__msg.vector_factor_power } ) ) ) begin
        vector_factor_counter <= vector_factor_counter + ( 8'd1 << { { 5 { 1'b0 } }, vector_factor_power } );
      end
      else if ( recv_opt__msg.is_last_ctrl & reached_vector_factor ) begin
        vector_factor_counter <= 8'd0;
      end
    end
  end

  assign vector_factor_power = 3'd0;
  assign in0_idx = in0[1:0];
  assign in1_idx = in1[1:0];

endmodule


// PyMTL Component ShifterRTL Definition
// Full name: ShifterRTL__CtrlPktType_IntraCgraPacket_4_4x1_4_8_2_CgraPayload__11cd3f8c0d91825c__num_inports_4__num_outports_2__vector_factor_power_0
// At /cgra/VectorCGRA/fu/single/ShifterRTL.py

module ShifterRTL__1a7eacb70e3ca1c4
(
  input  logic [0:0] clear ,
  input  logic [0:0] clk ,
  input  logic [2:0] ctrl_addr_inport ,
  input  logic [0:0] reset ,
  input CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 from_mem_rdata__msg  ,
  output logic [0:0] from_mem_rdata__rdy  ,
  input logic [0:0] from_mem_rdata__val  ,
  input CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 recv_const__msg  ,
  output logic [0:0] recv_const__rdy  ,
  input logic [0:0] recv_const__val  ,
  input MultiCgraPayload_Cmd_Data_DataAddr_Ctrl_CtrlAddr__a0427cd98cfcae6f recv_from_ctrl_mem__msg  ,
  output logic [0:0] recv_from_ctrl_mem__rdy  ,
  input logic [0:0] recv_from_ctrl_mem__val  ,
  input CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 recv_in__msg [0:3] ,
  output logic [0:0] recv_in__rdy [0:3] ,
  input logic [0:0] recv_in__val [0:3] ,
  input CGRAConfig_7_4_2_8_8_3__603a41f5d0e2436f recv_opt__msg  ,
  output logic [0:0] recv_opt__rdy  ,
  input logic [0:0] recv_opt__val  ,
  output CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 send_out__msg [0:1] ,
  input logic [0:0] send_out__rdy [0:1] ,
  output logic [0:0] send_out__val [0:1] ,
  output MultiCgraPayload_Cmd_Data_DataAddr_Ctrl_CtrlAddr__a0427cd98cfcae6f send_to_ctrl_mem__msg  ,
  input logic [0:0] send_to_ctrl_mem__rdy  ,
  output logic [0:0] send_to_ctrl_mem__val  ,
  output logic [8:0] to_mem_raddr__msg  ,
  input logic [0:0] to_mem_raddr__rdy  ,
  output logic [0:0] to_mem_raddr__val  ,
  output logic [8:0] to_mem_waddr__msg  ,
  input logic [0:0] to_mem_waddr__rdy  ,
  output logic [0:0] to_mem_waddr__val  ,
  output CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 to_mem_wdata__msg  ,
  input logic [0:0] to_mem_wdata__rdy  ,
  output logic [0:0] to_mem_wdata__val  
);
  localparam CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 const_zero  = { 32'd0, 1'd0, 1'd0, 1'd0 };
  localparam logic [6:0] __const__OPT_START  = 7'd0;
  localparam logic [0:0] __const__latency_at_proceed_latency  = 1'd1;
  localparam logic [2:0] __const__num_inports_at_comb_logic  = 3'd4;
  localparam logic [1:0] __const__num_outports_at_comb_logic  = 2'd2;
  localparam logic [6:0] __const__OPT_LLS  = 7'd5;
  localparam logic [6:0] __const__OPT_LRS  = 7'd6;
  logic [2:0] in0;
  logic [1:0] in0_idx;
  logic [2:0] in1;
  logic [1:0] in1_idx;
  logic [0:0] latency;
  logic [0:0] reached_vector_factor;
  logic [0:0] recv_all_val;
  logic [7:0] vector_factor_counter;
  logic [2:0] vector_factor_power;

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/fu/single/ShifterRTL.py:37
  // @update
  // def comb_logic():
  // 
  //   s.recv_all_val @= 0
  //   # For pick input register
  //   s.in0 @= FuInType(0)
  //   s.in1 @= FuInType(0)
  //   for i in range(num_inports):
  //     s.recv_in[i].rdy @= b1(0)
  //   for i in range(num_outports):
  //     s.send_out[i].val @= 0
  //     s.send_out[i].msg @= s.DataType()
  // 
  //   s.recv_const.rdy @= 0
  //   s.recv_opt.rdy @= 0
  // 
  //   s.send_to_ctrl_mem.val @= 0
  //   s.send_to_ctrl_mem.msg @= s.CgraPayloadType(0, 0, 0, 0, 0)
  //   s.recv_from_ctrl_mem.rdy @= 0
  // 
  //   if s.recv_opt.val:
  //     if s.recv_opt.msg.fu_in[0] != FuInType(0):
  //       s.in0 @= s.recv_opt.msg.fu_in[0] - FuInType(1)
  //     if s.recv_opt.msg.fu_in[1] != FuInType(0):
  //       s.in1 @= s.recv_opt.msg.fu_in[1] - FuInType(1)
  // 
  //   if s.recv_opt.val:
  //     if s.recv_opt.msg.operation == OPT_LLS:
  //       s.send_out[0].msg.payload @= s.recv_in[s.in0_idx].msg.payload << s.recv_in[s.in1_idx].msg.payload
  //       s.send_out[0].msg.predicate @= s.recv_in[s.in0_idx].msg.predicate & \
  //                                      s.recv_in[s.in1_idx].msg.predicate & \
  //                                      s.reached_vector_factor
  //       s.recv_all_val @= s.recv_in[s.in0_idx].val & s.recv_in[s.in1_idx].val
  //       s.send_out[0].val @= s.recv_all_val
  //       s.recv_in[s.in0_idx].rdy @= s.recv_all_val & s.send_out[0].rdy
  //       s.recv_in[s.in1_idx].rdy @= s.recv_all_val & s.send_out[0].rdy
  //       s.recv_opt.rdy @= s.recv_all_val & s.send_out[0].rdy
  // 
  //     elif s.recv_opt.msg.operation == OPT_LRS:
  //       s.send_out[0].msg.payload @= s.recv_in[s.in0_idx].msg.payload >> s.recv_in[s.in1_idx].msg.payload
  //       s.send_out[0].msg.predicate @= s.recv_in[s.in0_idx].msg.predicate & \
  //                                      s.recv_in[s.in1_idx].msg.predicate & \
  //                                      s.reached_vector_factor
  //       s.recv_all_val @= s.recv_in[s.in0_idx].val & s.recv_in[s.in1_idx].val
  //       s.send_out[0].val @= s.recv_all_val
  //       s.recv_in[s.in0_idx].rdy @= s.recv_all_val & s.send_out[0].rdy
  //       s.recv_in[s.in1_idx].rdy @= s.recv_all_val & s.send_out[0].rdy
  //       s.recv_opt.rdy @= s.recv_all_val & s.send_out[0].rdy
  // 
  //     else:
  //       for j in range(num_outports):
  //         s.send_out[j].val @= b1(0)
  //       s.recv_opt.rdy @= 0
  //       s.recv_in[s.in0_idx].rdy @= 0
  //       s.recv_in[s.in1_idx].rdy @= 0
  
  always_comb begin : comb_logic
    recv_all_val = 1'd0;
    in0 = 3'd0;
    in1 = 3'd0;
    for ( int unsigned i = 1'd0; i < 3'( __const__num_inports_at_comb_logic ); i += 1'd1 )
      recv_in__rdy[2'(i)] = 1'd0;
    for ( int unsigned i = 1'd0; i < 2'( __const__num_outports_at_comb_logic ); i += 1'd1 ) begin
      send_out__val[1'(i)] = 1'd0;
      send_out__msg[1'(i)] = { 32'd0, 1'd0, 1'd0, 1'd0 };
    end
    recv_const__rdy = 1'd0;
    recv_opt__rdy = 1'd0;
    send_to_ctrl_mem__val = 1'd0;
    send_to_ctrl_mem__msg = { 5'd0, 35'd0, 9'd0, 139'd0, 3'd0 };
    recv_from_ctrl_mem__rdy = 1'd0;
    if ( recv_opt__val ) begin
      if ( recv_opt__msg.fu_in[2'd0] != 3'd0 ) begin
        in0 = recv_opt__msg.fu_in[2'd0] - 3'd1;
      end
      if ( recv_opt__msg.fu_in[2'd1] != 3'd0 ) begin
        in1 = recv_opt__msg.fu_in[2'd1] - 3'd1;
      end
    end
    if ( recv_opt__val ) begin
      if ( recv_opt__msg.operation == 7'( __const__OPT_LLS ) ) begin
        send_out__msg[1'd0].payload = recv_in__msg[in0_idx].payload << recv_in__msg[in1_idx].payload;
        send_out__msg[1'd0].predicate = ( recv_in__msg[in0_idx].predicate & recv_in__msg[in1_idx].predicate ) & reached_vector_factor;
        recv_all_val = recv_in__val[in0_idx] & recv_in__val[in1_idx];
        send_out__val[1'd0] = recv_all_val;
        recv_in__rdy[in0_idx] = recv_all_val & send_out__rdy[1'd0];
        recv_in__rdy[in1_idx] = recv_all_val & send_out__rdy[1'd0];
        recv_opt__rdy = recv_all_val & send_out__rdy[1'd0];
      end
      else if ( recv_opt__msg.operation == 7'( __const__OPT_LRS ) ) begin
        send_out__msg[1'd0].payload = recv_in__msg[in0_idx].payload >> recv_in__msg[in1_idx].payload;
        send_out__msg[1'd0].predicate = ( recv_in__msg[in0_idx].predicate & recv_in__msg[in1_idx].predicate ) & reached_vector_factor;
        recv_all_val = recv_in__val[in0_idx] & recv_in__val[in1_idx];
        send_out__val[1'd0] = recv_all_val;
        recv_in__rdy[in0_idx] = recv_all_val & send_out__rdy[1'd0];
        recv_in__rdy[in1_idx] = recv_all_val & send_out__rdy[1'd0];
        recv_opt__rdy = recv_all_val & send_out__rdy[1'd0];
      end
      else begin
        for ( int unsigned j = 1'd0; j < 2'( __const__num_outports_at_comb_logic ); j += 1'd1 )
          send_out__val[1'(j)] = 1'd0;
        recv_opt__rdy = 1'd0;
        recv_in__rdy[in0_idx] = 1'd0;
        recv_in__rdy[in1_idx] = 1'd0;
      end
    end
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/fu/basic/Fu.py:68
  // @update
  // def update_mem():
  //   s.to_mem_waddr.val @= b1(0)
  //   s.to_mem_wdata.val @= b1(0)
  //   s.to_mem_wdata.msg @= s.const_zero
  //   s.to_mem_waddr.msg @= s.DataAddrType(0)
  //   s.to_mem_raddr.msg @= s.DataAddrType(0)
  //   s.to_mem_raddr.val @= b1(0)
  //   s.from_mem_rdata.rdy @= b1(0)
  
  always_comb begin : update_mem
    to_mem_waddr__val = 1'd0;
    to_mem_wdata__val = 1'd0;
    to_mem_wdata__msg = const_zero;
    to_mem_waddr__msg = 9'd0;
    to_mem_raddr__msg = 9'd0;
    to_mem_raddr__val = 1'd0;
    from_mem_rdata__rdy = 1'd0;
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/fu/basic/Fu.py:87
  // @update
  // def update_reached_vector_factor():
  //   s.reached_vector_factor @= 0
  //   if s.recv_opt.val & (s.vector_factor_counter + \
  //                        (VectorFactorType(1) << zext(s.vector_factor_power, VectorFactorType)) >= \
  //                        (VectorFactorType(1) << zext(s.recv_opt.msg.vector_factor_power, VectorFactorType))):
  //     s.reached_vector_factor @= 1
  
  always_comb begin : update_reached_vector_factor
    reached_vector_factor = 1'd0;
    if ( recv_opt__val & ( ( vector_factor_counter + ( 8'd1 << { { 5 { 1'b0 } }, vector_factor_power } ) ) >= ( 8'd1 << { { 5 { 1'b0 } }, recv_opt__msg.vector_factor_power } ) ) ) begin
      reached_vector_factor = 1'd1;
    end
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/fu/basic/Fu.py:78
  // @update_ff
  // def proceed_latency():
  //   if s.recv_opt.msg.operation == OPT_START:
  //     s.latency <<= LatencyType(0)
  //   elif s.latency == latency - 1:
  //     s.latency <<= LatencyType(0)
  //   else:
  //     s.latency <<= s.latency + LatencyType(1)
  
  always_ff @(posedge clk) begin : proceed_latency
    if ( recv_opt__msg.operation == 7'( __const__OPT_START ) ) begin
      latency <= 1'd0;
    end
    else if ( latency == ( 1'( __const__latency_at_proceed_latency ) - 1'd1 ) ) begin
      latency <= 1'd0;
    end
    else
      latency <= latency + 1'd1;
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/fu/basic/Fu.py:95
  // @update_ff
  // def update_vector_factor_counter():
  //   if s.reset:
  //     s.vector_factor_counter <<= 0
  //   else:
  //     if s.recv_opt.val:
  //       if s.recv_opt.msg.is_last_ctrl & \
  //          (s.vector_factor_counter + \
  //           (VectorFactorType(1) << zext(s.vector_factor_power, VectorFactorType)) < \
  //           (VectorFactorType(1) << zext(s.recv_opt.msg.vector_factor_power, VectorFactorType))):
  //         s.vector_factor_counter <<= s.vector_factor_counter + \
  //                                     (VectorFactorType(1) << zext(s.vector_factor_power, \
  //                                                                  VectorFactorType))
  //       elif s.recv_opt.msg.is_last_ctrl & s.reached_vector_factor:
  //         s.vector_factor_counter <<= 0
  
  always_ff @(posedge clk) begin : update_vector_factor_counter
    if ( reset ) begin
      vector_factor_counter <= 8'd0;
    end
    else if ( recv_opt__val ) begin
      if ( recv_opt__msg.is_last_ctrl & ( ( vector_factor_counter + ( 8'd1 << { { 5 { 1'b0 } }, vector_factor_power } ) ) < ( 8'd1 << { { 5 { 1'b0 } }, recv_opt__msg.vector_factor_power } ) ) ) begin
        vector_factor_counter <= vector_factor_counter + ( 8'd1 << { { 5 { 1'b0 } }, vector_factor_power } );
      end
      else if ( recv_opt__msg.is_last_ctrl & reached_vector_factor ) begin
        vector_factor_counter <= 8'd0;
      end
    end
  end

  assign vector_factor_power = 3'd0;
  assign in0_idx = in0[1:0];
  assign in1_idx = in1[1:0];

endmodule


// PyMTL Component PhiRTL Definition
// Full name: PhiRTL__CtrlPktType_IntraCgraPacket_4_4x1_4_8_2_CgraPayload__11cd3f8c0d91825c__num_inports_4__num_outports_2__vector_factor_power_0
// At /cgra/VectorCGRA/fu/single/PhiRTL.py

module PhiRTL__1a7eacb70e3ca1c4
(
  input  logic [0:0] clear ,
  input  logic [0:0] clk ,
  input  logic [2:0] ctrl_addr_inport ,
  input  logic [0:0] reset ,
  input CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 from_mem_rdata__msg  ,
  output logic [0:0] from_mem_rdata__rdy  ,
  input logic [0:0] from_mem_rdata__val  ,
  input CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 recv_const__msg  ,
  output logic [0:0] recv_const__rdy  ,
  input logic [0:0] recv_const__val  ,
  input MultiCgraPayload_Cmd_Data_DataAddr_Ctrl_CtrlAddr__a0427cd98cfcae6f recv_from_ctrl_mem__msg  ,
  output logic [0:0] recv_from_ctrl_mem__rdy  ,
  input logic [0:0] recv_from_ctrl_mem__val  ,
  input CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 recv_in__msg [0:3] ,
  output logic [0:0] recv_in__rdy [0:3] ,
  input logic [0:0] recv_in__val [0:3] ,
  input CGRAConfig_7_4_2_8_8_3__603a41f5d0e2436f recv_opt__msg  ,
  output logic [0:0] recv_opt__rdy  ,
  input logic [0:0] recv_opt__val  ,
  output CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 send_out__msg [0:1] ,
  input logic [0:0] send_out__rdy [0:1] ,
  output logic [0:0] send_out__val [0:1] ,
  output MultiCgraPayload_Cmd_Data_DataAddr_Ctrl_CtrlAddr__a0427cd98cfcae6f send_to_ctrl_mem__msg  ,
  input logic [0:0] send_to_ctrl_mem__rdy  ,
  output logic [0:0] send_to_ctrl_mem__val  ,
  output logic [8:0] to_mem_raddr__msg  ,
  input logic [0:0] to_mem_raddr__rdy  ,
  output logic [0:0] to_mem_raddr__val  ,
  output logic [8:0] to_mem_waddr__msg  ,
  input logic [0:0] to_mem_waddr__rdy  ,
  output logic [0:0] to_mem_waddr__val  ,
  output CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 to_mem_wdata__msg  ,
  input logic [0:0] to_mem_wdata__rdy  ,
  output logic [0:0] to_mem_wdata__val  
);
  localparam CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 const_zero  = { 32'd0, 1'd0, 1'd0, 1'd0 };
  localparam logic [6:0] __const__OPT_START  = 7'd0;
  localparam logic [0:0] __const__latency_at_proceed_latency  = 1'd1;
  localparam logic [2:0] __const__num_inports_at_comb_logic  = 3'd4;
  localparam logic [1:0] __const__num_outports_at_comb_logic  = 2'd2;
  localparam logic [6:0] __const__OPT_PHI  = 7'd17;
  localparam logic [6:0] __const__OPT_PHI_START  = 7'd84;
  localparam logic [6:0] __const__OPT_PHI_CONST  = 7'd32;
  logic [0:0] first;
  logic [2:0] in0;
  logic [1:0] in0_idx;
  logic [2:0] in1;
  logic [1:0] in1_idx;
  logic [0:0] latency;
  logic [0:0] reached_vector_factor;
  logic [0:0] recv_all_val;
  logic [7:0] vector_factor_counter;
  logic [2:0] vector_factor_power;

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/fu/single/PhiRTL.py:41
  //    @update
  //    def comb_logic():
  //      s.recv_all_val @= 0
  //      # For pick input register
  //      s.in0 @= 0
  //      s.in1 @= 0
  //      for i in range(num_inports):
  //        s.recv_in[i].rdy @= b1(0)
  //      for i in range(num_outports):
  //        s.send_out[i].val @= 0
  //        s.send_out[i].msg @= s.DataType()
  // 
  //      s.recv_const.rdy @= 0
  //      s.recv_opt.rdy @= 0
  // 
  //      s.send_to_ctrl_mem.val @= 0
  //      s.send_to_ctrl_mem.msg @= s.CgraPayloadType(0, 0, 0, 0, 0)
  //      s.recv_from_ctrl_mem.rdy @= 0
  // 
  //      if s.recv_opt.val:
  //        if s.recv_opt.msg.fu_in[0] != FuInType(0):
  //          s.in0 @= s.recv_opt.msg.fu_in[0] - FuInType(1)
  //        if s.recv_opt.msg.fu_in[1] != FuInType(0):
  //          s.in1 @= s.recv_opt.msg.fu_in[1] - FuInType(1)
  // 
  //      # TODO: decision needs to be made. Adder could be in FU vector width. Or only effective once on the boundary.
  //      # if s.recv_opt.val:
  //      if s.recv_opt.val:
  //        if s.recv_opt.msg.operation == OPT_PHI:
  //          if s.recv_in[s.in0_idx].msg.predicate == Bits1(1):
  //            s.send_out[0].msg.payload @= s.recv_in[s.in0_idx].msg.payload
  //            s.send_out[0].msg.predicate @= s.reached_vector_factor
  //          elif s.recv_in[s.in1_idx].msg.predicate == Bits1(1):
  //            s.send_out[0].msg.payload @= s.recv_in[s.in1_idx].msg.payload
  //            s.send_out[0].msg.predicate @= s.reached_vector_factor
  //          else: # No predecessor is active.
  //            s.send_out[0].msg.payload @= s.recv_in[s.in0_idx].msg.payload
  //            s.send_out[0].msg.predicate @= 0
  //          s.recv_all_val @= s.recv_in[s.in0_idx].val & s.recv_in[s.in1_idx].val
  //          s.send_out[0].val @= s.recv_all_val
  //          s.recv_in[s.in0_idx].rdy @= s.recv_all_val & s.send_out[0].rdy
  //          s.recv_in[s.in1_idx].rdy @= s.recv_all_val & s.send_out[0].rdy
  //          s.recv_opt.rdy @= s.recv_all_val & s.send_out[0].rdy
  // 
  //        elif s.recv_opt.msg.operation == OPT_PHI_START:
  //          if s.first:
  //            s.send_out[0].msg.payload @= s.recv_in[s.in0_idx].msg.payload
  //            s.send_out[0].msg.predicate @= s.reached_vector_factor
  //          elif s.recv_in[s.in0_idx].msg.predicate == Bits1(1):
  //            s.send_out[0].msg.payload @= s.recv_in[s.in0_idx].msg.payload
  //            s.send_out[0].msg.predicate @= s.reached_vector_factor
  //          elif s.recv_in[s.in1_idx].msg.predicate == Bits1(1):
  //            s.send_out[0].msg.payload @= s.recv_in[s.in1_idx].msg.payload
  //            s.send_out[0].msg.predicate @= s.reached_vector_factor
  //          else: # No predecessor is active.
  //            s.send_out[0].msg.payload @= s.recv_in[s.in0_idx].msg.payload
  //            s.send_out[0].msg.predicate @= 0
  //          s.recv_all_val @= ((s.first & s.recv_in[s.in0_idx].val) | \
  //                             (~s.first & s.recv_in[s.in0_idx].val & s.recv_in[s.in1_idx].val))
  //          s.send_out[0].val @= s.recv_all_val
  //          s.recv_in[s.in0_idx].rdy @= s.recv_all_val & s.send_out[0].rdy
  //          s.recv_in[s.in1_idx].rdy @= ~s.first & s.recv_all_val & s.send_out[0].rdy
  //          s.recv_opt.rdy @= s.recv_all_val & s.send_out[0].rdy
  // 
  //        elif s.recv_opt.msg.operation == OPT_PHI_CONST:
  //          if s.first:
  //            s.send_out[0].msg.payload @= s.recv_const.msg.payload
  //          else:
  //            s.send_out[0].msg.payload @= s.recv_in[s.in0_idx].msg.payload
  // 
  //          s.recv_all_val @= ((s.first & s.recv_const.val) | \
  //                             (~s.first & s.recv_in[s.in0_idx].val))
  //          s.send_out[0].val @= s.recv_all_val
  //          s.recv_in[s.in0_idx].rdy @= s.recv_all_val & s.send_out[0].rdy
  //          s.recv_const.rdy @= s.recv_all_val & s.send_out[0].rdy
  //          s.recv_opt.rdy @= s.recv_all_val & s.send_out[0].rdy
  // 
  //          if s.first:
  //            s.send_out[0].msg.predicate @= s.recv_const.msg.predicate & \
  //                                           s.reached_vector_factor
  //          else:
  //            s.send_out[0].msg.predicate @= s.recv_in[s.in0_idx].msg.predicate & \
  //                                           s.reached_vector_factor
  // 
  //        else:
  //          for j in range(num_outports):
  //            s.send_out[j].val @= b1(0)
  //          s.recv_opt.rdy @= 0
  //          s.recv_in[s.in0_idx].rdy @= 0
  //          s.recv_in[s.in1_idx].rdy @= 0
  
  always_comb begin : comb_logic
    recv_all_val = 1'd0;
    in0 = 3'd0;
    in1 = 3'd0;
    for ( int unsigned i = 1'd0; i < 3'( __const__num_inports_at_comb_logic ); i += 1'd1 )
      recv_in__rdy[2'(i)] = 1'd0;
    for ( int unsigned i = 1'd0; i < 2'( __const__num_outports_at_comb_logic ); i += 1'd1 ) begin
      send_out__val[1'(i)] = 1'd0;
      send_out__msg[1'(i)] = { 32'd0, 1'd0, 1'd0, 1'd0 };
    end
    recv_const__rdy = 1'd0;
    recv_opt__rdy = 1'd0;
    send_to_ctrl_mem__val = 1'd0;
    send_to_ctrl_mem__msg = { 5'd0, 35'd0, 9'd0, 139'd0, 3'd0 };
    recv_from_ctrl_mem__rdy = 1'd0;
    if ( recv_opt__val ) begin
      if ( recv_opt__msg.fu_in[2'd0] != 3'd0 ) begin
        in0 = recv_opt__msg.fu_in[2'd0] - 3'd1;
      end
      if ( recv_opt__msg.fu_in[2'd1] != 3'd0 ) begin
        in1 = recv_opt__msg.fu_in[2'd1] - 3'd1;
      end
    end
    if ( recv_opt__val ) begin
      if ( recv_opt__msg.operation == 7'( __const__OPT_PHI ) ) begin
        if ( recv_in__msg[in0_idx].predicate == 1'd1 ) begin
          send_out__msg[1'd0].payload = recv_in__msg[in0_idx].payload;
          send_out__msg[1'd0].predicate = reached_vector_factor;
        end
        else if ( recv_in__msg[in1_idx].predicate == 1'd1 ) begin
          send_out__msg[1'd0].payload = recv_in__msg[in1_idx].payload;
          send_out__msg[1'd0].predicate = reached_vector_factor;
        end
        else begin
          send_out__msg[1'd0].payload = recv_in__msg[in0_idx].payload;
          send_out__msg[1'd0].predicate = 1'd0;
        end
        recv_all_val = recv_in__val[in0_idx] & recv_in__val[in1_idx];
        send_out__val[1'd0] = recv_all_val;
        recv_in__rdy[in0_idx] = recv_all_val & send_out__rdy[1'd0];
        recv_in__rdy[in1_idx] = recv_all_val & send_out__rdy[1'd0];
        recv_opt__rdy = recv_all_val & send_out__rdy[1'd0];
      end
      else if ( recv_opt__msg.operation == 7'( __const__OPT_PHI_START ) ) begin
        if ( first ) begin
          send_out__msg[1'd0].payload = recv_in__msg[in0_idx].payload;
          send_out__msg[1'd0].predicate = reached_vector_factor;
        end
        else if ( recv_in__msg[in0_idx].predicate == 1'd1 ) begin
          send_out__msg[1'd0].payload = recv_in__msg[in0_idx].payload;
          send_out__msg[1'd0].predicate = reached_vector_factor;
        end
        else if ( recv_in__msg[in1_idx].predicate == 1'd1 ) begin
          send_out__msg[1'd0].payload = recv_in__msg[in1_idx].payload;
          send_out__msg[1'd0].predicate = reached_vector_factor;
        end
        else begin
          send_out__msg[1'd0].payload = recv_in__msg[in0_idx].payload;
          send_out__msg[1'd0].predicate = 1'd0;
        end
        recv_all_val = ( first & recv_in__val[in0_idx] ) | ( ( ( ~first ) & recv_in__val[in0_idx] ) & recv_in__val[in1_idx] );
        send_out__val[1'd0] = recv_all_val;
        recv_in__rdy[in0_idx] = recv_all_val & send_out__rdy[1'd0];
        recv_in__rdy[in1_idx] = ( ( ~first ) & recv_all_val ) & send_out__rdy[1'd0];
        recv_opt__rdy = recv_all_val & send_out__rdy[1'd0];
      end
      else if ( recv_opt__msg.operation == 7'( __const__OPT_PHI_CONST ) ) begin
        if ( first ) begin
          send_out__msg[1'd0].payload = recv_const__msg.payload;
        end
        else
          send_out__msg[1'd0].payload = recv_in__msg[in0_idx].payload;
        recv_all_val = ( first & recv_const__val ) | ( ( ~first ) & recv_in__val[in0_idx] );
        send_out__val[1'd0] = recv_all_val;
        recv_in__rdy[in0_idx] = recv_all_val & send_out__rdy[1'd0];
        recv_const__rdy = recv_all_val & send_out__rdy[1'd0];
        recv_opt__rdy = recv_all_val & send_out__rdy[1'd0];
        if ( first ) begin
          send_out__msg[1'd0].predicate = recv_const__msg.predicate & reached_vector_factor;
        end
        else
          send_out__msg[1'd0].predicate = recv_in__msg[in0_idx].predicate & reached_vector_factor;
      end
      else begin
        for ( int unsigned j = 1'd0; j < 2'( __const__num_outports_at_comb_logic ); j += 1'd1 )
          send_out__val[1'(j)] = 1'd0;
        recv_opt__rdy = 1'd0;
        recv_in__rdy[in0_idx] = 1'd0;
        recv_in__rdy[in1_idx] = 1'd0;
      end
    end
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/fu/basic/Fu.py:68
  // @update
  // def update_mem():
  //   s.to_mem_waddr.val @= b1(0)
  //   s.to_mem_wdata.val @= b1(0)
  //   s.to_mem_wdata.msg @= s.const_zero
  //   s.to_mem_waddr.msg @= s.DataAddrType(0)
  //   s.to_mem_raddr.msg @= s.DataAddrType(0)
  //   s.to_mem_raddr.val @= b1(0)
  //   s.from_mem_rdata.rdy @= b1(0)
  
  always_comb begin : update_mem
    to_mem_waddr__val = 1'd0;
    to_mem_wdata__val = 1'd0;
    to_mem_wdata__msg = const_zero;
    to_mem_waddr__msg = 9'd0;
    to_mem_raddr__msg = 9'd0;
    to_mem_raddr__val = 1'd0;
    from_mem_rdata__rdy = 1'd0;
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/fu/basic/Fu.py:87
  // @update
  // def update_reached_vector_factor():
  //   s.reached_vector_factor @= 0
  //   if s.recv_opt.val & (s.vector_factor_counter + \
  //                        (VectorFactorType(1) << zext(s.vector_factor_power, VectorFactorType)) >= \
  //                        (VectorFactorType(1) << zext(s.recv_opt.msg.vector_factor_power, VectorFactorType))):
  //     s.reached_vector_factor @= 1
  
  always_comb begin : update_reached_vector_factor
    reached_vector_factor = 1'd0;
    if ( recv_opt__val & ( ( vector_factor_counter + ( 8'd1 << { { 5 { 1'b0 } }, vector_factor_power } ) ) >= ( 8'd1 << { { 5 { 1'b0 } }, recv_opt__msg.vector_factor_power } ) ) ) begin
      reached_vector_factor = 1'd1;
    end
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/fu/single/PhiRTL.py:134
  // @update_ff
  // def br_start_once():
  //   if s.reset | s.clear:
  //     s.first <<= b1(1)
  //   if ((s.recv_opt.msg.operation == OPT_PHI_CONST) | (s.recv_opt.msg.operation == OPT_PHI_START)) & s.reached_vector_factor:
  //     s.first <<= b1(0)
  
  always_ff @(posedge clk) begin : br_start_once
    if ( reset | clear ) begin
      first <= 1'd1;
    end
    if ( ( ( recv_opt__msg.operation == 7'( __const__OPT_PHI_CONST ) ) | ( recv_opt__msg.operation == 7'( __const__OPT_PHI_START ) ) ) & reached_vector_factor ) begin
      first <= 1'd0;
    end
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/fu/basic/Fu.py:78
  // @update_ff
  // def proceed_latency():
  //   if s.recv_opt.msg.operation == OPT_START:
  //     s.latency <<= LatencyType(0)
  //   elif s.latency == latency - 1:
  //     s.latency <<= LatencyType(0)
  //   else:
  //     s.latency <<= s.latency + LatencyType(1)
  
  always_ff @(posedge clk) begin : proceed_latency
    if ( recv_opt__msg.operation == 7'( __const__OPT_START ) ) begin
      latency <= 1'd0;
    end
    else if ( latency == ( 1'( __const__latency_at_proceed_latency ) - 1'd1 ) ) begin
      latency <= 1'd0;
    end
    else
      latency <= latency + 1'd1;
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/fu/basic/Fu.py:95
  // @update_ff
  // def update_vector_factor_counter():
  //   if s.reset:
  //     s.vector_factor_counter <<= 0
  //   else:
  //     if s.recv_opt.val:
  //       if s.recv_opt.msg.is_last_ctrl & \
  //          (s.vector_factor_counter + \
  //           (VectorFactorType(1) << zext(s.vector_factor_power, VectorFactorType)) < \
  //           (VectorFactorType(1) << zext(s.recv_opt.msg.vector_factor_power, VectorFactorType))):
  //         s.vector_factor_counter <<= s.vector_factor_counter + \
  //                                     (VectorFactorType(1) << zext(s.vector_factor_power, \
  //                                                                  VectorFactorType))
  //       elif s.recv_opt.msg.is_last_ctrl & s.reached_vector_factor:
  //         s.vector_factor_counter <<= 0
  
  always_ff @(posedge clk) begin : update_vector_factor_counter
    if ( reset ) begin
      vector_factor_counter <= 8'd0;
    end
    else if ( recv_opt__val ) begin
      if ( recv_opt__msg.is_last_ctrl & ( ( vector_factor_counter + ( 8'd1 << { { 5 { 1'b0 } }, vector_factor_power } ) ) < ( 8'd1 << { { 5 { 1'b0 } }, recv_opt__msg.vector_factor_power } ) ) ) begin
        vector_factor_counter <= vector_factor_counter + ( 8'd1 << { { 5 { 1'b0 } }, vector_factor_power } );
      end
      else if ( recv_opt__msg.is_last_ctrl & reached_vector_factor ) begin
        vector_factor_counter <= 8'd0;
      end
    end
  end

  assign vector_factor_power = 3'd0;
  assign in0_idx = in0[1:0];
  assign in1_idx = in1[1:0];

endmodule


// PyMTL Component LogicRTL Definition
// Full name: LogicRTL__CtrlPktType_IntraCgraPacket_4_4x1_4_8_2_CgraPayload__11cd3f8c0d91825c__num_inports_4__num_outports_2__vector_factor_power_0
// At /cgra/VectorCGRA/fu/single/LogicRTL.py

module LogicRTL__1a7eacb70e3ca1c4
(
  input  logic [0:0] clear ,
  input  logic [0:0] clk ,
  input  logic [2:0] ctrl_addr_inport ,
  input  logic [0:0] reset ,
  input CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 from_mem_rdata__msg  ,
  output logic [0:0] from_mem_rdata__rdy  ,
  input logic [0:0] from_mem_rdata__val  ,
  input CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 recv_const__msg  ,
  output logic [0:0] recv_const__rdy  ,
  input logic [0:0] recv_const__val  ,
  input MultiCgraPayload_Cmd_Data_DataAddr_Ctrl_CtrlAddr__a0427cd98cfcae6f recv_from_ctrl_mem__msg  ,
  output logic [0:0] recv_from_ctrl_mem__rdy  ,
  input logic [0:0] recv_from_ctrl_mem__val  ,
  input CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 recv_in__msg [0:3] ,
  output logic [0:0] recv_in__rdy [0:3] ,
  input logic [0:0] recv_in__val [0:3] ,
  input CGRAConfig_7_4_2_8_8_3__603a41f5d0e2436f recv_opt__msg  ,
  output logic [0:0] recv_opt__rdy  ,
  input logic [0:0] recv_opt__val  ,
  output CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 send_out__msg [0:1] ,
  input logic [0:0] send_out__rdy [0:1] ,
  output logic [0:0] send_out__val [0:1] ,
  output MultiCgraPayload_Cmd_Data_DataAddr_Ctrl_CtrlAddr__a0427cd98cfcae6f send_to_ctrl_mem__msg  ,
  input logic [0:0] send_to_ctrl_mem__rdy  ,
  output logic [0:0] send_to_ctrl_mem__val  ,
  output logic [8:0] to_mem_raddr__msg  ,
  input logic [0:0] to_mem_raddr__rdy  ,
  output logic [0:0] to_mem_raddr__val  ,
  output logic [8:0] to_mem_waddr__msg  ,
  input logic [0:0] to_mem_waddr__rdy  ,
  output logic [0:0] to_mem_waddr__val  ,
  output CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 to_mem_wdata__msg  ,
  input logic [0:0] to_mem_wdata__rdy  ,
  output logic [0:0] to_mem_wdata__val  
);
  localparam CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 const_zero  = { 32'd0, 1'd0, 1'd0, 1'd0 };
  localparam logic [6:0] __const__OPT_START  = 7'd0;
  localparam logic [0:0] __const__latency_at_proceed_latency  = 1'd1;
  localparam logic [2:0] __const__num_inports_at_comb_logic  = 3'd4;
  localparam logic [1:0] __const__num_outports_at_comb_logic  = 2'd2;
  localparam logic [6:0] __const__OPT_OR  = 7'd8;
  localparam logic [6:0] __const__OPT_AND  = 7'd10;
  localparam logic [6:0] __const__OPT_BIT_NOT  = 7'd43;
  localparam logic [6:0] __const__OPT_NOT  = 7'd11;
  localparam logic [6:0] __const__OPT_XOR  = 7'd9;
  logic [2:0] in0;
  logic [1:0] in0_idx;
  logic [2:0] in1;
  logic [1:0] in1_idx;
  logic [0:0] latency;
  logic [0:0] reached_vector_factor;
  logic [0:0] recv_all_val;
  logic [7:0] vector_factor_counter;
  logic [2:0] vector_factor_power;

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/fu/single/LogicRTL.py:37
  // @update
  // def comb_logic():
  // 
  //   s.recv_all_val @= 0
  //   # For pick input register
  //   s.in0 @= 0
  //   s.in1 @= 0
  //   for i in range(num_inports):
  //     s.recv_in[i].rdy @= b1(0)
  //   for i in range( num_outports ):
  //     s.send_out[i].val @= b1(0)
  //     s.send_out[i].msg @= s.DataType()
  // 
  //   s.recv_const.rdy @= 0
  //   s.recv_opt.rdy @= 0
  // 
  //   s.send_to_ctrl_mem.val @= 0
  //   s.send_to_ctrl_mem.msg @= s.CgraPayloadType(0, 0, 0, 0, 0)
  //   s.recv_from_ctrl_mem.rdy @= 0
  // 
  //   if s.recv_opt.val:
  //     if s.recv_opt.msg.fu_in[0] != FuInType(0):
  //       s.in0 @= s.recv_opt.msg.fu_in[0] - FuInType(1)
  //     if s.recv_opt.msg.fu_in[1] != FuInType(0):
  //       s.in1 @= s.recv_opt.msg.fu_in[1] - FuInType(1)
  // 
  //   if s.recv_opt.val:
  //     if s.recv_opt.msg.operation == OPT_OR:
  //       s.send_out[0].msg.payload @= s.recv_in[s.in0_idx].msg.payload | s.recv_in[s.in1_idx].msg.payload
  //       s.send_out[0].msg.predicate @= s.recv_in[s.in0_idx].msg.predicate & \
  //                                      s.recv_in[s.in1_idx].msg.predicate & \
  //                                      s.reached_vector_factor
  //       s.recv_all_val @= s.recv_in[s.in0_idx].val & s.recv_in[s.in1_idx].val
  //       s.send_out[0].val @= s.recv_all_val
  //       s.recv_in[s.in0_idx].rdy @= s.recv_all_val & s.send_out[0].rdy
  //       s.recv_in[s.in1_idx].rdy @= s.recv_all_val & s.send_out[0].rdy
  //       s.recv_opt.rdy @= s.recv_all_val & s.send_out[0].rdy
  // 
  //     elif s.recv_opt.msg.operation == OPT_AND:
  //       s.send_out[0].msg.payload @= s.recv_in[s.in0_idx].msg.payload & s.recv_in[s.in1_idx].msg.payload
  //       s.send_out[0].msg.predicate @= s.recv_in[s.in0_idx].msg.predicate & \
  //                                      s.recv_in[s.in1_idx].msg.predicate & \
  //                                      s.reached_vector_factor
  //       s.recv_all_val @= s.recv_in[s.in0_idx].val & s.recv_in[s.in1_idx].val
  //       s.send_out[0].val @= s.recv_all_val
  //       s.recv_in[s.in0_idx].rdy @= s.recv_all_val & s.send_out[0].rdy
  //       s.recv_in[s.in1_idx].rdy @= s.recv_all_val & s.send_out[0].rdy
  //       s.recv_opt.rdy @= s.recv_all_val & s.send_out[0].rdy
  // 
  //     elif s.recv_opt.msg.operation == OPT_BIT_NOT:
  //       s.send_out[0].msg.payload @= ~ s.recv_in[s.in0_idx].msg.payload
  //       s.send_out[0].msg.predicate @= s.recv_in[s.in0_idx].msg.predicate & \
  //                                      s.reached_vector_factor
  //       s.recv_all_val @= s.recv_in[s.in0_idx].val
  //       s.send_out[0].val @= s.recv_all_val
  //       s.recv_in[s.in0_idx].rdy @= s.recv_all_val & s.send_out[0].rdy
  //       s.recv_opt.rdy @= s.recv_all_val & s.send_out[0].rdy
  // 
  //     elif s.recv_opt.msg.operation == OPT_NOT:
  //       if s.recv_in[s.in0_idx].msg.payload == 0:
  //         s.send_out[0].msg.payload @= 1
  //       else:
  //         s.send_out[0].msg.payload @= 0
  //       s.send_out[0].msg.predicate @= s.recv_in[s.in0_idx].msg.predicate & \
  //                                      s.reached_vector_factor
  //       s.recv_all_val @= s.recv_in[s.in0_idx].val
  //       s.send_out[0].val @= s.recv_all_val
  //       s.recv_in[s.in0_idx].rdy @= s.recv_all_val & s.send_out[0].rdy
  //       s.recv_opt.rdy @= s.recv_all_val & s.send_out[0].rdy
  // 
  //     elif s.recv_opt.msg.operation == OPT_XOR:
  //       s.send_out[0].msg.payload @= s.recv_in[s.in0_idx].msg.payload ^ s.recv_in[s.in1_idx].msg.payload
  //       s.send_out[0].msg.predicate @= s.recv_in[s.in0_idx].msg.predicate & \
  //                                      s.recv_in[s.in1_idx].msg.predicate & \
  //                                      s.reached_vector_factor
  //       s.recv_all_val @= s.recv_in[s.in0_idx].val & s.recv_in[s.in1_idx].val
  //       s.send_out[0].val @= s.recv_all_val
  //       s.recv_in[s.in0_idx].rdy @= s.recv_all_val & s.send_out[0].rdy
  //       s.recv_in[s.in1_idx].rdy @= s.recv_all_val & s.send_out[0].rdy
  //       s.recv_opt.rdy @= s.recv_all_val & s.send_out[0].rdy
  //     else:
  //       for j in range(num_outports):
  //         s.send_out[j].val @= b1(0)
  //       s.recv_opt.rdy @= 0
  //       s.recv_in[s.in0_idx].rdy @= 0
  //       s.recv_in[s.in1_idx].rdy @= 0
  
  always_comb begin : comb_logic
    recv_all_val = 1'd0;
    in0 = 3'd0;
    in1 = 3'd0;
    for ( int unsigned i = 1'd0; i < 3'( __const__num_inports_at_comb_logic ); i += 1'd1 )
      recv_in__rdy[2'(i)] = 1'd0;
    for ( int unsigned i = 1'd0; i < 2'( __const__num_outports_at_comb_logic ); i += 1'd1 ) begin
      send_out__val[1'(i)] = 1'd0;
      send_out__msg[1'(i)] = { 32'd0, 1'd0, 1'd0, 1'd0 };
    end
    recv_const__rdy = 1'd0;
    recv_opt__rdy = 1'd0;
    send_to_ctrl_mem__val = 1'd0;
    send_to_ctrl_mem__msg = { 5'd0, 35'd0, 9'd0, 139'd0, 3'd0 };
    recv_from_ctrl_mem__rdy = 1'd0;
    if ( recv_opt__val ) begin
      if ( recv_opt__msg.fu_in[2'd0] != 3'd0 ) begin
        in0 = recv_opt__msg.fu_in[2'd0] - 3'd1;
      end
      if ( recv_opt__msg.fu_in[2'd1] != 3'd0 ) begin
        in1 = recv_opt__msg.fu_in[2'd1] - 3'd1;
      end
    end
    if ( recv_opt__val ) begin
      if ( recv_opt__msg.operation == 7'( __const__OPT_OR ) ) begin
        send_out__msg[1'd0].payload = recv_in__msg[in0_idx].payload | recv_in__msg[in1_idx].payload;
        send_out__msg[1'd0].predicate = ( recv_in__msg[in0_idx].predicate & recv_in__msg[in1_idx].predicate ) & reached_vector_factor;
        recv_all_val = recv_in__val[in0_idx] & recv_in__val[in1_idx];
        send_out__val[1'd0] = recv_all_val;
        recv_in__rdy[in0_idx] = recv_all_val & send_out__rdy[1'd0];
        recv_in__rdy[in1_idx] = recv_all_val & send_out__rdy[1'd0];
        recv_opt__rdy = recv_all_val & send_out__rdy[1'd0];
      end
      else if ( recv_opt__msg.operation == 7'( __const__OPT_AND ) ) begin
        send_out__msg[1'd0].payload = recv_in__msg[in0_idx].payload & recv_in__msg[in1_idx].payload;
        send_out__msg[1'd0].predicate = ( recv_in__msg[in0_idx].predicate & recv_in__msg[in1_idx].predicate ) & reached_vector_factor;
        recv_all_val = recv_in__val[in0_idx] & recv_in__val[in1_idx];
        send_out__val[1'd0] = recv_all_val;
        recv_in__rdy[in0_idx] = recv_all_val & send_out__rdy[1'd0];
        recv_in__rdy[in1_idx] = recv_all_val & send_out__rdy[1'd0];
        recv_opt__rdy = recv_all_val & send_out__rdy[1'd0];
      end
      else if ( recv_opt__msg.operation == 7'( __const__OPT_BIT_NOT ) ) begin
        send_out__msg[1'd0].payload = ~recv_in__msg[in0_idx].payload;
        send_out__msg[1'd0].predicate = recv_in__msg[in0_idx].predicate & reached_vector_factor;
        recv_all_val = recv_in__val[in0_idx];
        send_out__val[1'd0] = recv_all_val;
        recv_in__rdy[in0_idx] = recv_all_val & send_out__rdy[1'd0];
        recv_opt__rdy = recv_all_val & send_out__rdy[1'd0];
      end
      else if ( recv_opt__msg.operation == 7'( __const__OPT_NOT ) ) begin
        if ( recv_in__msg[in0_idx].payload == 32'd0 ) begin
          send_out__msg[1'd0].payload = 32'd1;
        end
        else
          send_out__msg[1'd0].payload = 32'd0;
        send_out__msg[1'd0].predicate = recv_in__msg[in0_idx].predicate & reached_vector_factor;
        recv_all_val = recv_in__val[in0_idx];
        send_out__val[1'd0] = recv_all_val;
        recv_in__rdy[in0_idx] = recv_all_val & send_out__rdy[1'd0];
        recv_opt__rdy = recv_all_val & send_out__rdy[1'd0];
      end
      else if ( recv_opt__msg.operation == 7'( __const__OPT_XOR ) ) begin
        send_out__msg[1'd0].payload = recv_in__msg[in0_idx].payload ^ recv_in__msg[in1_idx].payload;
        send_out__msg[1'd0].predicate = ( recv_in__msg[in0_idx].predicate & recv_in__msg[in1_idx].predicate ) & reached_vector_factor;
        recv_all_val = recv_in__val[in0_idx] & recv_in__val[in1_idx];
        send_out__val[1'd0] = recv_all_val;
        recv_in__rdy[in0_idx] = recv_all_val & send_out__rdy[1'd0];
        recv_in__rdy[in1_idx] = recv_all_val & send_out__rdy[1'd0];
        recv_opt__rdy = recv_all_val & send_out__rdy[1'd0];
      end
      else begin
        for ( int unsigned j = 1'd0; j < 2'( __const__num_outports_at_comb_logic ); j += 1'd1 )
          send_out__val[1'(j)] = 1'd0;
        recv_opt__rdy = 1'd0;
        recv_in__rdy[in0_idx] = 1'd0;
        recv_in__rdy[in1_idx] = 1'd0;
      end
    end
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/fu/basic/Fu.py:68
  // @update
  // def update_mem():
  //   s.to_mem_waddr.val @= b1(0)
  //   s.to_mem_wdata.val @= b1(0)
  //   s.to_mem_wdata.msg @= s.const_zero
  //   s.to_mem_waddr.msg @= s.DataAddrType(0)
  //   s.to_mem_raddr.msg @= s.DataAddrType(0)
  //   s.to_mem_raddr.val @= b1(0)
  //   s.from_mem_rdata.rdy @= b1(0)
  
  always_comb begin : update_mem
    to_mem_waddr__val = 1'd0;
    to_mem_wdata__val = 1'd0;
    to_mem_wdata__msg = const_zero;
    to_mem_waddr__msg = 9'd0;
    to_mem_raddr__msg = 9'd0;
    to_mem_raddr__val = 1'd0;
    from_mem_rdata__rdy = 1'd0;
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/fu/basic/Fu.py:87
  // @update
  // def update_reached_vector_factor():
  //   s.reached_vector_factor @= 0
  //   if s.recv_opt.val & (s.vector_factor_counter + \
  //                        (VectorFactorType(1) << zext(s.vector_factor_power, VectorFactorType)) >= \
  //                        (VectorFactorType(1) << zext(s.recv_opt.msg.vector_factor_power, VectorFactorType))):
  //     s.reached_vector_factor @= 1
  
  always_comb begin : update_reached_vector_factor
    reached_vector_factor = 1'd0;
    if ( recv_opt__val & ( ( vector_factor_counter + ( 8'd1 << { { 5 { 1'b0 } }, vector_factor_power } ) ) >= ( 8'd1 << { { 5 { 1'b0 } }, recv_opt__msg.vector_factor_power } ) ) ) begin
      reached_vector_factor = 1'd1;
    end
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/fu/basic/Fu.py:78
  // @update_ff
  // def proceed_latency():
  //   if s.recv_opt.msg.operation == OPT_START:
  //     s.latency <<= LatencyType(0)
  //   elif s.latency == latency - 1:
  //     s.latency <<= LatencyType(0)
  //   else:
  //     s.latency <<= s.latency + LatencyType(1)
  
  always_ff @(posedge clk) begin : proceed_latency
    if ( recv_opt__msg.operation == 7'( __const__OPT_START ) ) begin
      latency <= 1'd0;
    end
    else if ( latency == ( 1'( __const__latency_at_proceed_latency ) - 1'd1 ) ) begin
      latency <= 1'd0;
    end
    else
      latency <= latency + 1'd1;
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/fu/basic/Fu.py:95
  // @update_ff
  // def update_vector_factor_counter():
  //   if s.reset:
  //     s.vector_factor_counter <<= 0
  //   else:
  //     if s.recv_opt.val:
  //       if s.recv_opt.msg.is_last_ctrl & \
  //          (s.vector_factor_counter + \
  //           (VectorFactorType(1) << zext(s.vector_factor_power, VectorFactorType)) < \
  //           (VectorFactorType(1) << zext(s.recv_opt.msg.vector_factor_power, VectorFactorType))):
  //         s.vector_factor_counter <<= s.vector_factor_counter + \
  //                                     (VectorFactorType(1) << zext(s.vector_factor_power, \
  //                                                                  VectorFactorType))
  //       elif s.recv_opt.msg.is_last_ctrl & s.reached_vector_factor:
  //         s.vector_factor_counter <<= 0
  
  always_ff @(posedge clk) begin : update_vector_factor_counter
    if ( reset ) begin
      vector_factor_counter <= 8'd0;
    end
    else if ( recv_opt__val ) begin
      if ( recv_opt__msg.is_last_ctrl & ( ( vector_factor_counter + ( 8'd1 << { { 5 { 1'b0 } }, vector_factor_power } ) ) < ( 8'd1 << { { 5 { 1'b0 } }, recv_opt__msg.vector_factor_power } ) ) ) begin
        vector_factor_counter <= vector_factor_counter + ( 8'd1 << { { 5 { 1'b0 } }, vector_factor_power } );
      end
      else if ( recv_opt__msg.is_last_ctrl & reached_vector_factor ) begin
        vector_factor_counter <= 8'd0;
      end
    end
  end

  assign vector_factor_power = 3'd0;
  assign in0_idx = in0[1:0];
  assign in1_idx = in1[1:0];

endmodule


// PyMTL Component ConstRTL Definition
// Full name: ConstRTL__CtrlPktType_IntraCgraPacket_4_4x1_4_8_2_CgraPayload__11cd3f8c0d91825c__num_inports_4__num_outports_2__vector_factor_power_0
// At /cgra/VectorCGRA/fu/single/ConstRTL.py

module ConstRTL__1a7eacb70e3ca1c4
(
  input  logic [0:0] clear ,
  input  logic [0:0] clk ,
  input  logic [2:0] ctrl_addr_inport ,
  input  logic [0:0] reset ,
  input CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 from_mem_rdata__msg  ,
  output logic [0:0] from_mem_rdata__rdy  ,
  input logic [0:0] from_mem_rdata__val  ,
  input CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 recv_const__msg  ,
  output logic [0:0] recv_const__rdy  ,
  input logic [0:0] recv_const__val  ,
  input MultiCgraPayload_Cmd_Data_DataAddr_Ctrl_CtrlAddr__a0427cd98cfcae6f recv_from_ctrl_mem__msg  ,
  output logic [0:0] recv_from_ctrl_mem__rdy  ,
  input logic [0:0] recv_from_ctrl_mem__val  ,
  input CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 recv_in__msg [0:3] ,
  output logic [0:0] recv_in__rdy [0:3] ,
  input logic [0:0] recv_in__val [0:3] ,
  input CGRAConfig_7_4_2_8_8_3__603a41f5d0e2436f recv_opt__msg  ,
  output logic [0:0] recv_opt__rdy  ,
  input logic [0:0] recv_opt__val  ,
  output CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 send_out__msg [0:1] ,
  input logic [0:0] send_out__rdy [0:1] ,
  output logic [0:0] send_out__val [0:1] ,
  output MultiCgraPayload_Cmd_Data_DataAddr_Ctrl_CtrlAddr__a0427cd98cfcae6f send_to_ctrl_mem__msg  ,
  input logic [0:0] send_to_ctrl_mem__rdy  ,
  output logic [0:0] send_to_ctrl_mem__val  ,
  output logic [8:0] to_mem_raddr__msg  ,
  input logic [0:0] to_mem_raddr__rdy  ,
  output logic [0:0] to_mem_raddr__val  ,
  output logic [8:0] to_mem_waddr__msg  ,
  input logic [0:0] to_mem_waddr__rdy  ,
  output logic [0:0] to_mem_waddr__val  ,
  output CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 to_mem_wdata__msg  ,
  input logic [0:0] to_mem_wdata__rdy  ,
  output logic [0:0] to_mem_wdata__val  
);
  localparam CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 const_zero  = { 32'd0, 1'd0, 1'd0, 1'd0 };
  localparam logic [6:0] __const__OPT_START  = 7'd0;
  localparam logic [0:0] __const__latency_at_proceed_latency  = 1'd1;
  localparam logic [2:0] __const__num_inports_at_comb_logic  = 3'd4;
  localparam logic [1:0] __const__num_outports_at_comb_logic  = 2'd2;
  localparam logic [6:0] __const__OPT_CONST  = 7'd80;
  logic [0:0] latency;
  logic [0:0] reached_vector_factor;
  logic [0:0] recv_all_val;
  logic [7:0] vector_factor_counter;
  logic [2:0] vector_factor_power;

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/fu/single/ConstRTL.py:27
  // @update
  // def comb_logic():
  // 
  //   s.recv_all_val @= 0
  //   for i in range(num_inports):
  //     s.recv_in[i].rdy @= b1(0)
  //   for i in range( num_outports ):
  //     s.send_out[i].val @= b1(0)
  //     s.send_out[i].msg @= s.DataType()
  // 
  //   s.recv_const.rdy @= 0
  //   s.recv_opt.rdy @= 0
  // 
  //   s.send_to_ctrl_mem.val @= 0
  //   s.send_to_ctrl_mem.msg @= s.CgraPayloadType(0, 0, 0, 0, 0)
  //   s.recv_from_ctrl_mem.rdy @= 0
  // 
  //   if s.recv_opt.val:
  //     if s.recv_opt.msg.operation == OPT_CONST:
  //       s.send_out[0].msg.payload @= s.recv_const.msg.payload
  //       s.send_out[0].msg.predicate @= s.recv_const.msg.predicate & \
  //                                      s.reached_vector_factor
  //       s.recv_all_val @= s.recv_const.val
  //       s.send_out[0].val @= s.recv_all_val
  //       s.recv_const.rdy @= s.recv_all_val & s.send_out[0].rdy
  //       s.recv_opt.rdy @= s.recv_all_val & s.send_out[0].rdy
  //     else:
  //       for j in range(num_outports):
  //         s.send_out[j].val @= b1(0)
  //       s.recv_opt.rdy @= 0
  
  always_comb begin : comb_logic
    recv_all_val = 1'd0;
    for ( int unsigned i = 1'd0; i < 3'( __const__num_inports_at_comb_logic ); i += 1'd1 )
      recv_in__rdy[2'(i)] = 1'd0;
    for ( int unsigned i = 1'd0; i < 2'( __const__num_outports_at_comb_logic ); i += 1'd1 ) begin
      send_out__val[1'(i)] = 1'd0;
      send_out__msg[1'(i)] = { 32'd0, 1'd0, 1'd0, 1'd0 };
    end
    recv_const__rdy = 1'd0;
    recv_opt__rdy = 1'd0;
    send_to_ctrl_mem__val = 1'd0;
    send_to_ctrl_mem__msg = { 5'd0, 35'd0, 9'd0, 139'd0, 3'd0 };
    recv_from_ctrl_mem__rdy = 1'd0;
    if ( recv_opt__val ) begin
      if ( recv_opt__msg.operation == 7'( __const__OPT_CONST ) ) begin
        send_out__msg[1'd0].payload = recv_const__msg.payload;
        send_out__msg[1'd0].predicate = recv_const__msg.predicate & reached_vector_factor;
        recv_all_val = recv_const__val;
        send_out__val[1'd0] = recv_all_val;
        recv_const__rdy = recv_all_val & send_out__rdy[1'd0];
        recv_opt__rdy = recv_all_val & send_out__rdy[1'd0];
      end
      else begin
        for ( int unsigned j = 1'd0; j < 2'( __const__num_outports_at_comb_logic ); j += 1'd1 )
          send_out__val[1'(j)] = 1'd0;
        recv_opt__rdy = 1'd0;
      end
    end
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/fu/basic/Fu.py:68
  // @update
  // def update_mem():
  //   s.to_mem_waddr.val @= b1(0)
  //   s.to_mem_wdata.val @= b1(0)
  //   s.to_mem_wdata.msg @= s.const_zero
  //   s.to_mem_waddr.msg @= s.DataAddrType(0)
  //   s.to_mem_raddr.msg @= s.DataAddrType(0)
  //   s.to_mem_raddr.val @= b1(0)
  //   s.from_mem_rdata.rdy @= b1(0)
  
  always_comb begin : update_mem
    to_mem_waddr__val = 1'd0;
    to_mem_wdata__val = 1'd0;
    to_mem_wdata__msg = const_zero;
    to_mem_waddr__msg = 9'd0;
    to_mem_raddr__msg = 9'd0;
    to_mem_raddr__val = 1'd0;
    from_mem_rdata__rdy = 1'd0;
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/fu/basic/Fu.py:87
  // @update
  // def update_reached_vector_factor():
  //   s.reached_vector_factor @= 0
  //   if s.recv_opt.val & (s.vector_factor_counter + \
  //                        (VectorFactorType(1) << zext(s.vector_factor_power, VectorFactorType)) >= \
  //                        (VectorFactorType(1) << zext(s.recv_opt.msg.vector_factor_power, VectorFactorType))):
  //     s.reached_vector_factor @= 1
  
  always_comb begin : update_reached_vector_factor
    reached_vector_factor = 1'd0;
    if ( recv_opt__val & ( ( vector_factor_counter + ( 8'd1 << { { 5 { 1'b0 } }, vector_factor_power } ) ) >= ( 8'd1 << { { 5 { 1'b0 } }, recv_opt__msg.vector_factor_power } ) ) ) begin
      reached_vector_factor = 1'd1;
    end
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/fu/basic/Fu.py:78
  // @update_ff
  // def proceed_latency():
  //   if s.recv_opt.msg.operation == OPT_START:
  //     s.latency <<= LatencyType(0)
  //   elif s.latency == latency - 1:
  //     s.latency <<= LatencyType(0)
  //   else:
  //     s.latency <<= s.latency + LatencyType(1)
  
  always_ff @(posedge clk) begin : proceed_latency
    if ( recv_opt__msg.operation == 7'( __const__OPT_START ) ) begin
      latency <= 1'd0;
    end
    else if ( latency == ( 1'( __const__latency_at_proceed_latency ) - 1'd1 ) ) begin
      latency <= 1'd0;
    end
    else
      latency <= latency + 1'd1;
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/fu/basic/Fu.py:95
  // @update_ff
  // def update_vector_factor_counter():
  //   if s.reset:
  //     s.vector_factor_counter <<= 0
  //   else:
  //     if s.recv_opt.val:
  //       if s.recv_opt.msg.is_last_ctrl & \
  //          (s.vector_factor_counter + \
  //           (VectorFactorType(1) << zext(s.vector_factor_power, VectorFactorType)) < \
  //           (VectorFactorType(1) << zext(s.recv_opt.msg.vector_factor_power, VectorFactorType))):
  //         s.vector_factor_counter <<= s.vector_factor_counter + \
  //                                     (VectorFactorType(1) << zext(s.vector_factor_power, \
  //                                                                  VectorFactorType))
  //       elif s.recv_opt.msg.is_last_ctrl & s.reached_vector_factor:
  //         s.vector_factor_counter <<= 0
  
  always_ff @(posedge clk) begin : update_vector_factor_counter
    if ( reset ) begin
      vector_factor_counter <= 8'd0;
    end
    else if ( recv_opt__val ) begin
      if ( recv_opt__msg.is_last_ctrl & ( ( vector_factor_counter + ( 8'd1 << { { 5 { 1'b0 } }, vector_factor_power } ) ) < ( 8'd1 << { { 5 { 1'b0 } }, recv_opt__msg.vector_factor_power } ) ) ) begin
        vector_factor_counter <= vector_factor_counter + ( 8'd1 << { { 5 { 1'b0 } }, vector_factor_power } );
      end
      else if ( recv_opt__msg.is_last_ctrl & reached_vector_factor ) begin
        vector_factor_counter <= 8'd0;
      end
    end
  end

  assign vector_factor_power = 3'd0;

endmodule


// PyMTL Component NahRTL Definition
// Full name: NahRTL__CtrlPktType_IntraCgraPacket_4_4x1_4_8_2_CgraPayload__11cd3f8c0d91825c__num_inports_4__num_outports_2__vector_factor_power_0
// At /cgra/VectorCGRA/fu/single/NahRTL.py

module NahRTL__1a7eacb70e3ca1c4
(
  input  logic [0:0] clear ,
  input  logic [0:0] clk ,
  input  logic [2:0] ctrl_addr_inport ,
  input  logic [0:0] reset ,
  input CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 from_mem_rdata__msg  ,
  output logic [0:0] from_mem_rdata__rdy  ,
  input logic [0:0] from_mem_rdata__val  ,
  input CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 recv_const__msg  ,
  output logic [0:0] recv_const__rdy  ,
  input logic [0:0] recv_const__val  ,
  input MultiCgraPayload_Cmd_Data_DataAddr_Ctrl_CtrlAddr__a0427cd98cfcae6f recv_from_ctrl_mem__msg  ,
  output logic [0:0] recv_from_ctrl_mem__rdy  ,
  input logic [0:0] recv_from_ctrl_mem__val  ,
  input CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 recv_in__msg [0:3] ,
  output logic [0:0] recv_in__rdy [0:3] ,
  input logic [0:0] recv_in__val [0:3] ,
  input CGRAConfig_7_4_2_8_8_3__603a41f5d0e2436f recv_opt__msg  ,
  output logic [0:0] recv_opt__rdy  ,
  input logic [0:0] recv_opt__val  ,
  output CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 send_out__msg [0:1] ,
  input logic [0:0] send_out__rdy [0:1] ,
  output logic [0:0] send_out__val [0:1] ,
  output MultiCgraPayload_Cmd_Data_DataAddr_Ctrl_CtrlAddr__a0427cd98cfcae6f send_to_ctrl_mem__msg  ,
  input logic [0:0] send_to_ctrl_mem__rdy  ,
  output logic [0:0] send_to_ctrl_mem__val  ,
  output logic [8:0] to_mem_raddr__msg  ,
  input logic [0:0] to_mem_raddr__rdy  ,
  output logic [0:0] to_mem_raddr__val  ,
  output logic [8:0] to_mem_waddr__msg  ,
  input logic [0:0] to_mem_waddr__rdy  ,
  output logic [0:0] to_mem_waddr__val  ,
  output CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 to_mem_wdata__msg  ,
  input logic [0:0] to_mem_wdata__rdy  ,
  output logic [0:0] to_mem_wdata__val  
);
  localparam CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 const_zero  = { 32'd0, 1'd0, 1'd0, 1'd0 };
  localparam logic [6:0] __const__OPT_START  = 7'd0;
  localparam logic [0:0] __const__latency_at_proceed_latency  = 1'd1;
  localparam logic [2:0] __const__num_inports_at_comb_logic  = 3'd4;
  localparam logic [1:0] __const__num_outports_at_comb_logic  = 2'd2;
  localparam logic [6:0] __const__OPT_NAH  = 7'd1;
  logic [0:0] latency;
  logic [0:0] reached_vector_factor;
  logic [7:0] vector_factor_counter;
  logic [2:0] vector_factor_power;

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/fu/single/NahRTL.py:21
  // @update
  // def comb_logic():
  // 
  //   s.recv_const.rdy @= 0
  //   s.recv_opt.rdy @= 0
  //   # For pick input register
  //   for i in range(num_inports):
  //     s.recv_in[i].rdy @= b1(0)
  // 
  //   for i in range( num_outports ):
  //     # s.send_out[i].val @= s.recv_opt.val
  //     s.send_out[i].val @= 0
  //     s.send_out[i].msg @= s.DataType()
  // 
  //   s.send_to_ctrl_mem.val @= 0
  //   s.send_to_ctrl_mem.msg @= s.CgraPayloadType(0, 0, 0, 0, 0)
  //   s.recv_from_ctrl_mem.rdy @= 0
  // 
  //   if s.recv_opt.val & (s.recv_opt.msg.operation == OPT_NAH):
  //     s.recv_opt.rdy @= 1
  //   else:
  //     for j in range(num_outports):
  //       s.send_out[j].val @= b1(0)
  //     s.recv_opt.rdy @= 0
  
  always_comb begin : comb_logic
    recv_const__rdy = 1'd0;
    recv_opt__rdy = 1'd0;
    for ( int unsigned i = 1'd0; i < 3'( __const__num_inports_at_comb_logic ); i += 1'd1 )
      recv_in__rdy[2'(i)] = 1'd0;
    for ( int unsigned i = 1'd0; i < 2'( __const__num_outports_at_comb_logic ); i += 1'd1 ) begin
      send_out__val[1'(i)] = 1'd0;
      send_out__msg[1'(i)] = { 32'd0, 1'd0, 1'd0, 1'd0 };
    end
    send_to_ctrl_mem__val = 1'd0;
    send_to_ctrl_mem__msg = { 5'd0, 35'd0, 9'd0, 139'd0, 3'd0 };
    recv_from_ctrl_mem__rdy = 1'd0;
    if ( recv_opt__val & ( recv_opt__msg.operation == 7'( __const__OPT_NAH ) ) ) begin
      recv_opt__rdy = 1'd1;
    end
    else begin
      for ( int unsigned j = 1'd0; j < 2'( __const__num_outports_at_comb_logic ); j += 1'd1 )
        send_out__val[1'(j)] = 1'd0;
      recv_opt__rdy = 1'd0;
    end
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/fu/basic/Fu.py:68
  // @update
  // def update_mem():
  //   s.to_mem_waddr.val @= b1(0)
  //   s.to_mem_wdata.val @= b1(0)
  //   s.to_mem_wdata.msg @= s.const_zero
  //   s.to_mem_waddr.msg @= s.DataAddrType(0)
  //   s.to_mem_raddr.msg @= s.DataAddrType(0)
  //   s.to_mem_raddr.val @= b1(0)
  //   s.from_mem_rdata.rdy @= b1(0)
  
  always_comb begin : update_mem
    to_mem_waddr__val = 1'd0;
    to_mem_wdata__val = 1'd0;
    to_mem_wdata__msg = const_zero;
    to_mem_waddr__msg = 9'd0;
    to_mem_raddr__msg = 9'd0;
    to_mem_raddr__val = 1'd0;
    from_mem_rdata__rdy = 1'd0;
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/fu/basic/Fu.py:87
  // @update
  // def update_reached_vector_factor():
  //   s.reached_vector_factor @= 0
  //   if s.recv_opt.val & (s.vector_factor_counter + \
  //                        (VectorFactorType(1) << zext(s.vector_factor_power, VectorFactorType)) >= \
  //                        (VectorFactorType(1) << zext(s.recv_opt.msg.vector_factor_power, VectorFactorType))):
  //     s.reached_vector_factor @= 1
  
  always_comb begin : update_reached_vector_factor
    reached_vector_factor = 1'd0;
    if ( recv_opt__val & ( ( vector_factor_counter + ( 8'd1 << { { 5 { 1'b0 } }, vector_factor_power } ) ) >= ( 8'd1 << { { 5 { 1'b0 } }, recv_opt__msg.vector_factor_power } ) ) ) begin
      reached_vector_factor = 1'd1;
    end
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/fu/basic/Fu.py:78
  // @update_ff
  // def proceed_latency():
  //   if s.recv_opt.msg.operation == OPT_START:
  //     s.latency <<= LatencyType(0)
  //   elif s.latency == latency - 1:
  //     s.latency <<= LatencyType(0)
  //   else:
  //     s.latency <<= s.latency + LatencyType(1)
  
  always_ff @(posedge clk) begin : proceed_latency
    if ( recv_opt__msg.operation == 7'( __const__OPT_START ) ) begin
      latency <= 1'd0;
    end
    else if ( latency == ( 1'( __const__latency_at_proceed_latency ) - 1'd1 ) ) begin
      latency <= 1'd0;
    end
    else
      latency <= latency + 1'd1;
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/fu/basic/Fu.py:95
  // @update_ff
  // def update_vector_factor_counter():
  //   if s.reset:
  //     s.vector_factor_counter <<= 0
  //   else:
  //     if s.recv_opt.val:
  //       if s.recv_opt.msg.is_last_ctrl & \
  //          (s.vector_factor_counter + \
  //           (VectorFactorType(1) << zext(s.vector_factor_power, VectorFactorType)) < \
  //           (VectorFactorType(1) << zext(s.recv_opt.msg.vector_factor_power, VectorFactorType))):
  //         s.vector_factor_counter <<= s.vector_factor_counter + \
  //                                     (VectorFactorType(1) << zext(s.vector_factor_power, \
  //                                                                  VectorFactorType))
  //       elif s.recv_opt.msg.is_last_ctrl & s.reached_vector_factor:
  //         s.vector_factor_counter <<= 0
  
  always_ff @(posedge clk) begin : update_vector_factor_counter
    if ( reset ) begin
      vector_factor_counter <= 8'd0;
    end
    else if ( recv_opt__val ) begin
      if ( recv_opt__msg.is_last_ctrl & ( ( vector_factor_counter + ( 8'd1 << { { 5 { 1'b0 } }, vector_factor_power } ) ) < ( 8'd1 << { { 5 { 1'b0 } }, recv_opt__msg.vector_factor_power } ) ) ) begin
        vector_factor_counter <= vector_factor_counter + ( 8'd1 << { { 5 { 1'b0 } }, vector_factor_power } );
      end
      else if ( recv_opt__msg.is_last_ctrl & reached_vector_factor ) begin
        vector_factor_counter <= 8'd0;
      end
    end
  end

  assign vector_factor_power = 3'd0;

endmodule


// PyMTL VerilogPlaceholder AddRecFN Definition
// At /cgra/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/AddRecFNRTL.py

//***********************************************************
// Pickled source file of placeholder AddRecFN__expWidth_9__sigWidth_23
//***********************************************************

//-----------------------------------------------------------
// Dependency of placeholder AddRecFN
//-----------------------------------------------------------

`ifndef ADDRECFN
`define ADDRECFN

// The source code below are included because they are specified
// as the v_libs Verilog placeholder option of component AddRecFN__expWidth_9__sigWidth_23.

// If you get a duplicated def error from files included below, please
// make sure they are included either through the v_libs option or the
// explicit `include statement in the Verilog source code -- if they
// appear in both then they will be included twice!

`line 1 "/cgra/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/HardFloat_primitives.v" 0
`ifndef __HARDFLOAT_PRIMITIVES_VI__
`define __HARDFLOAT_PRIMITIVES_VI__

/*============================================================================

This Verilog source file is part of the Berkeley HardFloat IEEE Floating-Point
Arithmetic Package, Release 1, by John R. Hauser.

Copyright 2019 The Regents of the University of California.  All rights
reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
    this list of conditions, and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions, and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

 3. Neither the name of the University nor the names of its contributors may
    be used to endorse or promote products derived from this software without
    specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=============================================================================*/

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    reverse#(parameter width = 1) (
        input [(width - 1):0] in, output [(width - 1):0] out
    );

    genvar ix;
    generate
        for (ix = 0; ix < width; ix = ix + 1) begin :Bit
            assign out[ix] = in[width - 1 - ix];
        end
    endgenerate

endmodule

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    lowMaskHiLo#(
        parameter inWidth = 1,
        parameter topBound = 1,
        parameter bottomBound = 0
    ) (
        input [(inWidth - 1):0] in,
        output [(topBound - bottomBound - 1):0] out
    );

    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    localparam numInVals = 1<<inWidth;
    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    wire signed [numInVals:0] c;
    assign c[numInVals] = 1;
    assign c[(numInVals - 1):0] = 0;
    wire [(topBound - bottomBound - 1):0] reverseOut =
        (c>>>in)>>(numInVals - topBound);
    reverse#(topBound - bottomBound) reverse(reverseOut, out);

endmodule

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    lowMaskLoHi#(
        parameter inWidth = 1,
        parameter topBound = 0,
        parameter bottomBound = 1
    ) (
        input [(inWidth - 1):0] in,
        output [(bottomBound - topBound - 1):0] out
    );

    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    localparam numInVals = 1<<inWidth;
    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    wire signed [numInVals:0] c;
    assign c[numInVals] = 1;
    assign c[(numInVals - 1):0] = 0;
    wire [(bottomBound - topBound - 1):0] reverseOut =
        (c>>>~in)>>(topBound + 1);
    reverse#(bottomBound - topBound) reverse(reverseOut, out);

endmodule

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    countLeadingZeros#(parameter inWidth = 1, parameter countWidth = 1) (
        input [(inWidth - 1):0] in, output [(countWidth - 1):0] count
    );

    wire [(inWidth - 1):0] reverseIn;
    reverse#(inWidth) reverse_in(in, reverseIn);
    wire [inWidth:0] oneLeastReverseIn =
        {1'b1, reverseIn} & ({1'b0, ~reverseIn} + 1);
    genvar ix;
    generate
        for (ix = 0; ix <= inWidth; ix = ix + 1) begin :Bit
            wire [(countWidth - 1):0] countSoFar;
            if (ix == 0) begin
                assign countSoFar = 0;
            end else begin
                assign countSoFar =
                    Bit[ix - 1].countSoFar | (oneLeastReverseIn[ix] ? ix : 0);
                if (ix == inWidth) assign count = countSoFar;
            end
        end
    endgenerate

endmodule

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    compressBy2#(parameter inWidth = 1) (
        input [(inWidth - 1):0] in, output [((inWidth - 1)/2):0] out
    );

    localparam maxBitNumReduced = (inWidth - 1)/2;
    genvar ix;
    generate
        for (ix = 0; ix < maxBitNumReduced; ix = ix + 1) begin :Bit
            assign out[ix] = |in[(ix*2 + 1):ix*2];
        end
    endgenerate
    assign out[maxBitNumReduced] = |in[(inWidth - 1):maxBitNumReduced*2];

endmodule

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    compressBy4#(parameter inWidth = 1) (
        input [(inWidth - 1):0] in, output [(inWidth - 1)/4:0] out
    );

    localparam maxBitNumReduced = (inWidth - 1)/4;
    genvar ix;
    generate
        for (ix = 0; ix < maxBitNumReduced; ix = ix + 1) begin :Bit
            assign out[ix] = |in[(ix*4 + 3):ix*4];
        end
    endgenerate
    assign out[maxBitNumReduced] = |in[(inWidth - 1):maxBitNumReduced*4];

endmodule

`endif /* __HARDFLOAT_PRIMITIVES_VI__ */
`line 1 "/cgra/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/isSigNaNRecFN.v" 0
`ifndef __HARDFLOAT_ISSIGNANRECFN_V__
`define __HARDFLOAT_ISSIGNANRECFN_V__

/*============================================================================

This Verilog source file is part of the Berkeley HardFloat IEEE Floating-Point
Arithmetic Package, Release 1, by John R. Hauser.

Copyright 2019 The Regents of the University of California.  All rights
reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
    this list of conditions, and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions, and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

 3. Neither the name of the University nor the names of its contributors may
    be used to endorse or promote products derived from this software without
    specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=============================================================================*/

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    isSigNaNRecFN#(parameter expWidth = 3, parameter sigWidth = 3) (
        input [(expWidth + sigWidth):0] in, output isSigNaN
    );

    wire isNaN =
        (in[(expWidth + sigWidth - 1):(expWidth + sigWidth - 3)] == 'b111);
    assign isSigNaN = isNaN && !in[sigWidth - 2];

endmodule

`endif /* __HARDFLOAT_ISSIGNANRECFN_V__ */
`line 1 "/cgra/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/HardFloat_rawFN.v" 0
`ifndef __HARDFLOAT_RAWFN_VI__
`define __HARDFLOAT_RAWFN_VI__

/*============================================================================

This Verilog source file is part of the Berkeley HardFloat IEEE Floating-Point
Arithmetic Package, Release 1, by John R. Hauser.

Copyright 2019 The Regents of the University of California.  All rights
reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
    this list of conditions, and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions, and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

 3. Neither the name of the University nor the names of its contributors may
    be used to endorse or promote products derived from this software without
    specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=============================================================================*/

`line 1 "/cgra/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/HardFloat_consts.vi" 0
`ifndef __HARDFLOAT_CONSTS_VI__
`define __HARDFLOAT_CONSTS_VI__

/*============================================================================

This Verilog include file is part of the Berkeley HardFloat IEEE Floating-
Point Arithmetic Package, Release 1, by John R. Hauser.

Copyright 2019 The Regents of the University of California.  All rights
reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
    this list of conditions, and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions, and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

 3. Neither the name of the University nor the names of its contributors may
    be used to endorse or promote products derived from this software without
    specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=============================================================================*/

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/
`define round_near_even   3'b000
`define round_minMag      3'b001
`define round_min         3'b010
`define round_max         3'b011
`define round_near_maxMag 3'b100
`define round_odd         3'b110

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/
`define floatControlWidth 1
`define flControl_tininessBeforeRounding 1'b0
`define flControl_tininessAfterRounding  1'b1

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/
`define flRoundOpt_sigMSBitAlwaysZero  1
`define flRoundOpt_subnormsAlwaysExact 2
`define flRoundOpt_neverUnderflows     4
`define flRoundOpt_neverOverflows      8

`endif /* __HARDFLOAT_CONSTS_VI__ */

`line 40 "/cgra/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/HardFloat_rawFN.v" 0
`line 1 "/cgra/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/HardFloat_specialize.vi" 0
`ifndef __HARDFLOAT_SPECIALIZE_VI__
`define __HARDFLOAT_SPECIALIZE_VI__

/*============================================================================

This Verilog source file is part of the Berkeley HardFloat IEEE Floating-Point
Arithmetic Package, Release 1, by John R. Hauser.

Copyright 2019 The Regents of the University of California.  All rights
reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
    this list of conditions, and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions, and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

 3. Neither the name of the University nor the names of its contributors may
    be used to endorse or promote products derived from this software without
    specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=============================================================================*/

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    iNFromException#(parameter width = 1) (
        input signedOut,
        input isNaN,
        input sign,
        output [(width - 1):0] out
    );

    wire maxInt = isNaN || !sign;
    assign out = {signedOut ^ maxInt, {(width - 1){maxInt}}};

endmodule

`endif /* __HARDFLOAT_SPECIALIZE_VI__ */

`line 41 "/cgra/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/HardFloat_rawFN.v" 0

/* ===================== Adding some extra include files ================ */
`line 1 "/cgra/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/RISCV/HardFloat_specialize.vi" 0
`ifndef __RISCV_HARDFLOAT_SPECIALIZE_VI__
`define __RISCV_HARDFLOAT_SPECIALIZE_VI__

/*============================================================================

This Verilog include file is part of the Berkeley HardFloat IEEE Floating-
Point Arithmetic Package, Release 1, by John R. Hauser.

Copyright 2019 The Regents of the University of California.  All rights
reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
    this list of conditions, and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions, and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

 3. Neither the name of the University nor the names of its contributors may
    be used to endorse or promote products derived from this software without
    specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=============================================================================*/

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/
`define flControl_default `flControl_tininessAfterRounding

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/
//`define HardFloat_propagateNaNPayloads

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/
`define HardFloat_signDefaultNaN 0
`define HardFloat_fractDefaultNaN(sigWidth) {1'b1, {((sigWidth) - 2){1'b0}}}

`endif /* __RISCV_HARDFLOAT_SPECIALIZE_VI__ */

`line 44 "/cgra/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/HardFloat_rawFN.v" 0
/* ====================================================================== */

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    recFNToRawFN#(parameter expWidth = 3, parameter sigWidth = 3) (
        input [(expWidth + sigWidth):0] in,
        output isNaN,
        output isInf,
        output isZero,
        output sign,
        output signed [(expWidth + 1):0] sExp,
        output [sigWidth:0] sig
    );

    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    wire [expWidth:0] exp;
    wire [(sigWidth - 2):0] fract;
    assign {sign, exp, fract} = in;
    wire isSpecial = (exp>>(expWidth - 1) == 'b11);
    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    assign isNaN = isSpecial &&  exp[expWidth - 2];
    assign isInf = isSpecial && !exp[expWidth - 2];
    assign isZero = (exp>>(expWidth - 2) == 'b000);
    assign sExp = exp;
    assign sig = {1'b0, !isZero, fract};

endmodule

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    roundAnyRawFNToRecFN#(
        parameter inExpWidth = 3,
        parameter inSigWidth = 3,
        parameter outExpWidth = 3,
        parameter outSigWidth = 3,
        parameter options = 0
    ) (
        input [(`floatControlWidth - 1):0] control,
        input invalidExc,     // overrides 'infiniteExc' and 'in_*' inputs
        input infiniteExc,    // overrides 'in_*' inputs except 'in_sign'
        input in_isNaN,
        input in_isInf,
        input in_isZero,
        input in_sign,
        input signed [(inExpWidth + 1):0] in_sExp,   // limited range allowed
        input [inSigWidth:0] in_sig,
        input [2:0] roundingMode,
        output [(outExpWidth + outSigWidth):0] out,
        output [4:0] exceptionFlags
    );

    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    localparam sigMSBitAlwaysZero =
        ((options & `flRoundOpt_sigMSBitAlwaysZero) != 0);
    localparam effectiveInSigWidth =
        sigMSBitAlwaysZero ? inSigWidth : inSigWidth + 1;
    localparam neverUnderflows =
        ((options
              & (`flRoundOpt_neverUnderflows
                     | `flRoundOpt_subnormsAlwaysExact))
             != 0)
            || (inExpWidth < outExpWidth);
    localparam neverOverflows =
        ((options & `flRoundOpt_neverOverflows) != 0)
            || (inExpWidth < outExpWidth);
    localparam adjustedExpWidth =
          (inExpWidth < outExpWidth) ? outExpWidth + 1
        : (inExpWidth == outExpWidth) ? inExpWidth + 2
        : inExpWidth + 3;
    localparam outNaNExp = 7<<(outExpWidth - 2);
    localparam outInfExp = 6<<(outExpWidth - 2);
    localparam outMaxFiniteExp = outInfExp - 1;
    localparam outMinNormExp = (1<<(outExpWidth - 1)) + 2;
    localparam outMinNonzeroExp = outMinNormExp - outSigWidth + 1;
    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    wire roundingMode_near_even   = (roundingMode == `round_near_even);
    wire roundingMode_minMag      = (roundingMode == `round_minMag);
    wire roundingMode_min         = (roundingMode == `round_min);
    wire roundingMode_max         = (roundingMode == `round_max);
    wire roundingMode_near_maxMag = (roundingMode == `round_near_maxMag);
    wire roundingMode_odd         = (roundingMode == `round_odd);
    wire roundMagUp =
        (roundingMode_min && in_sign) || (roundingMode_max && !in_sign);
    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    wire isNaNOut = invalidExc || (!infiniteExc && in_isNaN);
`ifdef HardFloat_propagateNaNPayloads
    wire propagateNaNPayload = isNaNOut;
`else
    wire propagateNaNPayload = 0;
`endif
    wire signed [(adjustedExpWidth - 1):0] sAdjustedExp =
        in_sExp + ((1<<outExpWidth) - (1<<inExpWidth));
    wire [(outSigWidth + 2):0] adjustedSig;
    generate
        if (inSigWidth <= outSigWidth + 2) begin
            assign adjustedSig = in_sig<<(outSigWidth - inSigWidth + 2);
        end else begin
            assign adjustedSig =
                {in_sig[inSigWidth:(inSigWidth - outSigWidth - 1)],
                 |in_sig[(inSigWidth - outSigWidth - 2):0]};
        end
    endgenerate
    wire doShiftSigDown1 =
        sigMSBitAlwaysZero ? 0 : adjustedSig[outSigWidth + 2];
    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    wire [outExpWidth:0] common_expOut;
    wire [(outSigWidth - 2):0] common_fractOut;
    wire common_overflow, common_totalUnderflow, common_underflow;
    wire common_inexact;
    generate
        if (
            neverOverflows && neverUnderflows
                && (effectiveInSigWidth <= outSigWidth)
        ) begin
            /*----------------------------------------------------------------
            *----------------------------------------------------------------*/
            assign common_expOut = sAdjustedExp + doShiftSigDown1;
            assign common_fractOut =
                doShiftSigDown1 ? adjustedSig>>3 : adjustedSig>>2;
            assign common_overflow       = 0;
            assign common_totalUnderflow = 0;
            assign common_underflow      = 0;
            assign common_inexact        = 0;
        end else begin
            /*----------------------------------------------------------------
            *----------------------------------------------------------------*/
            wire [(outSigWidth + 2):0] roundMask;
            if (neverUnderflows) begin
                assign roundMask = {doShiftSigDown1, 2'b11};
            end else begin
                wire [outSigWidth:0] roundMask_main;
                lowMaskLoHi#(
                    outExpWidth + 1,
                    outMinNormExp - outSigWidth - 1,
                    outMinNormExp
                ) lowMask_roundMask(
                        sAdjustedExp[outExpWidth:0]
                            | (propagateNaNPayload ? 1'b1<<outExpWidth : 1'b0),
                        roundMask_main
                    );
                assign roundMask = {roundMask_main | doShiftSigDown1, 2'b11};
            end
            wire [(outSigWidth + 2):0] shiftedRoundMask = roundMask>>1;
            wire [(outSigWidth + 2):0] roundPosMask =
                ~shiftedRoundMask & roundMask;
            wire roundPosBit =
                (|(adjustedSig[(outSigWidth + 2):3]
                       & roundPosMask[(outSigWidth + 2):3]))
                    || ((|(adjustedSig[2:0] & roundPosMask[2:0]))
                            && !propagateNaNPayload);
            wire anyRoundExtra =
                (|(adjustedSig[(outSigWidth + 2):3]
                       & shiftedRoundMask[(outSigWidth + 2):3]))
                    || ((|(adjustedSig[2:0] & shiftedRoundMask[2:0]))
                            && !propagateNaNPayload);
            wire anyRound = roundPosBit || anyRoundExtra;
            /*----------------------------------------------------------------
            *----------------------------------------------------------------*/
            wire roundIncr =
                ((roundingMode_near_even || roundingMode_near_maxMag)
                     && roundPosBit)
                    || (roundMagUp && anyRound);
            wire [(outSigWidth + 1):0] roundedSig =
                roundIncr
                    ? (((adjustedSig | roundMask)>>2) + 1)
                          & ~(roundingMode_near_even && roundPosBit
                                  && !anyRoundExtra
                                  ? roundMask>>1 : 0)
                    : (adjustedSig & ~roundMask)>>2
                          | (roundingMode_odd && anyRound
                                 ? roundPosMask>>1 : 0);
            wire signed [adjustedExpWidth:0] sExtAdjustedExp = sAdjustedExp;
            wire signed [adjustedExpWidth:0] sRoundedExp =
                sExtAdjustedExp + (roundedSig>>outSigWidth);
            /*----------------------------------------------------------------
            *----------------------------------------------------------------*/
            assign common_expOut = sRoundedExp;
            assign common_fractOut =
                doShiftSigDown1 ? roundedSig>>1 : roundedSig;
            assign common_overflow =
                neverOverflows ? 0 : (sRoundedExp>>>(outExpWidth - 1) >= 3);
            assign common_totalUnderflow =
                neverUnderflows ? 0 : (sRoundedExp < outMinNonzeroExp);
            /*----------------------------------------------------------------
            *----------------------------------------------------------------*/
            wire unboundedRange_roundPosBit =
                doShiftSigDown1 ? adjustedSig[2] : adjustedSig[1];
            wire unboundedRange_anyRound =
                (doShiftSigDown1 && adjustedSig[2]) || (|adjustedSig[1:0]);
            wire unboundedRange_roundIncr =
                ((roundingMode_near_even || roundingMode_near_maxMag)
                     && unboundedRange_roundPosBit)
                    || (roundMagUp && unboundedRange_anyRound);
            wire roundCarry =
                doShiftSigDown1
                    ? roundedSig[outSigWidth + 1] : roundedSig[outSigWidth];
            assign common_underflow =
                neverUnderflows ? 0
                    : common_totalUnderflow
                          || (anyRound && (sAdjustedExp>>>outExpWidth <= 0)
                                  && (doShiftSigDown1
                                          ? roundMask[3] : roundMask[2])
                                  && !(((control
                                           & `flControl_tininessAfterRounding)
                                            != 0)
                                           && !(doShiftSigDown1 ? roundMask[4]
                                                    : roundMask[3])
                                           && roundCarry && roundPosBit
                                           && unboundedRange_roundIncr));
            /*----------------------------------------------------------------
            *----------------------------------------------------------------*/
            assign common_inexact = common_totalUnderflow || anyRound;
        end
    endgenerate
    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    wire notNaN_isSpecialInfOut = infiniteExc || in_isInf;
    wire commonCase = !isNaNOut && !notNaN_isSpecialInfOut && !in_isZero;
    wire overflow  = commonCase && common_overflow;
    wire underflow = commonCase && common_underflow;
    wire inexact = overflow || (commonCase && common_inexact);
    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    wire overflow_roundMagUp =
        roundingMode_near_even || roundingMode_near_maxMag || roundMagUp;
    wire pegMinNonzeroMagOut =
        commonCase && common_totalUnderflow
            && (roundMagUp || roundingMode_odd);
    wire pegMaxFiniteMagOut = overflow && !overflow_roundMagUp;
    wire notNaN_isInfOut =
        notNaN_isSpecialInfOut || (overflow && overflow_roundMagUp);
    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
`ifdef HardFloat_propagateNaNPayloads
    wire signOut = in_sign;
`else
    wire signOut = isNaNOut ? `HardFloat_signDefaultNaN : in_sign;
`endif
    wire [outExpWidth:0] expOut =
        (common_expOut
             & ~(in_isZero || common_totalUnderflow ? 7<<(outExpWidth - 2) : 0)
             & ~(pegMinNonzeroMagOut               ? ~outMinNonzeroExp    : 0)
             & ~(pegMaxFiniteMagOut                ? 1<<(outExpWidth - 1) : 0)
             & ~(notNaN_isInfOut                   ? 1<<(outExpWidth - 2) : 0))
            | (pegMinNonzeroMagOut ? outMinNonzeroExp : 0)
            | (pegMaxFiniteMagOut  ? outMaxFiniteExp  : 0)
            | (notNaN_isInfOut     ? outInfExp        : 0)
            | (isNaNOut            ? outNaNExp        : 0);
`ifdef HardFloat_propagateNaNPayloads
    wire [(outSigWidth - 2):0] fractOut =
        {isNaNOut
             || (!in_isZero && !common_totalUnderflow
                     && common_fractOut[outSigWidth - 2]),
         isNaNOut || (!in_isZero && !common_totalUnderflow)
             ? common_fractOut[(outSigWidth - 3):0] : 1'b0}
            | {(outSigWidth - 1){pegMaxFiniteMagOut}};
`else
    wire [(outSigWidth - 2):0] fractOut =
          (isNaNOut ? `HardFloat_fractDefaultNaN(outSigWidth) : 0)
        | (!in_isZero && !common_totalUnderflow
               ? common_fractOut & `HardFloat_fractDefaultNaN(outSigWidth) : 0)
        | (!isNaNOut && !in_isZero && !common_totalUnderflow
               ? common_fractOut & ~`HardFloat_fractDefaultNaN(outSigWidth)
               : 0)
        | {(outSigWidth - 1){pegMaxFiniteMagOut}};
`endif
    assign out = {signOut, expOut, fractOut};
    assign exceptionFlags =
        {invalidExc, infiniteExc, overflow, underflow, inexact};

endmodule

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    roundRawFNToRecFN#(
        parameter expWidth = 3,
        parameter sigWidth = 3,
        parameter options = 0
    ) (
        input [(`floatControlWidth - 1):0] control,
        input invalidExc,     // overrides 'infiniteExc' and 'in_*' inputs
        input infiniteExc,    // overrides 'in_*' inputs except 'in_sign'
        input in_isNaN,
        input in_isInf,
        input in_isZero,
        input in_sign,
        input signed [(expWidth + 1):0] in_sExp,   // limited range allowed
        input [(sigWidth + 2):0] in_sig,
        input [2:0] roundingMode,
        output [(expWidth + sigWidth):0] out,
        output [4:0] exceptionFlags
    );

    roundAnyRawFNToRecFN#(expWidth, sigWidth + 2, expWidth, sigWidth, options)
        roundAnyRawFNToRecFN(
            control,
            invalidExc,
            infiniteExc,
            in_isNaN,
            in_isInf,
            in_isZero,
            in_sign,
            in_sExp,
            in_sig,
            roundingMode,
            out,
            exceptionFlags
        );

endmodule

`endif /* __HARDFLOAT_RAWFN_VI__ */

// End of all v_libs files for component AddRecFN__expWidth_9__sigWidth_23

`line 1 "/cgra/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/addRecFN.v" 0
`ifndef __HARDFLOAT_ADDRECFN_V__
`define __HARDFLOAT_ADDRECFN_V__

/*============================================================================

This Verilog source file is part of the Berkeley HardFloat IEEE Floating-Point
Arithmetic Package, Release 1, by John R. Hauser.

Copyright 2019 The Regents of the University of California.  All rights
reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
    this list of conditions, and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions, and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

 3. Neither the name of the University nor the names of its contributors may
    be used to endorse or promote products derived from this software without
    specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=============================================================================*/

`line 1 "/cgra/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/HardFloat_consts.vi" 0
`ifndef __HARDFLOAT_CONSTS_VI__
`define __HARDFLOAT_CONSTS_VI__

/*============================================================================

This Verilog include file is part of the Berkeley HardFloat IEEE Floating-
Point Arithmetic Package, Release 1, by John R. Hauser.

Copyright 2019 The Regents of the University of California.  All rights
reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
    this list of conditions, and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions, and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

 3. Neither the name of the University nor the names of its contributors may
    be used to endorse or promote products derived from this software without
    specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=============================================================================*/

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/
`define round_near_even   3'b000
`define round_minMag      3'b001
`define round_min         3'b010
`define round_max         3'b011
`define round_near_maxMag 3'b100
`define round_odd         3'b110

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/
`define floatControlWidth 1
`define flControl_tininessBeforeRounding 1'b0
`define flControl_tininessAfterRounding  1'b1

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/
`define flRoundOpt_sigMSBitAlwaysZero  1
`define flRoundOpt_subnormsAlwaysExact 2
`define flRoundOpt_neverUnderflows     4
`define flRoundOpt_neverOverflows      8

`endif /* __HARDFLOAT_CONSTS_VI__ */

`line 40 "/cgra/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/addRecFN.v" 0
`line 1 "/cgra/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/HardFloat_specialize.vi" 0
`ifndef __HARDFLOAT_SPECIALIZE_VI__
`define __HARDFLOAT_SPECIALIZE_VI__

/*============================================================================

This Verilog source file is part of the Berkeley HardFloat IEEE Floating-Point
Arithmetic Package, Release 1, by John R. Hauser.

Copyright 2019 The Regents of the University of California.  All rights
reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
    this list of conditions, and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions, and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

 3. Neither the name of the University nor the names of its contributors may
    be used to endorse or promote products derived from this software without
    specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=============================================================================*/

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    iNFromException#(parameter width = 1) (
        input signedOut,
        input isNaN,
        input sign,
        output [(width - 1):0] out
    );

    wire maxInt = isNaN || !sign;
    assign out = {signedOut ^ maxInt, {(width - 1){maxInt}}};

endmodule

`endif /* __HARDFLOAT_SPECIALIZE_VI__ */

`line 41 "/cgra/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/addRecFN.v" 0

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    addRecFNToRaw#(parameter expWidth = 3, parameter sigWidth = 3) (
        input [(`floatControlWidth - 1):0] control,
        input subOp,
        input [(expWidth + sigWidth):0] a,
        input [(expWidth + sigWidth):0] b,
        input [2:0] roundingMode,
        output invalidExc,
        output out_isNaN,
        output out_isInf,
        output out_isZero,
        output out_sign,
        output signed [(expWidth + 1):0] out_sExp,
        output [(sigWidth + 2):0] out_sig
    );
`line 1 "/cgra/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/HardFloat_localFuncs.vi" 0

/*============================================================================

This Verilog include file is part of the Berkeley HardFloat IEEE Floating-
Point Arithmetic Package, Release 1, by John R. Hauser.

Copyright 2019 The Regents of the University of California.  All rights
reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
    this list of conditions, and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions, and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

 3. Neither the name of the University nor the names of its contributors may
    be used to endorse or promote products derived from this software without
    specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=============================================================================*/

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

function integer clog2;
    input integer a;

    begin
        a = a - 1;
        for (clog2 = 0; a > 0; clog2 = clog2 + 1) a = a>>1;
    end

endfunction


`line 61 "/cgra/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/addRecFN.v" 0

    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    localparam alignDistWidth = clog2(sigWidth);
    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    wire isNaNA, isInfA, isZeroA, signA;
    wire signed [(expWidth + 1):0] sExpA;
    wire [sigWidth:0] sigA;
    recFNToRawFN#(expWidth, sigWidth)
        recFNToRawFN_a(a, isNaNA, isInfA, isZeroA, signA, sExpA, sigA);
    wire isSigNaNA;
    isSigNaNRecFN#(expWidth, sigWidth) isSigNaN_a(a, isSigNaNA);
    wire isNaNB, isInfB, isZeroB, signB;
    wire signed [(expWidth + 1):0] sExpB;
    wire [sigWidth:0] sigB;
    recFNToRawFN#(expWidth, sigWidth)
        recFNToRawFN_b(b, isNaNB, isInfB, isZeroB, signB, sExpB, sigB);
    wire effSignB = subOp ? !signB : signB;
    wire isSigNaNB;
    isSigNaNRecFN#(expWidth, sigWidth) isSigNaN_b(b, isSigNaNB);
    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    wire eqSigns = (signA == effSignB);
    wire notEqSigns_signZero = (roundingMode == `round_min) ? 1 : 0;
    wire signed [(expWidth + 1):0] sDiffExps = sExpA - sExpB;
    wire [(alignDistWidth - 1):0] modNatAlignDist =
        (sDiffExps < 0) ? sExpB - sExpA : sDiffExps;
    wire isMaxAlign =
        (sDiffExps>>>alignDistWidth != 0)
            && ((sDiffExps>>>alignDistWidth != -1)
                    || (sDiffExps[(alignDistWidth - 1):0] == 0));
    wire [(alignDistWidth - 1):0] alignDist =
        isMaxAlign ? (1<<alignDistWidth) - 1 : modNatAlignDist;
    wire closeSubMags = !eqSigns && !isMaxAlign && (modNatAlignDist <= 1);
    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    wire signed [(sigWidth + 2):0] close_alignedSigA =
          ((0 <= sDiffExps) &&  sDiffExps[0] ? sigA<<2 : 0)
        | ((0 <= sDiffExps) && !sDiffExps[0] ? sigA<<1 : 0)
        | ((sDiffExps < 0)                   ? sigA    : 0);
    wire signed [(sigWidth + 2):0] close_sSigSum =
        close_alignedSigA - (sigB<<1);
    wire [(sigWidth + 1):0] close_sigSum =
        (close_sSigSum < 0) ? -close_sSigSum : close_sSigSum;
    wire [(sigWidth + 1 + (sigWidth & 1)):0] close_adjustedSigSum =
        close_sigSum<<(sigWidth & 1);
    wire [(sigWidth + 1)/2:0] close_reduced2SigSum;
    compressBy2#(sigWidth + 2 + (sigWidth & 1))
        compressBy2_close_sigSum(close_adjustedSigSum, close_reduced2SigSum);
    wire [(alignDistWidth - 1):0] close_normDistReduced2;
    countLeadingZeros#((sigWidth + 3)/2, alignDistWidth)
        countLeadingZeros_close(close_reduced2SigSum, close_normDistReduced2);
    wire [(alignDistWidth - 1):0] close_nearNormDist =
        close_normDistReduced2<<1;
    wire [(sigWidth + 2):0] close_sigOut =
        (close_sigSum<<close_nearNormDist)<<1;
    wire close_totalCancellation =
        !(|close_sigOut[(sigWidth + 2):(sigWidth + 1)]);
    wire close_notTotalCancellation_signOut = signA ^ (close_sSigSum < 0);
    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    wire far_signOut = (sDiffExps < 0) ? effSignB : signA;
    wire [(sigWidth - 1):0] far_sigLarger  = (sDiffExps < 0) ? sigB : sigA;
    wire [(sigWidth - 1):0] far_sigSmaller = (sDiffExps < 0) ? sigA : sigB;
    wire [(sigWidth + 4):0] far_mainAlignedSigSmaller =
        {far_sigSmaller, 5'b0}>>alignDist;
    wire [(sigWidth + 1)/4:0] far_reduced4SigSmaller;
    compressBy4#(sigWidth + 2)
        compressBy4_far_sigSmaller(
            {far_sigSmaller, 2'b00}, far_reduced4SigSmaller);
    wire [(sigWidth + 1)/4:0] far_roundExtraMask;
    lowMaskHiLo#(alignDistWidth - 2, (sigWidth + 5)/4, 0)
        lowMask_far_roundExtraMask(
            alignDist[(alignDistWidth - 1):2], far_roundExtraMask);
    wire [(sigWidth + 2):0] far_alignedSigSmaller =
        {far_mainAlignedSigSmaller>>3,
         (|far_mainAlignedSigSmaller[2:0])
             || (|(far_reduced4SigSmaller & far_roundExtraMask))};
    wire far_subMags = !eqSigns;
    wire [(sigWidth + 3):0] far_negAlignedSigSmaller =
        far_subMags ? {1'b1, ~far_alignedSigSmaller}
            : {1'b0, far_alignedSigSmaller};
    wire [(sigWidth + 3):0] far_sigSum =
        (far_sigLarger<<3) + far_negAlignedSigSmaller + far_subMags;
    wire [(sigWidth + 2):0] far_sigOut =
        far_subMags ? far_sigSum : far_sigSum>>1 | far_sigSum[0];
    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    wire notSigNaN_invalidExc = isInfA && isInfB && !eqSigns;
    wire notNaN_isInfOut = isInfA || isInfB;
    wire addZeros = isZeroA && isZeroB;
    wire notNaN_specialCase = notNaN_isInfOut || addZeros;
    wire notNaN_isZeroOut =
        addZeros
            || (!notNaN_isInfOut && closeSubMags && close_totalCancellation);
    wire notNaN_signOut =
           (eqSigns                      && signA              )
        || (isInfA                       && signA              )
        || (isInfB                       && effSignB           )
        || (notNaN_isZeroOut && !eqSigns && notEqSigns_signZero)
        || (!notNaN_specialCase && closeSubMags && !close_totalCancellation
                                        && close_notTotalCancellation_signOut)
        || (!notNaN_specialCase && !closeSubMags && far_signOut);
    wire signed [(expWidth + 1):0] common_sExpOut =
        (closeSubMags || (sDiffExps < 0) ? sExpB : sExpA)
            - (closeSubMags ? close_nearNormDist : far_subMags);
    wire [(sigWidth + 2):0] common_sigOut =
        closeSubMags ? close_sigOut : far_sigOut;
    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    assign invalidExc = isSigNaNA || isSigNaNB || notSigNaN_invalidExc;
    assign out_isInf = notNaN_isInfOut;
    assign out_isZero = notNaN_isZeroOut;
    assign out_sExp = common_sExpOut;
`ifdef HardFloat_propagateNaNPayloads
    assign out_isNaN = isNaNA || isNaNB || notSigNaN_invalidExc;
    wire signNaN;
    wire [(sigWidth - 2):0] fractNaN;
    propagateFloatNaN_add#(sigWidth)
        propagateNaN(
            control,
            subOp,
            isNaNA,
            signA,
            sigA[(sigWidth - 2):0],
            isNaNB,
            signB,
            sigB[(sigWidth - 2):0],
            signNaN,
            fractNaN
        );
    assign out_sign = out_isNaN ? signNaN : notNaN_signOut;
    assign out_sig = out_isNaN ? {1'b1, fractNaN, 2'b00} : common_sigOut;
`else
    assign out_isNaN = isNaNA || isNaNB;
    assign out_sign = notNaN_signOut;
    assign out_sig = common_sigOut;
`endif

endmodule

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    addRecFN#(parameter expWidth = 3, parameter sigWidth = 3) (
        input [(`floatControlWidth - 1):0] control,
        input subOp,
        input [(expWidth + sigWidth):0] a,
        input [(expWidth + sigWidth):0] b,
        input [2:0] roundingMode,
        output [(expWidth + sigWidth):0] out,
        output [4:0] exceptionFlags
    );

    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    wire invalidExc, out_isNaN, out_isInf, out_isZero, out_sign;
    wire signed [(expWidth + 1):0] out_sExp;
    wire [(sigWidth + 2):0] out_sig;
    addRecFNToRaw#(expWidth, sigWidth)
        addRecFNToRaw(
            control,
            subOp,
            a,
            b,
            roundingMode,
            invalidExc,
            out_isNaN,
            out_isInf,
            out_isZero,
            out_sign,
            out_sExp,
            out_sig
        );
    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    roundRawFNToRecFN#(expWidth, sigWidth, `flRoundOpt_subnormsAlwaysExact)
        roundRawOut(
            control,
            invalidExc,
            1'b0,
            out_isNaN,
            out_isInf,
            out_isZero,
            out_sign,
            out_sExp,
            out_sig,
            roundingMode,
            out,
            exceptionFlags
        );

endmodule

`endif /* __HARDFLOAT_ADDRECFN_V__ */

`endif /* ADDRECFN */

//-----------------------------------------------------------
// Wrapper of placeholder AddRecFN__expWidth_9__sigWidth_23
//-----------------------------------------------------------

`ifndef ADDRECFN__EXPWIDTH_9__SIGWIDTH_23
`define ADDRECFN__EXPWIDTH_9__SIGWIDTH_23

module AddRecFN__expWidth_9__sigWidth_23
(
  input logic reset,
  input logic clk,
  input logic [33-1:0] a ,
  input logic [33-1:0] b ,
  input logic [1-1:0] control ,
  output logic [5-1:0] exceptionFlags ,
  output logic [33-1:0] out ,
  input logic [3-1:0] roundingMode ,
  input logic [1-1:0] subOp 
);
  addRecFN
  #(
    .expWidth( 9 ),
    .sigWidth( 23 )
  ) v
  (
    .a( a ),
    .b( b ),
    .control( control ),
    .exceptionFlags( exceptionFlags ),
    .out( out ),
    .roundingMode( roundingMode ),
    .subOp( subOp )
  );
endmodule

`endif /* ADDRECFN__EXPWIDTH_9__SIGWIDTH_23 */



// PyMTL VerilogPlaceholder RecFNToFN Definition
// At /cgra/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/RecFNToFNRTL.py

//***********************************************************
// Pickled source file of placeholder RecFNToFN__expWidth_9__sigWidth_23
//***********************************************************

//-----------------------------------------------------------
// Dependency of placeholder RecFNToFN
//-----------------------------------------------------------

`ifndef RECFNTOFN
`define RECFNTOFN

// The source code below are included because they are specified
// as the v_libs Verilog placeholder option of component RecFNToFN__expWidth_9__sigWidth_23.

// If you get a duplicated def error from files included below, please
// make sure they are included either through the v_libs option or the
// explicit `include statement in the Verilog source code -- if they
// appear in both then they will be included twice!

`line 1 "/cgra/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/HardFloat_primitives.v" 0
`ifndef __HARDFLOAT_PRIMITIVES_VI__
`define __HARDFLOAT_PRIMITIVES_VI__

/*============================================================================

This Verilog source file is part of the Berkeley HardFloat IEEE Floating-Point
Arithmetic Package, Release 1, by John R. Hauser.

Copyright 2019 The Regents of the University of California.  All rights
reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
    this list of conditions, and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions, and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

 3. Neither the name of the University nor the names of its contributors may
    be used to endorse or promote products derived from this software without
    specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=============================================================================*/

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    reverse#(parameter width = 1) (
        input [(width - 1):0] in, output [(width - 1):0] out
    );

    genvar ix;
    generate
        for (ix = 0; ix < width; ix = ix + 1) begin :Bit
            assign out[ix] = in[width - 1 - ix];
        end
    endgenerate

endmodule

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    lowMaskHiLo#(
        parameter inWidth = 1,
        parameter topBound = 1,
        parameter bottomBound = 0
    ) (
        input [(inWidth - 1):0] in,
        output [(topBound - bottomBound - 1):0] out
    );

    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    localparam numInVals = 1<<inWidth;
    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    wire signed [numInVals:0] c;
    assign c[numInVals] = 1;
    assign c[(numInVals - 1):0] = 0;
    wire [(topBound - bottomBound - 1):0] reverseOut =
        (c>>>in)>>(numInVals - topBound);
    reverse#(topBound - bottomBound) reverse(reverseOut, out);

endmodule

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    lowMaskLoHi#(
        parameter inWidth = 1,
        parameter topBound = 0,
        parameter bottomBound = 1
    ) (
        input [(inWidth - 1):0] in,
        output [(bottomBound - topBound - 1):0] out
    );

    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    localparam numInVals = 1<<inWidth;
    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    wire signed [numInVals:0] c;
    assign c[numInVals] = 1;
    assign c[(numInVals - 1):0] = 0;
    wire [(bottomBound - topBound - 1):0] reverseOut =
        (c>>>~in)>>(topBound + 1);
    reverse#(bottomBound - topBound) reverse(reverseOut, out);

endmodule

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    countLeadingZeros#(parameter inWidth = 1, parameter countWidth = 1) (
        input [(inWidth - 1):0] in, output [(countWidth - 1):0] count
    );

    wire [(inWidth - 1):0] reverseIn;
    reverse#(inWidth) reverse_in(in, reverseIn);
    wire [inWidth:0] oneLeastReverseIn =
        {1'b1, reverseIn} & ({1'b0, ~reverseIn} + 1);
    genvar ix;
    generate
        for (ix = 0; ix <= inWidth; ix = ix + 1) begin :Bit
            wire [(countWidth - 1):0] countSoFar;
            if (ix == 0) begin
                assign countSoFar = 0;
            end else begin
                assign countSoFar =
                    Bit[ix - 1].countSoFar | (oneLeastReverseIn[ix] ? ix : 0);
                if (ix == inWidth) assign count = countSoFar;
            end
        end
    endgenerate

endmodule

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    compressBy2#(parameter inWidth = 1) (
        input [(inWidth - 1):0] in, output [((inWidth - 1)/2):0] out
    );

    localparam maxBitNumReduced = (inWidth - 1)/2;
    genvar ix;
    generate
        for (ix = 0; ix < maxBitNumReduced; ix = ix + 1) begin :Bit
            assign out[ix] = |in[(ix*2 + 1):ix*2];
        end
    endgenerate
    assign out[maxBitNumReduced] = |in[(inWidth - 1):maxBitNumReduced*2];

endmodule

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    compressBy4#(parameter inWidth = 1) (
        input [(inWidth - 1):0] in, output [(inWidth - 1)/4:0] out
    );

    localparam maxBitNumReduced = (inWidth - 1)/4;
    genvar ix;
    generate
        for (ix = 0; ix < maxBitNumReduced; ix = ix + 1) begin :Bit
            assign out[ix] = |in[(ix*4 + 3):ix*4];
        end
    endgenerate
    assign out[maxBitNumReduced] = |in[(inWidth - 1):maxBitNumReduced*4];

endmodule

`endif /* __HARDFLOAT_PRIMITIVES_VI__ */
`line 1 "/cgra/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/isSigNaNRecFN.v" 0
`ifndef __HARDFLOAT_ISSIGNANRECFN_V__
`define __HARDFLOAT_ISSIGNANRECFN_V__

/*============================================================================

This Verilog source file is part of the Berkeley HardFloat IEEE Floating-Point
Arithmetic Package, Release 1, by John R. Hauser.

Copyright 2019 The Regents of the University of California.  All rights
reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
    this list of conditions, and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions, and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

 3. Neither the name of the University nor the names of its contributors may
    be used to endorse or promote products derived from this software without
    specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=============================================================================*/

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    isSigNaNRecFN#(parameter expWidth = 3, parameter sigWidth = 3) (
        input [(expWidth + sigWidth):0] in, output isSigNaN
    );

    wire isNaN =
        (in[(expWidth + sigWidth - 1):(expWidth + sigWidth - 3)] == 'b111);
    assign isSigNaN = isNaN && !in[sigWidth - 2];

endmodule

`endif /* __HARDFLOAT_ISSIGNANRECFN_V__ */
`line 1 "/cgra/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/HardFloat_rawFN.v" 0
`ifndef __HARDFLOAT_RAWFN_VI__
`define __HARDFLOAT_RAWFN_VI__

/*============================================================================

This Verilog source file is part of the Berkeley HardFloat IEEE Floating-Point
Arithmetic Package, Release 1, by John R. Hauser.

Copyright 2019 The Regents of the University of California.  All rights
reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
    this list of conditions, and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions, and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

 3. Neither the name of the University nor the names of its contributors may
    be used to endorse or promote products derived from this software without
    specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=============================================================================*/

`line 1 "/cgra/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/HardFloat_consts.vi" 0
`ifndef __HARDFLOAT_CONSTS_VI__
`define __HARDFLOAT_CONSTS_VI__

/*============================================================================

This Verilog include file is part of the Berkeley HardFloat IEEE Floating-
Point Arithmetic Package, Release 1, by John R. Hauser.

Copyright 2019 The Regents of the University of California.  All rights
reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
    this list of conditions, and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions, and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

 3. Neither the name of the University nor the names of its contributors may
    be used to endorse or promote products derived from this software without
    specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=============================================================================*/

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/
`define round_near_even   3'b000
`define round_minMag      3'b001
`define round_min         3'b010
`define round_max         3'b011
`define round_near_maxMag 3'b100
`define round_odd         3'b110

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/
`define floatControlWidth 1
`define flControl_tininessBeforeRounding 1'b0
`define flControl_tininessAfterRounding  1'b1

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/
`define flRoundOpt_sigMSBitAlwaysZero  1
`define flRoundOpt_subnormsAlwaysExact 2
`define flRoundOpt_neverUnderflows     4
`define flRoundOpt_neverOverflows      8

`endif /* __HARDFLOAT_CONSTS_VI__ */

`line 40 "/cgra/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/HardFloat_rawFN.v" 0
`line 1 "/cgra/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/HardFloat_specialize.vi" 0
`ifndef __HARDFLOAT_SPECIALIZE_VI__
`define __HARDFLOAT_SPECIALIZE_VI__

/*============================================================================

This Verilog source file is part of the Berkeley HardFloat IEEE Floating-Point
Arithmetic Package, Release 1, by John R. Hauser.

Copyright 2019 The Regents of the University of California.  All rights
reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
    this list of conditions, and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions, and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

 3. Neither the name of the University nor the names of its contributors may
    be used to endorse or promote products derived from this software without
    specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=============================================================================*/

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    iNFromException#(parameter width = 1) (
        input signedOut,
        input isNaN,
        input sign,
        output [(width - 1):0] out
    );

    wire maxInt = isNaN || !sign;
    assign out = {signedOut ^ maxInt, {(width - 1){maxInt}}};

endmodule

`endif /* __HARDFLOAT_SPECIALIZE_VI__ */

`line 41 "/cgra/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/HardFloat_rawFN.v" 0

/* ===================== Adding some extra include files ================ */
`line 1 "/cgra/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/RISCV/HardFloat_specialize.vi" 0
`ifndef __RISCV_HARDFLOAT_SPECIALIZE_VI__
`define __RISCV_HARDFLOAT_SPECIALIZE_VI__

/*============================================================================

This Verilog include file is part of the Berkeley HardFloat IEEE Floating-
Point Arithmetic Package, Release 1, by John R. Hauser.

Copyright 2019 The Regents of the University of California.  All rights
reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
    this list of conditions, and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions, and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

 3. Neither the name of the University nor the names of its contributors may
    be used to endorse or promote products derived from this software without
    specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=============================================================================*/

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/
`define flControl_default `flControl_tininessAfterRounding

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/
//`define HardFloat_propagateNaNPayloads

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/
`define HardFloat_signDefaultNaN 0
`define HardFloat_fractDefaultNaN(sigWidth) {1'b1, {((sigWidth) - 2){1'b0}}}

`endif /* __RISCV_HARDFLOAT_SPECIALIZE_VI__ */

`line 44 "/cgra/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/HardFloat_rawFN.v" 0
/* ====================================================================== */

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    recFNToRawFN#(parameter expWidth = 3, parameter sigWidth = 3) (
        input [(expWidth + sigWidth):0] in,
        output isNaN,
        output isInf,
        output isZero,
        output sign,
        output signed [(expWidth + 1):0] sExp,
        output [sigWidth:0] sig
    );

    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    wire [expWidth:0] exp;
    wire [(sigWidth - 2):0] fract;
    assign {sign, exp, fract} = in;
    wire isSpecial = (exp>>(expWidth - 1) == 'b11);
    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    assign isNaN = isSpecial &&  exp[expWidth - 2];
    assign isInf = isSpecial && !exp[expWidth - 2];
    assign isZero = (exp>>(expWidth - 2) == 'b000);
    assign sExp = exp;
    assign sig = {1'b0, !isZero, fract};

endmodule

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    roundAnyRawFNToRecFN#(
        parameter inExpWidth = 3,
        parameter inSigWidth = 3,
        parameter outExpWidth = 3,
        parameter outSigWidth = 3,
        parameter options = 0
    ) (
        input [(`floatControlWidth - 1):0] control,
        input invalidExc,     // overrides 'infiniteExc' and 'in_*' inputs
        input infiniteExc,    // overrides 'in_*' inputs except 'in_sign'
        input in_isNaN,
        input in_isInf,
        input in_isZero,
        input in_sign,
        input signed [(inExpWidth + 1):0] in_sExp,   // limited range allowed
        input [inSigWidth:0] in_sig,
        input [2:0] roundingMode,
        output [(outExpWidth + outSigWidth):0] out,
        output [4:0] exceptionFlags
    );

    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    localparam sigMSBitAlwaysZero =
        ((options & `flRoundOpt_sigMSBitAlwaysZero) != 0);
    localparam effectiveInSigWidth =
        sigMSBitAlwaysZero ? inSigWidth : inSigWidth + 1;
    localparam neverUnderflows =
        ((options
              & (`flRoundOpt_neverUnderflows
                     | `flRoundOpt_subnormsAlwaysExact))
             != 0)
            || (inExpWidth < outExpWidth);
    localparam neverOverflows =
        ((options & `flRoundOpt_neverOverflows) != 0)
            || (inExpWidth < outExpWidth);
    localparam adjustedExpWidth =
          (inExpWidth < outExpWidth) ? outExpWidth + 1
        : (inExpWidth == outExpWidth) ? inExpWidth + 2
        : inExpWidth + 3;
    localparam outNaNExp = 7<<(outExpWidth - 2);
    localparam outInfExp = 6<<(outExpWidth - 2);
    localparam outMaxFiniteExp = outInfExp - 1;
    localparam outMinNormExp = (1<<(outExpWidth - 1)) + 2;
    localparam outMinNonzeroExp = outMinNormExp - outSigWidth + 1;
    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    wire roundingMode_near_even   = (roundingMode == `round_near_even);
    wire roundingMode_minMag      = (roundingMode == `round_minMag);
    wire roundingMode_min         = (roundingMode == `round_min);
    wire roundingMode_max         = (roundingMode == `round_max);
    wire roundingMode_near_maxMag = (roundingMode == `round_near_maxMag);
    wire roundingMode_odd         = (roundingMode == `round_odd);
    wire roundMagUp =
        (roundingMode_min && in_sign) || (roundingMode_max && !in_sign);
    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    wire isNaNOut = invalidExc || (!infiniteExc && in_isNaN);
`ifdef HardFloat_propagateNaNPayloads
    wire propagateNaNPayload = isNaNOut;
`else
    wire propagateNaNPayload = 0;
`endif
    wire signed [(adjustedExpWidth - 1):0] sAdjustedExp =
        in_sExp + ((1<<outExpWidth) - (1<<inExpWidth));
    wire [(outSigWidth + 2):0] adjustedSig;
    generate
        if (inSigWidth <= outSigWidth + 2) begin
            assign adjustedSig = in_sig<<(outSigWidth - inSigWidth + 2);
        end else begin
            assign adjustedSig =
                {in_sig[inSigWidth:(inSigWidth - outSigWidth - 1)],
                 |in_sig[(inSigWidth - outSigWidth - 2):0]};
        end
    endgenerate
    wire doShiftSigDown1 =
        sigMSBitAlwaysZero ? 0 : adjustedSig[outSigWidth + 2];
    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    wire [outExpWidth:0] common_expOut;
    wire [(outSigWidth - 2):0] common_fractOut;
    wire common_overflow, common_totalUnderflow, common_underflow;
    wire common_inexact;
    generate
        if (
            neverOverflows && neverUnderflows
                && (effectiveInSigWidth <= outSigWidth)
        ) begin
            /*----------------------------------------------------------------
            *----------------------------------------------------------------*/
            assign common_expOut = sAdjustedExp + doShiftSigDown1;
            assign common_fractOut =
                doShiftSigDown1 ? adjustedSig>>3 : adjustedSig>>2;
            assign common_overflow       = 0;
            assign common_totalUnderflow = 0;
            assign common_underflow      = 0;
            assign common_inexact        = 0;
        end else begin
            /*----------------------------------------------------------------
            *----------------------------------------------------------------*/
            wire [(outSigWidth + 2):0] roundMask;
            if (neverUnderflows) begin
                assign roundMask = {doShiftSigDown1, 2'b11};
            end else begin
                wire [outSigWidth:0] roundMask_main;
                lowMaskLoHi#(
                    outExpWidth + 1,
                    outMinNormExp - outSigWidth - 1,
                    outMinNormExp
                ) lowMask_roundMask(
                        sAdjustedExp[outExpWidth:0]
                            | (propagateNaNPayload ? 1'b1<<outExpWidth : 1'b0),
                        roundMask_main
                    );
                assign roundMask = {roundMask_main | doShiftSigDown1, 2'b11};
            end
            wire [(outSigWidth + 2):0] shiftedRoundMask = roundMask>>1;
            wire [(outSigWidth + 2):0] roundPosMask =
                ~shiftedRoundMask & roundMask;
            wire roundPosBit =
                (|(adjustedSig[(outSigWidth + 2):3]
                       & roundPosMask[(outSigWidth + 2):3]))
                    || ((|(adjustedSig[2:0] & roundPosMask[2:0]))
                            && !propagateNaNPayload);
            wire anyRoundExtra =
                (|(adjustedSig[(outSigWidth + 2):3]
                       & shiftedRoundMask[(outSigWidth + 2):3]))
                    || ((|(adjustedSig[2:0] & shiftedRoundMask[2:0]))
                            && !propagateNaNPayload);
            wire anyRound = roundPosBit || anyRoundExtra;
            /*----------------------------------------------------------------
            *----------------------------------------------------------------*/
            wire roundIncr =
                ((roundingMode_near_even || roundingMode_near_maxMag)
                     && roundPosBit)
                    || (roundMagUp && anyRound);
            wire [(outSigWidth + 1):0] roundedSig =
                roundIncr
                    ? (((adjustedSig | roundMask)>>2) + 1)
                          & ~(roundingMode_near_even && roundPosBit
                                  && !anyRoundExtra
                                  ? roundMask>>1 : 0)
                    : (adjustedSig & ~roundMask)>>2
                          | (roundingMode_odd && anyRound
                                 ? roundPosMask>>1 : 0);
            wire signed [adjustedExpWidth:0] sExtAdjustedExp = sAdjustedExp;
            wire signed [adjustedExpWidth:0] sRoundedExp =
                sExtAdjustedExp + (roundedSig>>outSigWidth);
            /*----------------------------------------------------------------
            *----------------------------------------------------------------*/
            assign common_expOut = sRoundedExp;
            assign common_fractOut =
                doShiftSigDown1 ? roundedSig>>1 : roundedSig;
            assign common_overflow =
                neverOverflows ? 0 : (sRoundedExp>>>(outExpWidth - 1) >= 3);
            assign common_totalUnderflow =
                neverUnderflows ? 0 : (sRoundedExp < outMinNonzeroExp);
            /*----------------------------------------------------------------
            *----------------------------------------------------------------*/
            wire unboundedRange_roundPosBit =
                doShiftSigDown1 ? adjustedSig[2] : adjustedSig[1];
            wire unboundedRange_anyRound =
                (doShiftSigDown1 && adjustedSig[2]) || (|adjustedSig[1:0]);
            wire unboundedRange_roundIncr =
                ((roundingMode_near_even || roundingMode_near_maxMag)
                     && unboundedRange_roundPosBit)
                    || (roundMagUp && unboundedRange_anyRound);
            wire roundCarry =
                doShiftSigDown1
                    ? roundedSig[outSigWidth + 1] : roundedSig[outSigWidth];
            assign common_underflow =
                neverUnderflows ? 0
                    : common_totalUnderflow
                          || (anyRound && (sAdjustedExp>>>outExpWidth <= 0)
                                  && (doShiftSigDown1
                                          ? roundMask[3] : roundMask[2])
                                  && !(((control
                                           & `flControl_tininessAfterRounding)
                                            != 0)
                                           && !(doShiftSigDown1 ? roundMask[4]
                                                    : roundMask[3])
                                           && roundCarry && roundPosBit
                                           && unboundedRange_roundIncr));
            /*----------------------------------------------------------------
            *----------------------------------------------------------------*/
            assign common_inexact = common_totalUnderflow || anyRound;
        end
    endgenerate
    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    wire notNaN_isSpecialInfOut = infiniteExc || in_isInf;
    wire commonCase = !isNaNOut && !notNaN_isSpecialInfOut && !in_isZero;
    wire overflow  = commonCase && common_overflow;
    wire underflow = commonCase && common_underflow;
    wire inexact = overflow || (commonCase && common_inexact);
    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    wire overflow_roundMagUp =
        roundingMode_near_even || roundingMode_near_maxMag || roundMagUp;
    wire pegMinNonzeroMagOut =
        commonCase && common_totalUnderflow
            && (roundMagUp || roundingMode_odd);
    wire pegMaxFiniteMagOut = overflow && !overflow_roundMagUp;
    wire notNaN_isInfOut =
        notNaN_isSpecialInfOut || (overflow && overflow_roundMagUp);
    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
`ifdef HardFloat_propagateNaNPayloads
    wire signOut = in_sign;
`else
    wire signOut = isNaNOut ? `HardFloat_signDefaultNaN : in_sign;
`endif
    wire [outExpWidth:0] expOut =
        (common_expOut
             & ~(in_isZero || common_totalUnderflow ? 7<<(outExpWidth - 2) : 0)
             & ~(pegMinNonzeroMagOut               ? ~outMinNonzeroExp    : 0)
             & ~(pegMaxFiniteMagOut                ? 1<<(outExpWidth - 1) : 0)
             & ~(notNaN_isInfOut                   ? 1<<(outExpWidth - 2) : 0))
            | (pegMinNonzeroMagOut ? outMinNonzeroExp : 0)
            | (pegMaxFiniteMagOut  ? outMaxFiniteExp  : 0)
            | (notNaN_isInfOut     ? outInfExp        : 0)
            | (isNaNOut            ? outNaNExp        : 0);
`ifdef HardFloat_propagateNaNPayloads
    wire [(outSigWidth - 2):0] fractOut =
        {isNaNOut
             || (!in_isZero && !common_totalUnderflow
                     && common_fractOut[outSigWidth - 2]),
         isNaNOut || (!in_isZero && !common_totalUnderflow)
             ? common_fractOut[(outSigWidth - 3):0] : 1'b0}
            | {(outSigWidth - 1){pegMaxFiniteMagOut}};
`else
    wire [(outSigWidth - 2):0] fractOut =
          (isNaNOut ? `HardFloat_fractDefaultNaN(outSigWidth) : 0)
        | (!in_isZero && !common_totalUnderflow
               ? common_fractOut & `HardFloat_fractDefaultNaN(outSigWidth) : 0)
        | (!isNaNOut && !in_isZero && !common_totalUnderflow
               ? common_fractOut & ~`HardFloat_fractDefaultNaN(outSigWidth)
               : 0)
        | {(outSigWidth - 1){pegMaxFiniteMagOut}};
`endif
    assign out = {signOut, expOut, fractOut};
    assign exceptionFlags =
        {invalidExc, infiniteExc, overflow, underflow, inexact};

endmodule

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    roundRawFNToRecFN#(
        parameter expWidth = 3,
        parameter sigWidth = 3,
        parameter options = 0
    ) (
        input [(`floatControlWidth - 1):0] control,
        input invalidExc,     // overrides 'infiniteExc' and 'in_*' inputs
        input infiniteExc,    // overrides 'in_*' inputs except 'in_sign'
        input in_isNaN,
        input in_isInf,
        input in_isZero,
        input in_sign,
        input signed [(expWidth + 1):0] in_sExp,   // limited range allowed
        input [(sigWidth + 2):0] in_sig,
        input [2:0] roundingMode,
        output [(expWidth + sigWidth):0] out,
        output [4:0] exceptionFlags
    );

    roundAnyRawFNToRecFN#(expWidth, sigWidth + 2, expWidth, sigWidth, options)
        roundAnyRawFNToRecFN(
            control,
            invalidExc,
            infiniteExc,
            in_isNaN,
            in_isInf,
            in_isZero,
            in_sign,
            in_sExp,
            in_sig,
            roundingMode,
            out,
            exceptionFlags
        );

endmodule

`endif /* __HARDFLOAT_RAWFN_VI__ */
`line 1 "/cgra/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/recFNToRecFN.v" 0
`ifndef __HARDFLOAT_RECFNTORECFN_V__
`define __HARDFLOAT_RECFNTORECFN_V__

/*============================================================================

This Verilog source file is part of the Berkeley HardFloat IEEE Floating-Point
Arithmetic Package, Release 1, by John R. Hauser.

Copyright 2019 The Regents of the University of California.  All rights
reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
    this list of conditions, and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions, and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

 3. Neither the name of the University nor the names of its contributors may
    be used to endorse or promote products derived from this software without
    specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=============================================================================*/

`line 1 "/cgra/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/HardFloat_consts.vi" 0
`ifndef __HARDFLOAT_CONSTS_VI__
`define __HARDFLOAT_CONSTS_VI__

/*============================================================================

This Verilog include file is part of the Berkeley HardFloat IEEE Floating-
Point Arithmetic Package, Release 1, by John R. Hauser.

Copyright 2019 The Regents of the University of California.  All rights
reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
    this list of conditions, and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions, and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

 3. Neither the name of the University nor the names of its contributors may
    be used to endorse or promote products derived from this software without
    specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=============================================================================*/

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/
`define round_near_even   3'b000
`define round_minMag      3'b001
`define round_min         3'b010
`define round_max         3'b011
`define round_near_maxMag 3'b100
`define round_odd         3'b110

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/
`define floatControlWidth 1
`define flControl_tininessBeforeRounding 1'b0
`define flControl_tininessAfterRounding  1'b1

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/
`define flRoundOpt_sigMSBitAlwaysZero  1
`define flRoundOpt_subnormsAlwaysExact 2
`define flRoundOpt_neverUnderflows     4
`define flRoundOpt_neverOverflows      8

`endif /* __HARDFLOAT_CONSTS_VI__ */

`line 40 "/cgra/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/recFNToRecFN.v" 0
`line 1 "/cgra/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/HardFloat_specialize.vi" 0
`ifndef __HARDFLOAT_SPECIALIZE_VI__
`define __HARDFLOAT_SPECIALIZE_VI__

/*============================================================================

This Verilog source file is part of the Berkeley HardFloat IEEE Floating-Point
Arithmetic Package, Release 1, by John R. Hauser.

Copyright 2019 The Regents of the University of California.  All rights
reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
    this list of conditions, and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions, and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

 3. Neither the name of the University nor the names of its contributors may
    be used to endorse or promote products derived from this software without
    specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=============================================================================*/

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    iNFromException#(parameter width = 1) (
        input signedOut,
        input isNaN,
        input sign,
        output [(width - 1):0] out
    );

    wire maxInt = isNaN || !sign;
    assign out = {signedOut ^ maxInt, {(width - 1){maxInt}}};

endmodule

`endif /* __HARDFLOAT_SPECIALIZE_VI__ */

`line 41 "/cgra/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/recFNToRecFN.v" 0

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    recFNToRecFN#(
        parameter inExpWidth = 3,
        parameter inSigWidth = 3,
        parameter outExpWidth = 3,
        parameter outSigWidth = 3
    ) (
        input [(`floatControlWidth - 1):0] control,
        input [(inExpWidth + inSigWidth):0] in,
        input [2:0] roundingMode,
        output [(outExpWidth + outSigWidth):0] out,
        output [4:0] exceptionFlags
    );

    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    wire isNaN, isInf, isZero, sign;
    wire signed [(inExpWidth + 1):0] sExpIn;
    wire [inSigWidth:0] sigIn;
    recFNToRawFN#(inExpWidth, inSigWidth)
        inToRawIn(in, isNaN, isInf, isZero, sign, sExpIn, sigIn);
    wire isSigNaN;
    isSigNaNRecFN#(inExpWidth, inSigWidth) isSigNaNIn(in, isSigNaN);
    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    generate
        if ((inExpWidth == outExpWidth) && (inSigWidth <= outSigWidth)) begin
            /*----------------------------------------------------------------
            *----------------------------------------------------------------*/
            wire [(outExpWidth + outSigWidth):0] tentativeOut =
                in<<(outSigWidth - inSigWidth);
`ifdef HardFloat_propagateNaNPayloads
            assign out = tentativeOut | isNaN<<(outSigWidth - 2);
`else
            assign out =
                isNaN
                    ? {`HardFloat_signDefaultNaN, 3'b111}
                          <<(outExpWidth + outSigWidth - 3)
                          | `HardFloat_fractDefaultNaN(outSigWidth)
                    : tentativeOut;
`endif
            assign exceptionFlags = {isSigNaN, 4'b0000};
        end else begin
            /*----------------------------------------------------------------
            *----------------------------------------------------------------*/
            roundAnyRawFNToRecFN#(
                inExpWidth,
                inSigWidth,
                outExpWidth,
                outSigWidth,
                `flRoundOpt_sigMSBitAlwaysZero
            ) roundRawInToOut(
                    control,
                    isSigNaN,
                    1'b0,
                    isNaN,
                    isInf,
                    isZero,
                    sign,
                    sExpIn,
                    sigIn,
                    roundingMode,
                    out,
                    exceptionFlags
                );
        end
    endgenerate

endmodule

`endif /* __HARDFLOAT_RECFNTORECFN_V__ */
`line 1 "/cgra/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/HardFloat_specialize.vi" 0
`ifndef __HARDFLOAT_SPECIALIZE_VI__
`define __HARDFLOAT_SPECIALIZE_VI__

/*============================================================================

This Verilog source file is part of the Berkeley HardFloat IEEE Floating-Point
Arithmetic Package, Release 1, by John R. Hauser.

Copyright 2019 The Regents of the University of California.  All rights
reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
    this list of conditions, and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions, and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

 3. Neither the name of the University nor the names of its contributors may
    be used to endorse or promote products derived from this software without
    specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=============================================================================*/

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    iNFromException#(parameter width = 1) (
        input signedOut,
        input isNaN,
        input sign,
        output [(width - 1):0] out
    );

    wire maxInt = isNaN || !sign;
    assign out = {signedOut ^ maxInt, {(width - 1){maxInt}}};

endmodule

`endif /* __HARDFLOAT_SPECIALIZE_VI__ */

// End of all v_libs files for component RecFNToFN__expWidth_9__sigWidth_23

`line 1 "/cgra/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/recFNToFN.v" 0
`ifndef __HARDFLOAT_RECFNTOFN_V__
`define __HARDFLOAT_RECFNTOFN_V__

/*============================================================================

This Verilog source file is part of the Berkeley HardFloat IEEE Floating-Point
Arithmetic Package, Release 1, by John R. Hauser.

Copyright 2019 The Regents of the University of California.  All rights
reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
    this list of conditions, and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions, and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

 3. Neither the name of the University nor the names of its contributors may
    be used to endorse or promote products derived from this software without
    specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=============================================================================*/

/* ============= Added section to include some files ================== */
// verilator lint_off MODDUP
`line 1 "/cgra/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/includeFile.v" 0
/* ============= Added section to include some files ================== */
`line 1 "/cgra/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/HardFloat_rawFN.v" 0
`ifndef __HARDFLOAT_RAWFN_VI__
`define __HARDFLOAT_RAWFN_VI__

/*============================================================================

This Verilog source file is part of the Berkeley HardFloat IEEE Floating-Point
Arithmetic Package, Release 1, by John R. Hauser.

Copyright 2019 The Regents of the University of California.  All rights
reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
    this list of conditions, and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions, and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

 3. Neither the name of the University nor the names of its contributors may
    be used to endorse or promote products derived from this software without
    specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=============================================================================*/

`line 1 "/cgra/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/HardFloat_consts.vi" 0
`ifndef __HARDFLOAT_CONSTS_VI__
`define __HARDFLOAT_CONSTS_VI__

/*============================================================================

This Verilog include file is part of the Berkeley HardFloat IEEE Floating-
Point Arithmetic Package, Release 1, by John R. Hauser.

Copyright 2019 The Regents of the University of California.  All rights
reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
    this list of conditions, and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions, and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

 3. Neither the name of the University nor the names of its contributors may
    be used to endorse or promote products derived from this software without
    specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=============================================================================*/

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/
`define round_near_even   3'b000
`define round_minMag      3'b001
`define round_min         3'b010
`define round_max         3'b011
`define round_near_maxMag 3'b100
`define round_odd         3'b110

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/
`define floatControlWidth 1
`define flControl_tininessBeforeRounding 1'b0
`define flControl_tininessAfterRounding  1'b1

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/
`define flRoundOpt_sigMSBitAlwaysZero  1
`define flRoundOpt_subnormsAlwaysExact 2
`define flRoundOpt_neverUnderflows     4
`define flRoundOpt_neverOverflows      8

`endif /* __HARDFLOAT_CONSTS_VI__ */

`line 40 "/cgra/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/HardFloat_rawFN.v" 0
`line 1 "/cgra/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/HardFloat_specialize.vi" 0
`ifndef __HARDFLOAT_SPECIALIZE_VI__
`define __HARDFLOAT_SPECIALIZE_VI__

/*============================================================================

This Verilog source file is part of the Berkeley HardFloat IEEE Floating-Point
Arithmetic Package, Release 1, by John R. Hauser.

Copyright 2019 The Regents of the University of California.  All rights
reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
    this list of conditions, and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions, and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

 3. Neither the name of the University nor the names of its contributors may
    be used to endorse or promote products derived from this software without
    specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=============================================================================*/

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    iNFromException#(parameter width = 1) (
        input signedOut,
        input isNaN,
        input sign,
        output [(width - 1):0] out
    );

    wire maxInt = isNaN || !sign;
    assign out = {signedOut ^ maxInt, {(width - 1){maxInt}}};

endmodule

`endif /* __HARDFLOAT_SPECIALIZE_VI__ */

`line 41 "/cgra/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/HardFloat_rawFN.v" 0

/* ===================== Adding some extra include files ================ */
`line 1 "/cgra/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/RISCV/HardFloat_specialize.vi" 0
`ifndef __RISCV_HARDFLOAT_SPECIALIZE_VI__
`define __RISCV_HARDFLOAT_SPECIALIZE_VI__

/*============================================================================

This Verilog include file is part of the Berkeley HardFloat IEEE Floating-
Point Arithmetic Package, Release 1, by John R. Hauser.

Copyright 2019 The Regents of the University of California.  All rights
reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
    this list of conditions, and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions, and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

 3. Neither the name of the University nor the names of its contributors may
    be used to endorse or promote products derived from this software without
    specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=============================================================================*/

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/
`define flControl_default `flControl_tininessAfterRounding

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/
//`define HardFloat_propagateNaNPayloads

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/
`define HardFloat_signDefaultNaN 0
`define HardFloat_fractDefaultNaN(sigWidth) {1'b1, {((sigWidth) - 2){1'b0}}}

`endif /* __RISCV_HARDFLOAT_SPECIALIZE_VI__ */

`line 44 "/cgra/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/HardFloat_rawFN.v" 0
/* ====================================================================== */

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    recFNToRawFN#(parameter expWidth = 3, parameter sigWidth = 3) (
        input [(expWidth + sigWidth):0] in,
        output isNaN,
        output isInf,
        output isZero,
        output sign,
        output signed [(expWidth + 1):0] sExp,
        output [sigWidth:0] sig
    );

    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    wire [expWidth:0] exp;
    wire [(sigWidth - 2):0] fract;
    assign {sign, exp, fract} = in;
    wire isSpecial = (exp>>(expWidth - 1) == 'b11);
    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    assign isNaN = isSpecial &&  exp[expWidth - 2];
    assign isInf = isSpecial && !exp[expWidth - 2];
    assign isZero = (exp>>(expWidth - 2) == 'b000);
    assign sExp = exp;
    assign sig = {1'b0, !isZero, fract};

endmodule

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    roundAnyRawFNToRecFN#(
        parameter inExpWidth = 3,
        parameter inSigWidth = 3,
        parameter outExpWidth = 3,
        parameter outSigWidth = 3,
        parameter options = 0
    ) (
        input [(`floatControlWidth - 1):0] control,
        input invalidExc,     // overrides 'infiniteExc' and 'in_*' inputs
        input infiniteExc,    // overrides 'in_*' inputs except 'in_sign'
        input in_isNaN,
        input in_isInf,
        input in_isZero,
        input in_sign,
        input signed [(inExpWidth + 1):0] in_sExp,   // limited range allowed
        input [inSigWidth:0] in_sig,
        input [2:0] roundingMode,
        output [(outExpWidth + outSigWidth):0] out,
        output [4:0] exceptionFlags
    );

    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    localparam sigMSBitAlwaysZero =
        ((options & `flRoundOpt_sigMSBitAlwaysZero) != 0);
    localparam effectiveInSigWidth =
        sigMSBitAlwaysZero ? inSigWidth : inSigWidth + 1;
    localparam neverUnderflows =
        ((options
              & (`flRoundOpt_neverUnderflows
                     | `flRoundOpt_subnormsAlwaysExact))
             != 0)
            || (inExpWidth < outExpWidth);
    localparam neverOverflows =
        ((options & `flRoundOpt_neverOverflows) != 0)
            || (inExpWidth < outExpWidth);
    localparam adjustedExpWidth =
          (inExpWidth < outExpWidth) ? outExpWidth + 1
        : (inExpWidth == outExpWidth) ? inExpWidth + 2
        : inExpWidth + 3;
    localparam outNaNExp = 7<<(outExpWidth - 2);
    localparam outInfExp = 6<<(outExpWidth - 2);
    localparam outMaxFiniteExp = outInfExp - 1;
    localparam outMinNormExp = (1<<(outExpWidth - 1)) + 2;
    localparam outMinNonzeroExp = outMinNormExp - outSigWidth + 1;
    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    wire roundingMode_near_even   = (roundingMode == `round_near_even);
    wire roundingMode_minMag      = (roundingMode == `round_minMag);
    wire roundingMode_min         = (roundingMode == `round_min);
    wire roundingMode_max         = (roundingMode == `round_max);
    wire roundingMode_near_maxMag = (roundingMode == `round_near_maxMag);
    wire roundingMode_odd         = (roundingMode == `round_odd);
    wire roundMagUp =
        (roundingMode_min && in_sign) || (roundingMode_max && !in_sign);
    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    wire isNaNOut = invalidExc || (!infiniteExc && in_isNaN);
`ifdef HardFloat_propagateNaNPayloads
    wire propagateNaNPayload = isNaNOut;
`else
    wire propagateNaNPayload = 0;
`endif
    wire signed [(adjustedExpWidth - 1):0] sAdjustedExp =
        in_sExp + ((1<<outExpWidth) - (1<<inExpWidth));
    wire [(outSigWidth + 2):0] adjustedSig;
    generate
        if (inSigWidth <= outSigWidth + 2) begin
            assign adjustedSig = in_sig<<(outSigWidth - inSigWidth + 2);
        end else begin
            assign adjustedSig =
                {in_sig[inSigWidth:(inSigWidth - outSigWidth - 1)],
                 |in_sig[(inSigWidth - outSigWidth - 2):0]};
        end
    endgenerate
    wire doShiftSigDown1 =
        sigMSBitAlwaysZero ? 0 : adjustedSig[outSigWidth + 2];
    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    wire [outExpWidth:0] common_expOut;
    wire [(outSigWidth - 2):0] common_fractOut;
    wire common_overflow, common_totalUnderflow, common_underflow;
    wire common_inexact;
    generate
        if (
            neverOverflows && neverUnderflows
                && (effectiveInSigWidth <= outSigWidth)
        ) begin
            /*----------------------------------------------------------------
            *----------------------------------------------------------------*/
            assign common_expOut = sAdjustedExp + doShiftSigDown1;
            assign common_fractOut =
                doShiftSigDown1 ? adjustedSig>>3 : adjustedSig>>2;
            assign common_overflow       = 0;
            assign common_totalUnderflow = 0;
            assign common_underflow      = 0;
            assign common_inexact        = 0;
        end else begin
            /*----------------------------------------------------------------
            *----------------------------------------------------------------*/
            wire [(outSigWidth + 2):0] roundMask;
            if (neverUnderflows) begin
                assign roundMask = {doShiftSigDown1, 2'b11};
            end else begin
                wire [outSigWidth:0] roundMask_main;
                lowMaskLoHi#(
                    outExpWidth + 1,
                    outMinNormExp - outSigWidth - 1,
                    outMinNormExp
                ) lowMask_roundMask(
                        sAdjustedExp[outExpWidth:0]
                            | (propagateNaNPayload ? 1'b1<<outExpWidth : 1'b0),
                        roundMask_main
                    );
                assign roundMask = {roundMask_main | doShiftSigDown1, 2'b11};
            end
            wire [(outSigWidth + 2):0] shiftedRoundMask = roundMask>>1;
            wire [(outSigWidth + 2):0] roundPosMask =
                ~shiftedRoundMask & roundMask;
            wire roundPosBit =
                (|(adjustedSig[(outSigWidth + 2):3]
                       & roundPosMask[(outSigWidth + 2):3]))
                    || ((|(adjustedSig[2:0] & roundPosMask[2:0]))
                            && !propagateNaNPayload);
            wire anyRoundExtra =
                (|(adjustedSig[(outSigWidth + 2):3]
                       & shiftedRoundMask[(outSigWidth + 2):3]))
                    || ((|(adjustedSig[2:0] & shiftedRoundMask[2:0]))
                            && !propagateNaNPayload);
            wire anyRound = roundPosBit || anyRoundExtra;
            /*----------------------------------------------------------------
            *----------------------------------------------------------------*/
            wire roundIncr =
                ((roundingMode_near_even || roundingMode_near_maxMag)
                     && roundPosBit)
                    || (roundMagUp && anyRound);
            wire [(outSigWidth + 1):0] roundedSig =
                roundIncr
                    ? (((adjustedSig | roundMask)>>2) + 1)
                          & ~(roundingMode_near_even && roundPosBit
                                  && !anyRoundExtra
                                  ? roundMask>>1 : 0)
                    : (adjustedSig & ~roundMask)>>2
                          | (roundingMode_odd && anyRound
                                 ? roundPosMask>>1 : 0);
            wire signed [adjustedExpWidth:0] sExtAdjustedExp = sAdjustedExp;
            wire signed [adjustedExpWidth:0] sRoundedExp =
                sExtAdjustedExp + (roundedSig>>outSigWidth);
            /*----------------------------------------------------------------
            *----------------------------------------------------------------*/
            assign common_expOut = sRoundedExp;
            assign common_fractOut =
                doShiftSigDown1 ? roundedSig>>1 : roundedSig;
            assign common_overflow =
                neverOverflows ? 0 : (sRoundedExp>>>(outExpWidth - 1) >= 3);
            assign common_totalUnderflow =
                neverUnderflows ? 0 : (sRoundedExp < outMinNonzeroExp);
            /*----------------------------------------------------------------
            *----------------------------------------------------------------*/
            wire unboundedRange_roundPosBit =
                doShiftSigDown1 ? adjustedSig[2] : adjustedSig[1];
            wire unboundedRange_anyRound =
                (doShiftSigDown1 && adjustedSig[2]) || (|adjustedSig[1:0]);
            wire unboundedRange_roundIncr =
                ((roundingMode_near_even || roundingMode_near_maxMag)
                     && unboundedRange_roundPosBit)
                    || (roundMagUp && unboundedRange_anyRound);
            wire roundCarry =
                doShiftSigDown1
                    ? roundedSig[outSigWidth + 1] : roundedSig[outSigWidth];
            assign common_underflow =
                neverUnderflows ? 0
                    : common_totalUnderflow
                          || (anyRound && (sAdjustedExp>>>outExpWidth <= 0)
                                  && (doShiftSigDown1
                                          ? roundMask[3] : roundMask[2])
                                  && !(((control
                                           & `flControl_tininessAfterRounding)
                                            != 0)
                                           && !(doShiftSigDown1 ? roundMask[4]
                                                    : roundMask[3])
                                           && roundCarry && roundPosBit
                                           && unboundedRange_roundIncr));
            /*----------------------------------------------------------------
            *----------------------------------------------------------------*/
            assign common_inexact = common_totalUnderflow || anyRound;
        end
    endgenerate
    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    wire notNaN_isSpecialInfOut = infiniteExc || in_isInf;
    wire commonCase = !isNaNOut && !notNaN_isSpecialInfOut && !in_isZero;
    wire overflow  = commonCase && common_overflow;
    wire underflow = commonCase && common_underflow;
    wire inexact = overflow || (commonCase && common_inexact);
    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    wire overflow_roundMagUp =
        roundingMode_near_even || roundingMode_near_maxMag || roundMagUp;
    wire pegMinNonzeroMagOut =
        commonCase && common_totalUnderflow
            && (roundMagUp || roundingMode_odd);
    wire pegMaxFiniteMagOut = overflow && !overflow_roundMagUp;
    wire notNaN_isInfOut =
        notNaN_isSpecialInfOut || (overflow && overflow_roundMagUp);
    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
`ifdef HardFloat_propagateNaNPayloads
    wire signOut = in_sign;
`else
    wire signOut = isNaNOut ? `HardFloat_signDefaultNaN : in_sign;
`endif
    wire [outExpWidth:0] expOut =
        (common_expOut
             & ~(in_isZero || common_totalUnderflow ? 7<<(outExpWidth - 2) : 0)
             & ~(pegMinNonzeroMagOut               ? ~outMinNonzeroExp    : 0)
             & ~(pegMaxFiniteMagOut                ? 1<<(outExpWidth - 1) : 0)
             & ~(notNaN_isInfOut                   ? 1<<(outExpWidth - 2) : 0))
            | (pegMinNonzeroMagOut ? outMinNonzeroExp : 0)
            | (pegMaxFiniteMagOut  ? outMaxFiniteExp  : 0)
            | (notNaN_isInfOut     ? outInfExp        : 0)
            | (isNaNOut            ? outNaNExp        : 0);
`ifdef HardFloat_propagateNaNPayloads
    wire [(outSigWidth - 2):0] fractOut =
        {isNaNOut
             || (!in_isZero && !common_totalUnderflow
                     && common_fractOut[outSigWidth - 2]),
         isNaNOut || (!in_isZero && !common_totalUnderflow)
             ? common_fractOut[(outSigWidth - 3):0] : 1'b0}
            | {(outSigWidth - 1){pegMaxFiniteMagOut}};
`else
    wire [(outSigWidth - 2):0] fractOut =
          (isNaNOut ? `HardFloat_fractDefaultNaN(outSigWidth) : 0)
        | (!in_isZero && !common_totalUnderflow
               ? common_fractOut & `HardFloat_fractDefaultNaN(outSigWidth) : 0)
        | (!isNaNOut && !in_isZero && !common_totalUnderflow
               ? common_fractOut & ~`HardFloat_fractDefaultNaN(outSigWidth)
               : 0)
        | {(outSigWidth - 1){pegMaxFiniteMagOut}};
`endif
    assign out = {signOut, expOut, fractOut};
    assign exceptionFlags =
        {invalidExc, infiniteExc, overflow, underflow, inexact};

endmodule

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    roundRawFNToRecFN#(
        parameter expWidth = 3,
        parameter sigWidth = 3,
        parameter options = 0
    ) (
        input [(`floatControlWidth - 1):0] control,
        input invalidExc,     // overrides 'infiniteExc' and 'in_*' inputs
        input infiniteExc,    // overrides 'in_*' inputs except 'in_sign'
        input in_isNaN,
        input in_isInf,
        input in_isZero,
        input in_sign,
        input signed [(expWidth + 1):0] in_sExp,   // limited range allowed
        input [(sigWidth + 2):0] in_sig,
        input [2:0] roundingMode,
        output [(expWidth + sigWidth):0] out,
        output [4:0] exceptionFlags
    );

    roundAnyRawFNToRecFN#(expWidth, sigWidth + 2, expWidth, sigWidth, options)
        roundAnyRawFNToRecFN(
            control,
            invalidExc,
            infiniteExc,
            in_isNaN,
            in_isInf,
            in_isZero,
            in_sign,
            in_sExp,
            in_sig,
            roundingMode,
            out,
            exceptionFlags
        );

endmodule

`endif /* __HARDFLOAT_RAWFN_VI__ */

`line 3 "/cgra/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/includeFile.v" 0
`line 1 "/cgra/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/recFNToRecFN.v" 0
`ifndef __HARDFLOAT_RECFNTORECFN_V__
`define __HARDFLOAT_RECFNTORECFN_V__

/*============================================================================

This Verilog source file is part of the Berkeley HardFloat IEEE Floating-Point
Arithmetic Package, Release 1, by John R. Hauser.

Copyright 2019 The Regents of the University of California.  All rights
reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
    this list of conditions, and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions, and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

 3. Neither the name of the University nor the names of its contributors may
    be used to endorse or promote products derived from this software without
    specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=============================================================================*/

`line 1 "/cgra/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/HardFloat_consts.vi" 0
`ifndef __HARDFLOAT_CONSTS_VI__
`define __HARDFLOAT_CONSTS_VI__

/*============================================================================

This Verilog include file is part of the Berkeley HardFloat IEEE Floating-
Point Arithmetic Package, Release 1, by John R. Hauser.

Copyright 2019 The Regents of the University of California.  All rights
reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
    this list of conditions, and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions, and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

 3. Neither the name of the University nor the names of its contributors may
    be used to endorse or promote products derived from this software without
    specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=============================================================================*/

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/
`define round_near_even   3'b000
`define round_minMag      3'b001
`define round_min         3'b010
`define round_max         3'b011
`define round_near_maxMag 3'b100
`define round_odd         3'b110

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/
`define floatControlWidth 1
`define flControl_tininessBeforeRounding 1'b0
`define flControl_tininessAfterRounding  1'b1

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/
`define flRoundOpt_sigMSBitAlwaysZero  1
`define flRoundOpt_subnormsAlwaysExact 2
`define flRoundOpt_neverUnderflows     4
`define flRoundOpt_neverOverflows      8

`endif /* __HARDFLOAT_CONSTS_VI__ */

`line 40 "/cgra/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/recFNToRecFN.v" 0
`line 1 "/cgra/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/HardFloat_specialize.vi" 0
`ifndef __HARDFLOAT_SPECIALIZE_VI__
`define __HARDFLOAT_SPECIALIZE_VI__

/*============================================================================

This Verilog source file is part of the Berkeley HardFloat IEEE Floating-Point
Arithmetic Package, Release 1, by John R. Hauser.

Copyright 2019 The Regents of the University of California.  All rights
reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
    this list of conditions, and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions, and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

 3. Neither the name of the University nor the names of its contributors may
    be used to endorse or promote products derived from this software without
    specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=============================================================================*/

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    iNFromException#(parameter width = 1) (
        input signedOut,
        input isNaN,
        input sign,
        output [(width - 1):0] out
    );

    wire maxInt = isNaN || !sign;
    assign out = {signedOut ^ maxInt, {(width - 1){maxInt}}};

endmodule

`endif /* __HARDFLOAT_SPECIALIZE_VI__ */

`line 41 "/cgra/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/recFNToRecFN.v" 0

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    recFNToRecFN#(
        parameter inExpWidth = 3,
        parameter inSigWidth = 3,
        parameter outExpWidth = 3,
        parameter outSigWidth = 3
    ) (
        input [(`floatControlWidth - 1):0] control,
        input [(inExpWidth + inSigWidth):0] in,
        input [2:0] roundingMode,
        output [(outExpWidth + outSigWidth):0] out,
        output [4:0] exceptionFlags
    );

    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    wire isNaN, isInf, isZero, sign;
    wire signed [(inExpWidth + 1):0] sExpIn;
    wire [inSigWidth:0] sigIn;
    recFNToRawFN#(inExpWidth, inSigWidth)
        inToRawIn(in, isNaN, isInf, isZero, sign, sExpIn, sigIn);
    wire isSigNaN;
    isSigNaNRecFN#(inExpWidth, inSigWidth) isSigNaNIn(in, isSigNaN);
    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    generate
        if ((inExpWidth == outExpWidth) && (inSigWidth <= outSigWidth)) begin
            /*----------------------------------------------------------------
            *----------------------------------------------------------------*/
            wire [(outExpWidth + outSigWidth):0] tentativeOut =
                in<<(outSigWidth - inSigWidth);
`ifdef HardFloat_propagateNaNPayloads
            assign out = tentativeOut | isNaN<<(outSigWidth - 2);
`else
            assign out =
                isNaN
                    ? {`HardFloat_signDefaultNaN, 3'b111}
                          <<(outExpWidth + outSigWidth - 3)
                          | `HardFloat_fractDefaultNaN(outSigWidth)
                    : tentativeOut;
`endif
            assign exceptionFlags = {isSigNaN, 4'b0000};
        end else begin
            /*----------------------------------------------------------------
            *----------------------------------------------------------------*/
            roundAnyRawFNToRecFN#(
                inExpWidth,
                inSigWidth,
                outExpWidth,
                outSigWidth,
                `flRoundOpt_sigMSBitAlwaysZero
            ) roundRawInToOut(
                    control,
                    isSigNaN,
                    1'b0,
                    isNaN,
                    isInf,
                    isZero,
                    sign,
                    sExpIn,
                    sigIn,
                    roundingMode,
                    out,
                    exceptionFlags
                );
        end
    endgenerate

endmodule

`endif /* __HARDFLOAT_RECFNTORECFN_V__ */

`line 4 "/cgra/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/includeFile.v" 0
`line 1 "/cgra/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/isSigNaNRecFN.v" 0
`ifndef __HARDFLOAT_ISSIGNANRECFN_V__
`define __HARDFLOAT_ISSIGNANRECFN_V__

/*============================================================================

This Verilog source file is part of the Berkeley HardFloat IEEE Floating-Point
Arithmetic Package, Release 1, by John R. Hauser.

Copyright 2019 The Regents of the University of California.  All rights
reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
    this list of conditions, and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions, and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

 3. Neither the name of the University nor the names of its contributors may
    be used to endorse or promote products derived from this software without
    specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=============================================================================*/

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    isSigNaNRecFN#(parameter expWidth = 3, parameter sigWidth = 3) (
        input [(expWidth + sigWidth):0] in, output isSigNaN
    );

    wire isNaN =
        (in[(expWidth + sigWidth - 1):(expWidth + sigWidth - 3)] == 'b111);
    assign isSigNaN = isNaN && !in[sigWidth - 2];

endmodule

`endif /* __HARDFLOAT_ISSIGNANRECFN_V__ */

`line 5 "/cgra/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/includeFile.v" 0
`line 1 "/cgra/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/HardFloat_primitives.v" 0
`ifndef __HARDFLOAT_PRIMITIVES_VI__
`define __HARDFLOAT_PRIMITIVES_VI__

/*============================================================================

This Verilog source file is part of the Berkeley HardFloat IEEE Floating-Point
Arithmetic Package, Release 1, by John R. Hauser.

Copyright 2019 The Regents of the University of California.  All rights
reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
    this list of conditions, and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions, and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

 3. Neither the name of the University nor the names of its contributors may
    be used to endorse or promote products derived from this software without
    specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=============================================================================*/

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    reverse#(parameter width = 1) (
        input [(width - 1):0] in, output [(width - 1):0] out
    );

    genvar ix;
    generate
        for (ix = 0; ix < width; ix = ix + 1) begin :Bit
            assign out[ix] = in[width - 1 - ix];
        end
    endgenerate

endmodule

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    lowMaskHiLo#(
        parameter inWidth = 1,
        parameter topBound = 1,
        parameter bottomBound = 0
    ) (
        input [(inWidth - 1):0] in,
        output [(topBound - bottomBound - 1):0] out
    );

    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    localparam numInVals = 1<<inWidth;
    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    wire signed [numInVals:0] c;
    assign c[numInVals] = 1;
    assign c[(numInVals - 1):0] = 0;
    wire [(topBound - bottomBound - 1):0] reverseOut =
        (c>>>in)>>(numInVals - topBound);
    reverse#(topBound - bottomBound) reverse(reverseOut, out);

endmodule

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    lowMaskLoHi#(
        parameter inWidth = 1,
        parameter topBound = 0,
        parameter bottomBound = 1
    ) (
        input [(inWidth - 1):0] in,
        output [(bottomBound - topBound - 1):0] out
    );

    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    localparam numInVals = 1<<inWidth;
    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    wire signed [numInVals:0] c;
    assign c[numInVals] = 1;
    assign c[(numInVals - 1):0] = 0;
    wire [(bottomBound - topBound - 1):0] reverseOut =
        (c>>>~in)>>(topBound + 1);
    reverse#(bottomBound - topBound) reverse(reverseOut, out);

endmodule

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    countLeadingZeros#(parameter inWidth = 1, parameter countWidth = 1) (
        input [(inWidth - 1):0] in, output [(countWidth - 1):0] count
    );

    wire [(inWidth - 1):0] reverseIn;
    reverse#(inWidth) reverse_in(in, reverseIn);
    wire [inWidth:0] oneLeastReverseIn =
        {1'b1, reverseIn} & ({1'b0, ~reverseIn} + 1);
    genvar ix;
    generate
        for (ix = 0; ix <= inWidth; ix = ix + 1) begin :Bit
            wire [(countWidth - 1):0] countSoFar;
            if (ix == 0) begin
                assign countSoFar = 0;
            end else begin
                assign countSoFar =
                    Bit[ix - 1].countSoFar | (oneLeastReverseIn[ix] ? ix : 0);
                if (ix == inWidth) assign count = countSoFar;
            end
        end
    endgenerate

endmodule

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    compressBy2#(parameter inWidth = 1) (
        input [(inWidth - 1):0] in, output [((inWidth - 1)/2):0] out
    );

    localparam maxBitNumReduced = (inWidth - 1)/2;
    genvar ix;
    generate
        for (ix = 0; ix < maxBitNumReduced; ix = ix + 1) begin :Bit
            assign out[ix] = |in[(ix*2 + 1):ix*2];
        end
    endgenerate
    assign out[maxBitNumReduced] = |in[(inWidth - 1):maxBitNumReduced*2];

endmodule

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    compressBy4#(parameter inWidth = 1) (
        input [(inWidth - 1):0] in, output [(inWidth - 1)/4:0] out
    );

    localparam maxBitNumReduced = (inWidth - 1)/4;
    genvar ix;
    generate
        for (ix = 0; ix < maxBitNumReduced; ix = ix + 1) begin :Bit
            assign out[ix] = |in[(ix*4 + 3):ix*4];
        end
    endgenerate
    assign out[maxBitNumReduced] = |in[(inWidth - 1):maxBitNumReduced*4];

endmodule

`endif /* __HARDFLOAT_PRIMITIVES_VI__ */

`line 6 "/cgra/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/includeFile.v" 0
`line 1 "/cgra/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/RISCV/HardFloat_specialize.vi" 0
`ifndef __RISCV_HARDFLOAT_SPECIALIZE_VI__
`define __RISCV_HARDFLOAT_SPECIALIZE_VI__

/*============================================================================

This Verilog include file is part of the Berkeley HardFloat IEEE Floating-
Point Arithmetic Package, Release 1, by John R. Hauser.

Copyright 2019 The Regents of the University of California.  All rights
reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
    this list of conditions, and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions, and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

 3. Neither the name of the University nor the names of its contributors may
    be used to endorse or promote products derived from this software without
    specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=============================================================================*/

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/
`define flControl_default `flControl_tininessAfterRounding

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/
//`define HardFloat_propagateNaNPayloads

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/
`define HardFloat_signDefaultNaN 0
`define HardFloat_fractDefaultNaN(sigWidth) {1'b1, {((sigWidth) - 2){1'b0}}}

`endif /* __RISCV_HARDFLOAT_SPECIALIZE_VI__ */

`line 7 "/cgra/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/includeFile.v" 0
/* ============================================================== */

`line 42 "/cgra/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/recFNToFN.v" 0
// verilator lint_on MODDUP
/* ============================================================== */

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    recFNToFN#(parameter expWidth = 3, parameter sigWidth = 3) (
        input [(expWidth + sigWidth):0] in_,
        output [(expWidth + sigWidth - 1):0] out
    );
`line 1 "/cgra/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/HardFloat_localFuncs.vi" 0

/*============================================================================

This Verilog include file is part of the Berkeley HardFloat IEEE Floating-
Point Arithmetic Package, Release 1, by John R. Hauser.

Copyright 2019 The Regents of the University of California.  All rights
reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
    this list of conditions, and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions, and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

 3. Neither the name of the University nor the names of its contributors may
    be used to endorse or promote products derived from this software without
    specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=============================================================================*/

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

function integer clog2;
    input integer a;

    begin
        a = a - 1;
        for (clog2 = 0; a > 0; clog2 = clog2 + 1) a = a>>1;
    end

endfunction


`line 54 "/cgra/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/recFNToFN.v" 0

    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    localparam [expWidth:0] minNormExp = (1<<(expWidth - 1)) + 2;
    localparam normDistWidth = clog2(sigWidth);
    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    wire isNaN, isInf, isZero, sign;
    wire signed [(expWidth + 1):0] sExp;
    wire [sigWidth:0] sig;
    recFNToRawFN#(expWidth, sigWidth)
        recFNToRawFN(in_, isNaN, isInf, isZero, sign, sExp, sig);
    wire isSubnormal = (sExp < minNormExp);
    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    wire [(normDistWidth - 1):0] denormShiftDist = minNormExp - 1 - sExp;
    wire [(expWidth - 1):0] expOut =
        (isSubnormal ? 0 : sExp - minNormExp + 1)
            | (isNaN || isInf ? {expWidth{1'b1}} : 0);
    wire [(sigWidth - 2):0] fractOut =
        isSubnormal ? (sig>>1)>>denormShiftDist : isInf ? 0 : sig;
    assign out = {sign, expOut, fractOut};

endmodule

`endif /* __HARDFLOAT_RECFNTOFN_V__ */

`endif /* RECFNTOFN */

//-----------------------------------------------------------
// Wrapper of placeholder RecFNToFN__expWidth_9__sigWidth_23
//-----------------------------------------------------------

`ifndef RECFNTOFN__EXPWIDTH_9__SIGWIDTH_23
`define RECFNTOFN__EXPWIDTH_9__SIGWIDTH_23

module RecFNToFN__expWidth_9__sigWidth_23
(
  input logic reset,
  input logic clk,
  input logic [33-1:0] in_ ,
  output logic [32-1:0] out 
);
  recFNToFN
  #(
    .expWidth( 9 ),
    .sigWidth( 23 )
  ) v
  (
    .in_( in_ ),
    .out( out )
  );
endmodule

`endif /* RECFNTOFN__EXPWIDTH_9__SIGWIDTH_23 */



// PyMTL VerilogPlaceholder FNToRecFN Definition
// At /cgra/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/FNToRecFNRTL.py

//***********************************************************
// Pickled source file of placeholder FNToRecFN__expWidth_9__sigWidth_23
//***********************************************************

//-----------------------------------------------------------
// Dependency of placeholder FNToRecFN
//-----------------------------------------------------------

`ifndef FNTORECFN
`define FNTORECFN

// The source code below are included because they are specified
// as the v_libs Verilog placeholder option of component FNToRecFN__expWidth_9__sigWidth_23.

// If you get a duplicated def error from files included below, please
// make sure they are included either through the v_libs option or the
// explicit `include statement in the Verilog source code -- if they
// appear in both then they will be included twice!

`line 1 "/cgra/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/HardFloat_primitives.v" 0
`ifndef __HARDFLOAT_PRIMITIVES_VI__
`define __HARDFLOAT_PRIMITIVES_VI__

/*============================================================================

This Verilog source file is part of the Berkeley HardFloat IEEE Floating-Point
Arithmetic Package, Release 1, by John R. Hauser.

Copyright 2019 The Regents of the University of California.  All rights
reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
    this list of conditions, and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions, and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

 3. Neither the name of the University nor the names of its contributors may
    be used to endorse or promote products derived from this software without
    specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=============================================================================*/

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    reverse#(parameter width = 1) (
        input [(width - 1):0] in, output [(width - 1):0] out
    );

    genvar ix;
    generate
        for (ix = 0; ix < width; ix = ix + 1) begin :Bit
            assign out[ix] = in[width - 1 - ix];
        end
    endgenerate

endmodule

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    lowMaskHiLo#(
        parameter inWidth = 1,
        parameter topBound = 1,
        parameter bottomBound = 0
    ) (
        input [(inWidth - 1):0] in,
        output [(topBound - bottomBound - 1):0] out
    );

    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    localparam numInVals = 1<<inWidth;
    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    wire signed [numInVals:0] c;
    assign c[numInVals] = 1;
    assign c[(numInVals - 1):0] = 0;
    wire [(topBound - bottomBound - 1):0] reverseOut =
        (c>>>in)>>(numInVals - topBound);
    reverse#(topBound - bottomBound) reverse(reverseOut, out);

endmodule

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    lowMaskLoHi#(
        parameter inWidth = 1,
        parameter topBound = 0,
        parameter bottomBound = 1
    ) (
        input [(inWidth - 1):0] in,
        output [(bottomBound - topBound - 1):0] out
    );

    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    localparam numInVals = 1<<inWidth;
    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    wire signed [numInVals:0] c;
    assign c[numInVals] = 1;
    assign c[(numInVals - 1):0] = 0;
    wire [(bottomBound - topBound - 1):0] reverseOut =
        (c>>>~in)>>(topBound + 1);
    reverse#(bottomBound - topBound) reverse(reverseOut, out);

endmodule

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    countLeadingZeros#(parameter inWidth = 1, parameter countWidth = 1) (
        input [(inWidth - 1):0] in, output [(countWidth - 1):0] count
    );

    wire [(inWidth - 1):0] reverseIn;
    reverse#(inWidth) reverse_in(in, reverseIn);
    wire [inWidth:0] oneLeastReverseIn =
        {1'b1, reverseIn} & ({1'b0, ~reverseIn} + 1);
    genvar ix;
    generate
        for (ix = 0; ix <= inWidth; ix = ix + 1) begin :Bit
            wire [(countWidth - 1):0] countSoFar;
            if (ix == 0) begin
                assign countSoFar = 0;
            end else begin
                assign countSoFar =
                    Bit[ix - 1].countSoFar | (oneLeastReverseIn[ix] ? ix : 0);
                if (ix == inWidth) assign count = countSoFar;
            end
        end
    endgenerate

endmodule

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    compressBy2#(parameter inWidth = 1) (
        input [(inWidth - 1):0] in, output [((inWidth - 1)/2):0] out
    );

    localparam maxBitNumReduced = (inWidth - 1)/2;
    genvar ix;
    generate
        for (ix = 0; ix < maxBitNumReduced; ix = ix + 1) begin :Bit
            assign out[ix] = |in[(ix*2 + 1):ix*2];
        end
    endgenerate
    assign out[maxBitNumReduced] = |in[(inWidth - 1):maxBitNumReduced*2];

endmodule

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    compressBy4#(parameter inWidth = 1) (
        input [(inWidth - 1):0] in, output [(inWidth - 1)/4:0] out
    );

    localparam maxBitNumReduced = (inWidth - 1)/4;
    genvar ix;
    generate
        for (ix = 0; ix < maxBitNumReduced; ix = ix + 1) begin :Bit
            assign out[ix] = |in[(ix*4 + 3):ix*4];
        end
    endgenerate
    assign out[maxBitNumReduced] = |in[(inWidth - 1):maxBitNumReduced*4];

endmodule

`endif /* __HARDFLOAT_PRIMITIVES_VI__ */
`line 1 "/cgra/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/isSigNaNRecFN.v" 0
`ifndef __HARDFLOAT_ISSIGNANRECFN_V__
`define __HARDFLOAT_ISSIGNANRECFN_V__

/*============================================================================

This Verilog source file is part of the Berkeley HardFloat IEEE Floating-Point
Arithmetic Package, Release 1, by John R. Hauser.

Copyright 2019 The Regents of the University of California.  All rights
reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
    this list of conditions, and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions, and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

 3. Neither the name of the University nor the names of its contributors may
    be used to endorse or promote products derived from this software without
    specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=============================================================================*/

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    isSigNaNRecFN#(parameter expWidth = 3, parameter sigWidth = 3) (
        input [(expWidth + sigWidth):0] in, output isSigNaN
    );

    wire isNaN =
        (in[(expWidth + sigWidth - 1):(expWidth + sigWidth - 3)] == 'b111);
    assign isSigNaN = isNaN && !in[sigWidth - 2];

endmodule

`endif /* __HARDFLOAT_ISSIGNANRECFN_V__ */
`line 1 "/cgra/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/HardFloat_rawFN.v" 0
`ifndef __HARDFLOAT_RAWFN_VI__
`define __HARDFLOAT_RAWFN_VI__

/*============================================================================

This Verilog source file is part of the Berkeley HardFloat IEEE Floating-Point
Arithmetic Package, Release 1, by John R. Hauser.

Copyright 2019 The Regents of the University of California.  All rights
reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
    this list of conditions, and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions, and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

 3. Neither the name of the University nor the names of its contributors may
    be used to endorse or promote products derived from this software without
    specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=============================================================================*/

`line 1 "/cgra/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/HardFloat_consts.vi" 0
`ifndef __HARDFLOAT_CONSTS_VI__
`define __HARDFLOAT_CONSTS_VI__

/*============================================================================

This Verilog include file is part of the Berkeley HardFloat IEEE Floating-
Point Arithmetic Package, Release 1, by John R. Hauser.

Copyright 2019 The Regents of the University of California.  All rights
reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
    this list of conditions, and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions, and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

 3. Neither the name of the University nor the names of its contributors may
    be used to endorse or promote products derived from this software without
    specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=============================================================================*/

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/
`define round_near_even   3'b000
`define round_minMag      3'b001
`define round_min         3'b010
`define round_max         3'b011
`define round_near_maxMag 3'b100
`define round_odd         3'b110

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/
`define floatControlWidth 1
`define flControl_tininessBeforeRounding 1'b0
`define flControl_tininessAfterRounding  1'b1

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/
`define flRoundOpt_sigMSBitAlwaysZero  1
`define flRoundOpt_subnormsAlwaysExact 2
`define flRoundOpt_neverUnderflows     4
`define flRoundOpt_neverOverflows      8

`endif /* __HARDFLOAT_CONSTS_VI__ */

`line 40 "/cgra/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/HardFloat_rawFN.v" 0
`line 1 "/cgra/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/HardFloat_specialize.vi" 0
`ifndef __HARDFLOAT_SPECIALIZE_VI__
`define __HARDFLOAT_SPECIALIZE_VI__

/*============================================================================

This Verilog source file is part of the Berkeley HardFloat IEEE Floating-Point
Arithmetic Package, Release 1, by John R. Hauser.

Copyright 2019 The Regents of the University of California.  All rights
reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
    this list of conditions, and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions, and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

 3. Neither the name of the University nor the names of its contributors may
    be used to endorse or promote products derived from this software without
    specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=============================================================================*/

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    iNFromException#(parameter width = 1) (
        input signedOut,
        input isNaN,
        input sign,
        output [(width - 1):0] out
    );

    wire maxInt = isNaN || !sign;
    assign out = {signedOut ^ maxInt, {(width - 1){maxInt}}};

endmodule

`endif /* __HARDFLOAT_SPECIALIZE_VI__ */

`line 41 "/cgra/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/HardFloat_rawFN.v" 0

/* ===================== Adding some extra include files ================ */
`line 1 "/cgra/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/RISCV/HardFloat_specialize.vi" 0
`ifndef __RISCV_HARDFLOAT_SPECIALIZE_VI__
`define __RISCV_HARDFLOAT_SPECIALIZE_VI__

/*============================================================================

This Verilog include file is part of the Berkeley HardFloat IEEE Floating-
Point Arithmetic Package, Release 1, by John R. Hauser.

Copyright 2019 The Regents of the University of California.  All rights
reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
    this list of conditions, and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions, and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

 3. Neither the name of the University nor the names of its contributors may
    be used to endorse or promote products derived from this software without
    specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=============================================================================*/

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/
`define flControl_default `flControl_tininessAfterRounding

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/
//`define HardFloat_propagateNaNPayloads

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/
`define HardFloat_signDefaultNaN 0
`define HardFloat_fractDefaultNaN(sigWidth) {1'b1, {((sigWidth) - 2){1'b0}}}

`endif /* __RISCV_HARDFLOAT_SPECIALIZE_VI__ */

`line 44 "/cgra/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/HardFloat_rawFN.v" 0
/* ====================================================================== */

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    recFNToRawFN#(parameter expWidth = 3, parameter sigWidth = 3) (
        input [(expWidth + sigWidth):0] in,
        output isNaN,
        output isInf,
        output isZero,
        output sign,
        output signed [(expWidth + 1):0] sExp,
        output [sigWidth:0] sig
    );

    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    wire [expWidth:0] exp;
    wire [(sigWidth - 2):0] fract;
    assign {sign, exp, fract} = in;
    wire isSpecial = (exp>>(expWidth - 1) == 'b11);
    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    assign isNaN = isSpecial &&  exp[expWidth - 2];
    assign isInf = isSpecial && !exp[expWidth - 2];
    assign isZero = (exp>>(expWidth - 2) == 'b000);
    assign sExp = exp;
    assign sig = {1'b0, !isZero, fract};

endmodule

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    roundAnyRawFNToRecFN#(
        parameter inExpWidth = 3,
        parameter inSigWidth = 3,
        parameter outExpWidth = 3,
        parameter outSigWidth = 3,
        parameter options = 0
    ) (
        input [(`floatControlWidth - 1):0] control,
        input invalidExc,     // overrides 'infiniteExc' and 'in_*' inputs
        input infiniteExc,    // overrides 'in_*' inputs except 'in_sign'
        input in_isNaN,
        input in_isInf,
        input in_isZero,
        input in_sign,
        input signed [(inExpWidth + 1):0] in_sExp,   // limited range allowed
        input [inSigWidth:0] in_sig,
        input [2:0] roundingMode,
        output [(outExpWidth + outSigWidth):0] out,
        output [4:0] exceptionFlags
    );

    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    localparam sigMSBitAlwaysZero =
        ((options & `flRoundOpt_sigMSBitAlwaysZero) != 0);
    localparam effectiveInSigWidth =
        sigMSBitAlwaysZero ? inSigWidth : inSigWidth + 1;
    localparam neverUnderflows =
        ((options
              & (`flRoundOpt_neverUnderflows
                     | `flRoundOpt_subnormsAlwaysExact))
             != 0)
            || (inExpWidth < outExpWidth);
    localparam neverOverflows =
        ((options & `flRoundOpt_neverOverflows) != 0)
            || (inExpWidth < outExpWidth);
    localparam adjustedExpWidth =
          (inExpWidth < outExpWidth) ? outExpWidth + 1
        : (inExpWidth == outExpWidth) ? inExpWidth + 2
        : inExpWidth + 3;
    localparam outNaNExp = 7<<(outExpWidth - 2);
    localparam outInfExp = 6<<(outExpWidth - 2);
    localparam outMaxFiniteExp = outInfExp - 1;
    localparam outMinNormExp = (1<<(outExpWidth - 1)) + 2;
    localparam outMinNonzeroExp = outMinNormExp - outSigWidth + 1;
    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    wire roundingMode_near_even   = (roundingMode == `round_near_even);
    wire roundingMode_minMag      = (roundingMode == `round_minMag);
    wire roundingMode_min         = (roundingMode == `round_min);
    wire roundingMode_max         = (roundingMode == `round_max);
    wire roundingMode_near_maxMag = (roundingMode == `round_near_maxMag);
    wire roundingMode_odd         = (roundingMode == `round_odd);
    wire roundMagUp =
        (roundingMode_min && in_sign) || (roundingMode_max && !in_sign);
    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    wire isNaNOut = invalidExc || (!infiniteExc && in_isNaN);
`ifdef HardFloat_propagateNaNPayloads
    wire propagateNaNPayload = isNaNOut;
`else
    wire propagateNaNPayload = 0;
`endif
    wire signed [(adjustedExpWidth - 1):0] sAdjustedExp =
        in_sExp + ((1<<outExpWidth) - (1<<inExpWidth));
    wire [(outSigWidth + 2):0] adjustedSig;
    generate
        if (inSigWidth <= outSigWidth + 2) begin
            assign adjustedSig = in_sig<<(outSigWidth - inSigWidth + 2);
        end else begin
            assign adjustedSig =
                {in_sig[inSigWidth:(inSigWidth - outSigWidth - 1)],
                 |in_sig[(inSigWidth - outSigWidth - 2):0]};
        end
    endgenerate
    wire doShiftSigDown1 =
        sigMSBitAlwaysZero ? 0 : adjustedSig[outSigWidth + 2];
    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    wire [outExpWidth:0] common_expOut;
    wire [(outSigWidth - 2):0] common_fractOut;
    wire common_overflow, common_totalUnderflow, common_underflow;
    wire common_inexact;
    generate
        if (
            neverOverflows && neverUnderflows
                && (effectiveInSigWidth <= outSigWidth)
        ) begin
            /*----------------------------------------------------------------
            *----------------------------------------------------------------*/
            assign common_expOut = sAdjustedExp + doShiftSigDown1;
            assign common_fractOut =
                doShiftSigDown1 ? adjustedSig>>3 : adjustedSig>>2;
            assign common_overflow       = 0;
            assign common_totalUnderflow = 0;
            assign common_underflow      = 0;
            assign common_inexact        = 0;
        end else begin
            /*----------------------------------------------------------------
            *----------------------------------------------------------------*/
            wire [(outSigWidth + 2):0] roundMask;
            if (neverUnderflows) begin
                assign roundMask = {doShiftSigDown1, 2'b11};
            end else begin
                wire [outSigWidth:0] roundMask_main;
                lowMaskLoHi#(
                    outExpWidth + 1,
                    outMinNormExp - outSigWidth - 1,
                    outMinNormExp
                ) lowMask_roundMask(
                        sAdjustedExp[outExpWidth:0]
                            | (propagateNaNPayload ? 1'b1<<outExpWidth : 1'b0),
                        roundMask_main
                    );
                assign roundMask = {roundMask_main | doShiftSigDown1, 2'b11};
            end
            wire [(outSigWidth + 2):0] shiftedRoundMask = roundMask>>1;
            wire [(outSigWidth + 2):0] roundPosMask =
                ~shiftedRoundMask & roundMask;
            wire roundPosBit =
                (|(adjustedSig[(outSigWidth + 2):3]
                       & roundPosMask[(outSigWidth + 2):3]))
                    || ((|(adjustedSig[2:0] & roundPosMask[2:0]))
                            && !propagateNaNPayload);
            wire anyRoundExtra =
                (|(adjustedSig[(outSigWidth + 2):3]
                       & shiftedRoundMask[(outSigWidth + 2):3]))
                    || ((|(adjustedSig[2:0] & shiftedRoundMask[2:0]))
                            && !propagateNaNPayload);
            wire anyRound = roundPosBit || anyRoundExtra;
            /*----------------------------------------------------------------
            *----------------------------------------------------------------*/
            wire roundIncr =
                ((roundingMode_near_even || roundingMode_near_maxMag)
                     && roundPosBit)
                    || (roundMagUp && anyRound);
            wire [(outSigWidth + 1):0] roundedSig =
                roundIncr
                    ? (((adjustedSig | roundMask)>>2) + 1)
                          & ~(roundingMode_near_even && roundPosBit
                                  && !anyRoundExtra
                                  ? roundMask>>1 : 0)
                    : (adjustedSig & ~roundMask)>>2
                          | (roundingMode_odd && anyRound
                                 ? roundPosMask>>1 : 0);
            wire signed [adjustedExpWidth:0] sExtAdjustedExp = sAdjustedExp;
            wire signed [adjustedExpWidth:0] sRoundedExp =
                sExtAdjustedExp + (roundedSig>>outSigWidth);
            /*----------------------------------------------------------------
            *----------------------------------------------------------------*/
            assign common_expOut = sRoundedExp;
            assign common_fractOut =
                doShiftSigDown1 ? roundedSig>>1 : roundedSig;
            assign common_overflow =
                neverOverflows ? 0 : (sRoundedExp>>>(outExpWidth - 1) >= 3);
            assign common_totalUnderflow =
                neverUnderflows ? 0 : (sRoundedExp < outMinNonzeroExp);
            /*----------------------------------------------------------------
            *----------------------------------------------------------------*/
            wire unboundedRange_roundPosBit =
                doShiftSigDown1 ? adjustedSig[2] : adjustedSig[1];
            wire unboundedRange_anyRound =
                (doShiftSigDown1 && adjustedSig[2]) || (|adjustedSig[1:0]);
            wire unboundedRange_roundIncr =
                ((roundingMode_near_even || roundingMode_near_maxMag)
                     && unboundedRange_roundPosBit)
                    || (roundMagUp && unboundedRange_anyRound);
            wire roundCarry =
                doShiftSigDown1
                    ? roundedSig[outSigWidth + 1] : roundedSig[outSigWidth];
            assign common_underflow =
                neverUnderflows ? 0
                    : common_totalUnderflow
                          || (anyRound && (sAdjustedExp>>>outExpWidth <= 0)
                                  && (doShiftSigDown1
                                          ? roundMask[3] : roundMask[2])
                                  && !(((control
                                           & `flControl_tininessAfterRounding)
                                            != 0)
                                           && !(doShiftSigDown1 ? roundMask[4]
                                                    : roundMask[3])
                                           && roundCarry && roundPosBit
                                           && unboundedRange_roundIncr));
            /*----------------------------------------------------------------
            *----------------------------------------------------------------*/
            assign common_inexact = common_totalUnderflow || anyRound;
        end
    endgenerate
    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    wire notNaN_isSpecialInfOut = infiniteExc || in_isInf;
    wire commonCase = !isNaNOut && !notNaN_isSpecialInfOut && !in_isZero;
    wire overflow  = commonCase && common_overflow;
    wire underflow = commonCase && common_underflow;
    wire inexact = overflow || (commonCase && common_inexact);
    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    wire overflow_roundMagUp =
        roundingMode_near_even || roundingMode_near_maxMag || roundMagUp;
    wire pegMinNonzeroMagOut =
        commonCase && common_totalUnderflow
            && (roundMagUp || roundingMode_odd);
    wire pegMaxFiniteMagOut = overflow && !overflow_roundMagUp;
    wire notNaN_isInfOut =
        notNaN_isSpecialInfOut || (overflow && overflow_roundMagUp);
    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
`ifdef HardFloat_propagateNaNPayloads
    wire signOut = in_sign;
`else
    wire signOut = isNaNOut ? `HardFloat_signDefaultNaN : in_sign;
`endif
    wire [outExpWidth:0] expOut =
        (common_expOut
             & ~(in_isZero || common_totalUnderflow ? 7<<(outExpWidth - 2) : 0)
             & ~(pegMinNonzeroMagOut               ? ~outMinNonzeroExp    : 0)
             & ~(pegMaxFiniteMagOut                ? 1<<(outExpWidth - 1) : 0)
             & ~(notNaN_isInfOut                   ? 1<<(outExpWidth - 2) : 0))
            | (pegMinNonzeroMagOut ? outMinNonzeroExp : 0)
            | (pegMaxFiniteMagOut  ? outMaxFiniteExp  : 0)
            | (notNaN_isInfOut     ? outInfExp        : 0)
            | (isNaNOut            ? outNaNExp        : 0);
`ifdef HardFloat_propagateNaNPayloads
    wire [(outSigWidth - 2):0] fractOut =
        {isNaNOut
             || (!in_isZero && !common_totalUnderflow
                     && common_fractOut[outSigWidth - 2]),
         isNaNOut || (!in_isZero && !common_totalUnderflow)
             ? common_fractOut[(outSigWidth - 3):0] : 1'b0}
            | {(outSigWidth - 1){pegMaxFiniteMagOut}};
`else
    wire [(outSigWidth - 2):0] fractOut =
          (isNaNOut ? `HardFloat_fractDefaultNaN(outSigWidth) : 0)
        | (!in_isZero && !common_totalUnderflow
               ? common_fractOut & `HardFloat_fractDefaultNaN(outSigWidth) : 0)
        | (!isNaNOut && !in_isZero && !common_totalUnderflow
               ? common_fractOut & ~`HardFloat_fractDefaultNaN(outSigWidth)
               : 0)
        | {(outSigWidth - 1){pegMaxFiniteMagOut}};
`endif
    assign out = {signOut, expOut, fractOut};
    assign exceptionFlags =
        {invalidExc, infiniteExc, overflow, underflow, inexact};

endmodule

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    roundRawFNToRecFN#(
        parameter expWidth = 3,
        parameter sigWidth = 3,
        parameter options = 0
    ) (
        input [(`floatControlWidth - 1):0] control,
        input invalidExc,     // overrides 'infiniteExc' and 'in_*' inputs
        input infiniteExc,    // overrides 'in_*' inputs except 'in_sign'
        input in_isNaN,
        input in_isInf,
        input in_isZero,
        input in_sign,
        input signed [(expWidth + 1):0] in_sExp,   // limited range allowed
        input [(sigWidth + 2):0] in_sig,
        input [2:0] roundingMode,
        output [(expWidth + sigWidth):0] out,
        output [4:0] exceptionFlags
    );

    roundAnyRawFNToRecFN#(expWidth, sigWidth + 2, expWidth, sigWidth, options)
        roundAnyRawFNToRecFN(
            control,
            invalidExc,
            infiniteExc,
            in_isNaN,
            in_isInf,
            in_isZero,
            in_sign,
            in_sExp,
            in_sig,
            roundingMode,
            out,
            exceptionFlags
        );

endmodule

`endif /* __HARDFLOAT_RAWFN_VI__ */

// End of all v_libs files for component FNToRecFN__expWidth_9__sigWidth_23

`line 1 "/cgra/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/fNToRecFN.v" 0
`ifndef __HARDFLOAT_DIVSQRTRECFN_V__
`define __HARDFLOAT_DIVSQRTRECFN_V__

/*============================================================================

This Verilog source file is part of the Berkeley HardFloat IEEE Floating-Point
Arithmetic Package, Release 1, by John R. Hauser.

Copyright 2019 The Regents of the University of California.  All rights
reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
    this list of conditions, and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions, and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

 3. Neither the name of the University nor the names of its contributors may
    be used to endorse or promote products derived from this software without
    specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=============================================================================*/

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    fNToRecFN#(parameter expWidth = 3, parameter sigWidth = 3) (
        input [(expWidth + sigWidth - 1):0] in_,
        output [(expWidth + sigWidth):0] out
    );
`line 1 "/cgra/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/HardFloat_localFuncs.vi" 0

/*============================================================================

This Verilog include file is part of the Berkeley HardFloat IEEE Floating-
Point Arithmetic Package, Release 1, by John R. Hauser.

Copyright 2019 The Regents of the University of California.  All rights
reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
    this list of conditions, and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions, and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

 3. Neither the name of the University nor the names of its contributors may
    be used to endorse or promote products derived from this software without
    specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=============================================================================*/

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

function integer clog2;
    input integer a;

    begin
        a = a - 1;
        for (clog2 = 0; a > 0; clog2 = clog2 + 1) a = a>>1;
    end

endfunction


`line 48 "/cgra/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/fNToRecFN.v" 0

    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    localparam normDistWidth = clog2(sigWidth);
    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    wire sign;
    wire [(expWidth - 1):0] expIn;
    wire [(sigWidth - 2):0] fractIn;
    assign {sign, expIn, fractIn} = in_;
    wire isZeroExpIn = (expIn == 0);
    wire isZeroFractIn = (fractIn == 0);
    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    wire [(normDistWidth - 1):0] normDist;
    countLeadingZeros#(sigWidth - 1, normDistWidth)
        countLeadingZeros(fractIn, normDist);
    wire [(sigWidth - 2):0] subnormFract = (fractIn<<normDist)<<1;
    wire [expWidth:0] adjustedExp =
        (isZeroExpIn ? normDist ^ ((1<<(expWidth + 1)) - 1) : expIn)
            + ((1<<(expWidth - 1)) | (isZeroExpIn ? 2 : 1));
    wire isZero = isZeroExpIn && isZeroFractIn;
    wire isSpecial = (adjustedExp[expWidth:(expWidth - 1)] == 'b11);
    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    wire [expWidth:0] exp;
    assign exp[expWidth:(expWidth - 2)] =
        isSpecial ? {2'b11, !isZeroFractIn}
            : isZero ? 3'b000 : adjustedExp[expWidth:(expWidth - 2)];
    assign exp[(expWidth - 3):0] = adjustedExp;
    assign out = {sign, exp, isZeroExpIn ? subnormFract : fractIn};

endmodule

`endif /* __HARDFLOAT_DIVSQRTRECFN_V__ */

`endif /* FNTORECFN */

//-----------------------------------------------------------
// Wrapper of placeholder FNToRecFN__expWidth_9__sigWidth_23
//-----------------------------------------------------------

`ifndef FNTORECFN__EXPWIDTH_9__SIGWIDTH_23
`define FNTORECFN__EXPWIDTH_9__SIGWIDTH_23

module FNToRecFN__expWidth_9__sigWidth_23
(
  input logic reset,
  input logic clk,
  input logic [32-1:0] in_ ,
  output logic [33-1:0] out 
);
  fNToRecFN
  #(
    .expWidth( 9 ),
    .sigWidth( 23 )
  ) v
  (
    .in_( in_ ),
    .out( out )
  );
endmodule

`endif /* FNTORECFN__EXPWIDTH_9__SIGWIDTH_23 */



// PyMTL Component AddFN Definition
// At /cgra/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/AddFNRTL.py

module AddFN__expWidth_9__sigWidth_23
(
  input  logic [31:0] a ,
  input  logic [31:0] b ,
  input  logic [0:0] clk ,
  output logic [31:0] out ,
  input  logic [0:0] reset ,
  input  logic [2:0] roundingMode ,
  input  logic [0:0] subOp 
);
  logic [32:0] conv_a;
  logic [32:0] conv_b;
  logic [4:0] exception_flags;
  //-------------------------------------------------------------
  // Component adder
  //-------------------------------------------------------------

  logic [32:0] adder_a;
  logic [32:0] adder_b;
  logic [0:0] adder_clk;
  logic [0:0] adder_control;
  logic [4:0] adder_exceptionFlags;
  logic [32:0] adder_out;
  logic [0:0] adder_reset;
  logic [2:0] adder_roundingMode;
  logic [0:0] adder_subOp;

  AddRecFN__expWidth_9__sigWidth_23 adder
  (
    .a( adder_a ),
    .b( adder_b ),
    .clk( adder_clk ),
    .control( adder_control ),
    .exceptionFlags( adder_exceptionFlags ),
    .out( adder_out ),
    .reset( adder_reset ),
    .roundingMode( adder_roundingMode ),
    .subOp( adder_subOp )
  );

  //-------------------------------------------------------------
  // End of component adder
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component rec_to_std_conv
  //-------------------------------------------------------------

  logic [0:0] rec_to_std_conv_clk;
  logic [32:0] rec_to_std_conv_in_;
  logic [31:0] rec_to_std_conv_out;
  logic [0:0] rec_to_std_conv_reset;

  RecFNToFN__expWidth_9__sigWidth_23 rec_to_std_conv
  (
    .clk( rec_to_std_conv_clk ),
    .in_( rec_to_std_conv_in_ ),
    .out( rec_to_std_conv_out ),
    .reset( rec_to_std_conv_reset )
  );

  //-------------------------------------------------------------
  // End of component rec_to_std_conv
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component std_to_rec_conv_a
  //-------------------------------------------------------------

  logic [0:0] std_to_rec_conv_a_clk;
  logic [31:0] std_to_rec_conv_a_in_;
  logic [32:0] std_to_rec_conv_a_out;
  logic [0:0] std_to_rec_conv_a_reset;

  FNToRecFN__expWidth_9__sigWidth_23 std_to_rec_conv_a
  (
    .clk( std_to_rec_conv_a_clk ),
    .in_( std_to_rec_conv_a_in_ ),
    .out( std_to_rec_conv_a_out ),
    .reset( std_to_rec_conv_a_reset )
  );

  //-------------------------------------------------------------
  // End of component std_to_rec_conv_a
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component std_to_rec_conv_b
  //-------------------------------------------------------------

  logic [0:0] std_to_rec_conv_b_clk;
  logic [31:0] std_to_rec_conv_b_in_;
  logic [32:0] std_to_rec_conv_b_out;
  logic [0:0] std_to_rec_conv_b_reset;

  FNToRecFN__expWidth_9__sigWidth_23 std_to_rec_conv_b
  (
    .clk( std_to_rec_conv_b_clk ),
    .in_( std_to_rec_conv_b_in_ ),
    .out( std_to_rec_conv_b_out ),
    .reset( std_to_rec_conv_b_reset )
  );

  //-------------------------------------------------------------
  // End of component std_to_rec_conv_b
  //-------------------------------------------------------------

  assign std_to_rec_conv_a_clk = clk;
  assign std_to_rec_conv_a_reset = reset;
  assign std_to_rec_conv_b_clk = clk;
  assign std_to_rec_conv_b_reset = reset;
  assign rec_to_std_conv_clk = clk;
  assign rec_to_std_conv_reset = reset;
  assign adder_clk = clk;
  assign adder_reset = reset;
  assign std_to_rec_conv_a_in_ = a;
  assign conv_a = std_to_rec_conv_a_out;
  assign std_to_rec_conv_b_in_ = b;
  assign conv_b = std_to_rec_conv_b_out;
  assign adder_control = 1'd1;
  assign adder_a = conv_a;
  assign adder_b = conv_b;
  assign adder_roundingMode = roundingMode;
  assign adder_subOp = subOp;
  assign exception_flags = adder_exceptionFlags;
  assign rec_to_std_conv_in_ = adder_out;
  assign out = rec_to_std_conv_out;

endmodule


// PyMTL Component FpAddRTL Definition
// Full name: FpAddRTL__CtrlPktType_IntraCgraPacket_4_4x1_4_8_2_CgraPayload__11cd3f8c0d91825c__num_inports_4__num_outports_2__exp_nbits_8__sig_nbits_23
// At /cgra/VectorCGRA/fu/float/FpAddRTL.py

module FpAddRTL__989701b477aa86f0
(
  input  logic [0:0] clear ,
  input  logic [0:0] clk ,
  input  logic [2:0] ctrl_addr_inport ,
  input  logic [0:0] reset ,
  input CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 from_mem_rdata__msg  ,
  output logic [0:0] from_mem_rdata__rdy  ,
  input logic [0:0] from_mem_rdata__val  ,
  input CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 recv_const__msg  ,
  output logic [0:0] recv_const__rdy  ,
  input logic [0:0] recv_const__val  ,
  input MultiCgraPayload_Cmd_Data_DataAddr_Ctrl_CtrlAddr__a0427cd98cfcae6f recv_from_ctrl_mem__msg  ,
  output logic [0:0] recv_from_ctrl_mem__rdy  ,
  input logic [0:0] recv_from_ctrl_mem__val  ,
  input CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 recv_in__msg [0:3] ,
  output logic [0:0] recv_in__rdy [0:3] ,
  input logic [0:0] recv_in__val [0:3] ,
  input CGRAConfig_7_4_2_8_8_3__603a41f5d0e2436f recv_opt__msg  ,
  output logic [0:0] recv_opt__rdy  ,
  input logic [0:0] recv_opt__val  ,
  output CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 send_out__msg [0:1] ,
  input logic [0:0] send_out__rdy [0:1] ,
  output logic [0:0] send_out__val [0:1] ,
  output MultiCgraPayload_Cmd_Data_DataAddr_Ctrl_CtrlAddr__a0427cd98cfcae6f send_to_ctrl_mem__msg  ,
  input logic [0:0] send_to_ctrl_mem__rdy  ,
  output logic [0:0] send_to_ctrl_mem__val  ,
  output logic [8:0] to_mem_raddr__msg  ,
  input logic [0:0] to_mem_raddr__rdy  ,
  output logic [0:0] to_mem_raddr__val  ,
  output logic [8:0] to_mem_waddr__msg  ,
  input logic [0:0] to_mem_waddr__rdy  ,
  output logic [0:0] to_mem_waddr__val  ,
  output CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 to_mem_wdata__msg  ,
  input logic [0:0] to_mem_wdata__rdy  ,
  output logic [0:0] to_mem_wdata__val  
);
  localparam CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 const_zero  = { 32'd0, 1'd0, 1'd0, 1'd0 };
  localparam logic [6:0] __const__OPT_START  = 7'd0;
  localparam logic [0:0] __const__latency_at_proceed_latency  = 1'd1;
  localparam logic [6:0] __const__OPT_FSUB  = 7'd38;
  localparam logic [2:0] __const__num_inports_at_comb_logic  = 3'd4;
  localparam logic [1:0] __const__num_outports_at_comb_logic  = 2'd2;
  localparam logic [6:0] __const__OPT_FADD  = 7'd37;
  localparam logic [6:0] __const__OPT_FADD_CONST  = 7'd39;
  localparam logic [6:0] __const__OPT_FINC  = 7'd40;
  logic [2:0] in0;
  logic [1:0] in0_idx;
  logic [2:0] in1;
  logic [1:0] in1_idx;
  logic [0:0] latency;
  logic [0:0] reached_vector_factor;
  logic [0:0] recv_all_val;
  logic [7:0] vector_factor_counter;
  logic [2:0] vector_factor_power;
  //-------------------------------------------------------------
  // Component fadd
  //-------------------------------------------------------------

  logic [31:0] fadd__a;
  logic [31:0] fadd__b;
  logic [0:0] fadd__clk;
  logic [31:0] fadd__out;
  logic [0:0] fadd__reset;
  logic [2:0] fadd__roundingMode;
  logic [0:0] fadd__subOp;

  AddFN__expWidth_9__sigWidth_23 fadd
  (
    .a( fadd__a ),
    .b( fadd__b ),
    .clk( fadd__clk ),
    .out( fadd__out ),
    .reset( fadd__reset ),
    .roundingMode( fadd__roundingMode ),
    .subOp( fadd__subOp )
  );

  //-------------------------------------------------------------
  // End of component fadd
  //-------------------------------------------------------------

  // PyMTL Lambda Block Source
  // At /cgra/VectorCGRA/fu/float/FpAddRTL.py:50
  // s.fadd.subOp //= lambda: s.recv_opt.msg.operation == OPT_FSUB
  
  always_comb begin : _lambda__s_dut_tile_0__element_fu_1__fadd_subOp
    fadd__subOp = recv_opt__msg.operation == 7'( __const__OPT_FSUB );
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/fu/float/FpAddRTL.py:65
  //   @update
  //   def comb_logic():
  // 
  //     s.recv_all_val @= 0
  //     # For pick input register
  //     s.in0 @= 0
  //     s.in1 @= 0
  //     for i in range(num_inports):
  //       s.recv_in[i].rdy @= b1(0)
  // 
  //     for i in range(num_outports):
  //       s.send_out[i].val @= 0
  //       s.send_out[i].msg @= s.DataType()
  // 
  //     s.recv_const.rdy @= 0
  //     s.recv_opt.rdy @= 0
  // 
  //     s.send_to_ctrl_mem.val @= 0
  //     s.send_to_ctrl_mem.msg @= s.CgraPayloadType(0, 0, 0, 0, 0)
  // 
  //     s.recv_from_ctrl_mem.rdy @= 0
  // 
  //     s.fadd.a @= 0
  //     s.fadd.b @= 0
  // 
  //     if s.recv_opt.val:
  //       if s.recv_opt.msg.fu_in[0] != 0:
  //         s.in0 @= zext(s.recv_opt.msg.fu_in[0] - 1, FuInType)
  //       if s.recv_opt.msg.fu_in[1] != 0:
  //         s.in1 @= zext(s.recv_opt.msg.fu_in[1] - 1, FuInType)
  // 
  //     if s.recv_opt.val:
  //       if s.recv_opt.msg.operation == OPT_FADD:
  //         s.fadd.a @= s.recv_in[s.in0_idx].msg.payload
  //         s.fadd.b @= s.recv_in[s.in1_idx].msg.payload
  //         s.send_out[0].msg.predicate @= s.recv_in[s.in0_idx].msg.predicate & \
  //                                        s.recv_in[s.in1_idx].msg.predicate
  //         s.recv_all_val @= s.recv_in[s.in0_idx].val & s.recv_in[s.in1_idx].val
  //         s.send_out[0].val @= s.recv_all_val
  //         s.recv_in[s.in0_idx].rdy @= s.recv_all_val & s.send_out[0].rdy
  //         s.recv_in[s.in1_idx].rdy @= s.recv_all_val & s.send_out[0].rdy
  //         s.recv_opt.rdy @= s.recv_all_val & s.send_out[0].rdy
  // 
  //       elif s.recv_opt.msg.operation == OPT_FADD_CONST:
  //         s.fadd.a @= s.recv_in[s.in0_idx].msg.payload
  //         s.fadd.b @= s.recv_const.msg.payload
  //         s.send_out[0].msg.predicate @= s.recv_in[s.in0_idx].msg.predicate
  //         s.recv_all_val @= s.recv_in[s.in0_idx].val & s.recv_const.val
  //         s.send_out[0].val @= s.recv_all_val
  //         s.recv_in[s.in0_idx].rdy @= s.recv_all_val & s.send_out[0].rdy
  //         s.recv_const.rdy @= s.recv_all_val & s.send_out[0].rdy
  //         s.recv_opt.rdy @= s.recv_all_val & s.send_out[0].rdy
  // 
  //       elif s.recv_opt.msg.operation == OPT_FINC:
  //         s.fadd.a @= s.recv_in[s.in0_idx].msg.payload
  //         s.fadd.b @= s.FLOATING_ONE
  //         s.send_out[0].msg.predicate @= s.recv_in[s.in0_idx].msg.predicate
  //         s.recv_all_val @= s.recv_in[s.in0_idx].val
  //         s.send_out[0].val @= s.recv_all_val & s.send_out[0].rdy
  //         s.recv_in[s.in0_idx].rdy @= s.recv_all_val & s.send_out[0].rdy
  //         s.recv_opt.rdy @= s.recv_all_val & s.send_out[0].rdy
  // 
  //       elif s.recv_opt.msg.operation == OPT_FSUB:
  //         s.fadd.a @= s.recv_in[s.in0_idx].msg.payload
  //         s.fadd.b @= s.recv_in[s.in1_idx].msg.payload
  //         s.send_out[0].msg.predicate @= s.recv_in[s.in0_idx].msg.predicate & \
  //                                        s.recv_in[s.in1_idx].msg.predicate
  //         s.recv_all_val @= s.recv_in[s.in0_idx].val & s.recv_in[s.in1_idx].val
  //         s.send_out[0].val @= s.recv_all_val
  //         s.recv_in[s.in0_idx].rdy @= s.recv_all_val & s.send_out[0].rdy
  //         s.recv_in[s.in1_idx].rdy @= s.recv_all_val & s.send_out[0].rdy
  //         s.recv_opt.rdy @= s.recv_all_val & s.send_out[0].rdy
  //       else:
  //         for j in range( num_outports ):
  //           s.send_out[j].val @= b1(0)
  //         s.recv_opt.rdy @= 0
  //         s.recv_in[s.in0_idx].rdy @= 0
  //         s.recv_in[s.in1_idx].rdy @= 0
  // 
  //       s.send_out[0].msg.payload @= s.fadd.out
  
  always_comb begin : comb_logic
    recv_all_val = 1'd0;
    in0 = 3'd0;
    in1 = 3'd0;
    for ( int unsigned i = 1'd0; i < 3'( __const__num_inports_at_comb_logic ); i += 1'd1 )
      recv_in__rdy[2'(i)] = 1'd0;
    for ( int unsigned i = 1'd0; i < 2'( __const__num_outports_at_comb_logic ); i += 1'd1 ) begin
      send_out__val[1'(i)] = 1'd0;
      send_out__msg[1'(i)] = { 32'd0, 1'd0, 1'd0, 1'd0 };
    end
    recv_const__rdy = 1'd0;
    recv_opt__rdy = 1'd0;
    send_to_ctrl_mem__val = 1'd0;
    send_to_ctrl_mem__msg = { 5'd0, 35'd0, 9'd0, 139'd0, 3'd0 };
    recv_from_ctrl_mem__rdy = 1'd0;
    fadd__a = 32'd0;
    fadd__b = 32'd0;
    if ( recv_opt__val ) begin
      if ( recv_opt__msg.fu_in[2'd0] != 3'd0 ) begin
        in0 = recv_opt__msg.fu_in[2'd0] - 3'd1;
      end
      if ( recv_opt__msg.fu_in[2'd1] != 3'd0 ) begin
        in1 = recv_opt__msg.fu_in[2'd1] - 3'd1;
      end
    end
    if ( recv_opt__val ) begin
      if ( recv_opt__msg.operation == 7'( __const__OPT_FADD ) ) begin
        fadd__a = recv_in__msg[in0_idx].payload;
        fadd__b = recv_in__msg[in1_idx].payload;
        send_out__msg[1'd0].predicate = recv_in__msg[in0_idx].predicate & recv_in__msg[in1_idx].predicate;
        recv_all_val = recv_in__val[in0_idx] & recv_in__val[in1_idx];
        send_out__val[1'd0] = recv_all_val;
        recv_in__rdy[in0_idx] = recv_all_val & send_out__rdy[1'd0];
        recv_in__rdy[in1_idx] = recv_all_val & send_out__rdy[1'd0];
        recv_opt__rdy = recv_all_val & send_out__rdy[1'd0];
      end
      else if ( recv_opt__msg.operation == 7'( __const__OPT_FADD_CONST ) ) begin
        fadd__a = recv_in__msg[in0_idx].payload;
        fadd__b = recv_const__msg.payload;
        send_out__msg[1'd0].predicate = recv_in__msg[in0_idx].predicate;
        recv_all_val = recv_in__val[in0_idx] & recv_const__val;
        send_out__val[1'd0] = recv_all_val;
        recv_in__rdy[in0_idx] = recv_all_val & send_out__rdy[1'd0];
        recv_const__rdy = recv_all_val & send_out__rdy[1'd0];
        recv_opt__rdy = recv_all_val & send_out__rdy[1'd0];
      end
      else if ( recv_opt__msg.operation == 7'( __const__OPT_FINC ) ) begin
        fadd__a = recv_in__msg[in0_idx].payload;
        fadd__b = 32'd1065353216;
        send_out__msg[1'd0].predicate = recv_in__msg[in0_idx].predicate;
        recv_all_val = recv_in__val[in0_idx];
        send_out__val[1'd0] = recv_all_val & send_out__rdy[1'd0];
        recv_in__rdy[in0_idx] = recv_all_val & send_out__rdy[1'd0];
        recv_opt__rdy = recv_all_val & send_out__rdy[1'd0];
      end
      else if ( recv_opt__msg.operation == 7'( __const__OPT_FSUB ) ) begin
        fadd__a = recv_in__msg[in0_idx].payload;
        fadd__b = recv_in__msg[in1_idx].payload;
        send_out__msg[1'd0].predicate = recv_in__msg[in0_idx].predicate & recv_in__msg[in1_idx].predicate;
        recv_all_val = recv_in__val[in0_idx] & recv_in__val[in1_idx];
        send_out__val[1'd0] = recv_all_val;
        recv_in__rdy[in0_idx] = recv_all_val & send_out__rdy[1'd0];
        recv_in__rdy[in1_idx] = recv_all_val & send_out__rdy[1'd0];
        recv_opt__rdy = recv_all_val & send_out__rdy[1'd0];
      end
      else begin
        for ( int unsigned j = 1'd0; j < 2'( __const__num_outports_at_comb_logic ); j += 1'd1 )
          send_out__val[1'(j)] = 1'd0;
        recv_opt__rdy = 1'd0;
        recv_in__rdy[in0_idx] = 1'd0;
        recv_in__rdy[in1_idx] = 1'd0;
      end
      send_out__msg[1'd0].payload = fadd__out;
    end
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/fu/basic/Fu.py:68
  // @update
  // def update_mem():
  //   s.to_mem_waddr.val @= b1(0)
  //   s.to_mem_wdata.val @= b1(0)
  //   s.to_mem_wdata.msg @= s.const_zero
  //   s.to_mem_waddr.msg @= s.DataAddrType(0)
  //   s.to_mem_raddr.msg @= s.DataAddrType(0)
  //   s.to_mem_raddr.val @= b1(0)
  //   s.from_mem_rdata.rdy @= b1(0)
  
  always_comb begin : update_mem
    to_mem_waddr__val = 1'd0;
    to_mem_wdata__val = 1'd0;
    to_mem_wdata__msg = const_zero;
    to_mem_waddr__msg = 9'd0;
    to_mem_raddr__msg = 9'd0;
    to_mem_raddr__val = 1'd0;
    from_mem_rdata__rdy = 1'd0;
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/fu/basic/Fu.py:87
  // @update
  // def update_reached_vector_factor():
  //   s.reached_vector_factor @= 0
  //   if s.recv_opt.val & (s.vector_factor_counter + \
  //                        (VectorFactorType(1) << zext(s.vector_factor_power, VectorFactorType)) >= \
  //                        (VectorFactorType(1) << zext(s.recv_opt.msg.vector_factor_power, VectorFactorType))):
  //     s.reached_vector_factor @= 1
  
  always_comb begin : update_reached_vector_factor
    reached_vector_factor = 1'd0;
    if ( recv_opt__val & ( ( vector_factor_counter + ( 8'd1 << { { 5 { 1'b0 } }, vector_factor_power } ) ) >= ( 8'd1 << { { 5 { 1'b0 } }, recv_opt__msg.vector_factor_power } ) ) ) begin
      reached_vector_factor = 1'd1;
    end
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/fu/basic/Fu.py:78
  // @update_ff
  // def proceed_latency():
  //   if s.recv_opt.msg.operation == OPT_START:
  //     s.latency <<= LatencyType(0)
  //   elif s.latency == latency - 1:
  //     s.latency <<= LatencyType(0)
  //   else:
  //     s.latency <<= s.latency + LatencyType(1)
  
  always_ff @(posedge clk) begin : proceed_latency
    if ( recv_opt__msg.operation == 7'( __const__OPT_START ) ) begin
      latency <= 1'd0;
    end
    else if ( latency == ( 1'( __const__latency_at_proceed_latency ) - 1'd1 ) ) begin
      latency <= 1'd0;
    end
    else
      latency <= latency + 1'd1;
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/fu/basic/Fu.py:95
  // @update_ff
  // def update_vector_factor_counter():
  //   if s.reset:
  //     s.vector_factor_counter <<= 0
  //   else:
  //     if s.recv_opt.val:
  //       if s.recv_opt.msg.is_last_ctrl & \
  //          (s.vector_factor_counter + \
  //           (VectorFactorType(1) << zext(s.vector_factor_power, VectorFactorType)) < \
  //           (VectorFactorType(1) << zext(s.recv_opt.msg.vector_factor_power, VectorFactorType))):
  //         s.vector_factor_counter <<= s.vector_factor_counter + \
  //                                     (VectorFactorType(1) << zext(s.vector_factor_power, \
  //                                                                  VectorFactorType))
  //       elif s.recv_opt.msg.is_last_ctrl & s.reached_vector_factor:
  //         s.vector_factor_counter <<= 0
  
  always_ff @(posedge clk) begin : update_vector_factor_counter
    if ( reset ) begin
      vector_factor_counter <= 8'd0;
    end
    else if ( recv_opt__val ) begin
      if ( recv_opt__msg.is_last_ctrl & ( ( vector_factor_counter + ( 8'd1 << { { 5 { 1'b0 } }, vector_factor_power } ) ) < ( 8'd1 << { { 5 { 1'b0 } }, recv_opt__msg.vector_factor_power } ) ) ) begin
        vector_factor_counter <= vector_factor_counter + ( 8'd1 << { { 5 { 1'b0 } }, vector_factor_power } );
      end
      else if ( recv_opt__msg.is_last_ctrl & reached_vector_factor ) begin
        vector_factor_counter <= 8'd0;
      end
    end
  end

  assign vector_factor_power = 3'd0;
  assign fadd__clk = clk;
  assign fadd__reset = reset;
  assign fadd__roundingMode = 3'd0;
  assign in0_idx = in0[1:0];
  assign in1_idx = in1[1:0];

endmodule


// PyMTL Component MulRTL Definition
// Full name: MulRTL__CtrlPktType_IntraCgraPacket_4_4x1_4_8_2_CgraPayload__11cd3f8c0d91825c__num_inports_4__num_outports_2__vector_factor_power_0
// At /cgra/VectorCGRA/fu/single/MulRTL.py

module MulRTL__1a7eacb70e3ca1c4
(
  input  logic [0:0] clear ,
  input  logic [0:0] clk ,
  input  logic [2:0] ctrl_addr_inport ,
  input  logic [0:0] reset ,
  input CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 from_mem_rdata__msg  ,
  output logic [0:0] from_mem_rdata__rdy  ,
  input logic [0:0] from_mem_rdata__val  ,
  input CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 recv_const__msg  ,
  output logic [0:0] recv_const__rdy  ,
  input logic [0:0] recv_const__val  ,
  input MultiCgraPayload_Cmd_Data_DataAddr_Ctrl_CtrlAddr__a0427cd98cfcae6f recv_from_ctrl_mem__msg  ,
  output logic [0:0] recv_from_ctrl_mem__rdy  ,
  input logic [0:0] recv_from_ctrl_mem__val  ,
  input CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 recv_in__msg [0:3] ,
  output logic [0:0] recv_in__rdy [0:3] ,
  input logic [0:0] recv_in__val [0:3] ,
  input CGRAConfig_7_4_2_8_8_3__603a41f5d0e2436f recv_opt__msg  ,
  output logic [0:0] recv_opt__rdy  ,
  input logic [0:0] recv_opt__val  ,
  output CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 send_out__msg [0:1] ,
  input logic [0:0] send_out__rdy [0:1] ,
  output logic [0:0] send_out__val [0:1] ,
  output MultiCgraPayload_Cmd_Data_DataAddr_Ctrl_CtrlAddr__a0427cd98cfcae6f send_to_ctrl_mem__msg  ,
  input logic [0:0] send_to_ctrl_mem__rdy  ,
  output logic [0:0] send_to_ctrl_mem__val  ,
  output logic [8:0] to_mem_raddr__msg  ,
  input logic [0:0] to_mem_raddr__rdy  ,
  output logic [0:0] to_mem_raddr__val  ,
  output logic [8:0] to_mem_waddr__msg  ,
  input logic [0:0] to_mem_waddr__rdy  ,
  output logic [0:0] to_mem_waddr__val  ,
  output CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 to_mem_wdata__msg  ,
  input logic [0:0] to_mem_wdata__rdy  ,
  output logic [0:0] to_mem_wdata__val  
);
  localparam CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 const_zero  = { 32'd0, 1'd0, 1'd0, 1'd0 };
  localparam logic [6:0] __const__OPT_START  = 7'd0;
  localparam logic [0:0] __const__latency_at_proceed_latency  = 1'd1;
  localparam logic [2:0] __const__num_inports_at_comb_logic  = 3'd4;
  localparam logic [1:0] __const__num_outports_at_comb_logic  = 2'd2;
  localparam logic [6:0] __const__OPT_MUL  = 7'd7;
  localparam logic [6:0] __const__OPT_MUL_CONST  = 7'd29;
  logic [2:0] in0;
  logic [1:0] in0_idx;
  logic [2:0] in1;
  logic [1:0] in1_idx;
  logic [0:0] latency;
  logic [0:0] reached_vector_factor;
  logic [0:0] recv_all_val;
  logic [7:0] vector_factor_counter;
  logic [2:0] vector_factor_power;

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/fu/single/MulRTL.py:37
  // @update
  // def comb_logic():
  // 
  //   s.recv_all_val @= 0
  //   # For pick input register
  //   s.in0 @= 0
  //   s.in1 @= 0
  //   for i in range(num_inports):
  //     s.recv_in[i].rdy @= b1(0)
  //   for i in range(num_outports):
  //     s.send_out[i].val @= 0
  //     s.send_out[i].msg @= s.DataType()
  // 
  //   s.recv_const.rdy @= 0
  //   s.recv_opt.rdy @= 0
  // 
  //   s.send_to_ctrl_mem.val @= 0
  //   s.send_to_ctrl_mem.msg @= s.CgraPayloadType(0, 0, 0, 0, 0)
  //   s.recv_from_ctrl_mem.rdy @= 0
  // 
  //   if s.recv_opt.val:
  //     if s.recv_opt.msg.fu_in[0] != 0:
  //       s.in0 @= zext(s.recv_opt.msg.fu_in[0] - 1, FuInType)
  //     if s.recv_opt.msg.fu_in[1] != 0:
  //       s.in1 @= zext(s.recv_opt.msg.fu_in[1] - 1, FuInType)
  // 
  //   if s.recv_opt.val:
  //     if s.recv_opt.msg.operation == OPT_MUL:
  //       s.send_out[0].msg.payload @= s.recv_in[s.in0_idx].msg.payload * s.recv_in[s.in1_idx].msg.payload
  //       s.send_out[0].msg.predicate @= s.recv_in[s.in0_idx].msg.predicate & \
  //                                      s.recv_in[s.in1_idx].msg.predicate & \
  //                                      s.reached_vector_factor
  //       s.recv_all_val @= s.recv_in[s.in0_idx].val & s.recv_in[s.in1_idx].val
  //       s.send_out[0].val @= s.recv_all_val
  //       s.recv_in[s.in0_idx].rdy @= s.recv_all_val & s.send_out[0].rdy
  //       s.recv_in[s.in1_idx].rdy @= s.recv_all_val & s.send_out[0].rdy
  //       s.recv_opt.rdy @= s.recv_all_val & s.send_out[0].rdy
  // 
  //     elif s.recv_opt.msg.operation == OPT_MUL_CONST:
  //       s.send_out[0].msg.payload @= s.recv_in[s.in0_idx].msg.payload * s.recv_const.msg.payload
  //       s.send_out[0].msg.predicate @= s.recv_in[s.in0_idx].msg.predicate & \
  //                                      s.reached_vector_factor
  //       s.recv_all_val @= s.recv_in[s.in0_idx].val & s.recv_const.val
  //       s.send_out[0].val @= s.recv_all_val
  //       s.recv_in[s.in0_idx].rdy @= s.recv_all_val & s.send_out[0].rdy
  //       s.recv_const.rdy @= s.recv_all_val & s.send_out[0].rdy
  //       s.recv_opt.rdy @= s.recv_all_val & s.send_out[0].rdy
  // 
  //     else:
  //       for j in range(num_outports):
  //         s.send_out[j].val @= b1(0)
  //       s.recv_opt.rdy @= 0
  //       s.recv_in[s.in0_idx].rdy @= 0
  //       s.recv_in[s.in1_idx].rdy @= 0
  
  always_comb begin : comb_logic
    recv_all_val = 1'd0;
    in0 = 3'd0;
    in1 = 3'd0;
    for ( int unsigned i = 1'd0; i < 3'( __const__num_inports_at_comb_logic ); i += 1'd1 )
      recv_in__rdy[2'(i)] = 1'd0;
    for ( int unsigned i = 1'd0; i < 2'( __const__num_outports_at_comb_logic ); i += 1'd1 ) begin
      send_out__val[1'(i)] = 1'd0;
      send_out__msg[1'(i)] = { 32'd0, 1'd0, 1'd0, 1'd0 };
    end
    recv_const__rdy = 1'd0;
    recv_opt__rdy = 1'd0;
    send_to_ctrl_mem__val = 1'd0;
    send_to_ctrl_mem__msg = { 5'd0, 35'd0, 9'd0, 139'd0, 3'd0 };
    recv_from_ctrl_mem__rdy = 1'd0;
    if ( recv_opt__val ) begin
      if ( recv_opt__msg.fu_in[2'd0] != 3'd0 ) begin
        in0 = recv_opt__msg.fu_in[2'd0] - 3'd1;
      end
      if ( recv_opt__msg.fu_in[2'd1] != 3'd0 ) begin
        in1 = recv_opt__msg.fu_in[2'd1] - 3'd1;
      end
    end
    if ( recv_opt__val ) begin
      if ( recv_opt__msg.operation == 7'( __const__OPT_MUL ) ) begin
        send_out__msg[1'd0].payload = recv_in__msg[in0_idx].payload * recv_in__msg[in1_idx].payload;
        send_out__msg[1'd0].predicate = ( recv_in__msg[in0_idx].predicate & recv_in__msg[in1_idx].predicate ) & reached_vector_factor;
        recv_all_val = recv_in__val[in0_idx] & recv_in__val[in1_idx];
        send_out__val[1'd0] = recv_all_val;
        recv_in__rdy[in0_idx] = recv_all_val & send_out__rdy[1'd0];
        recv_in__rdy[in1_idx] = recv_all_val & send_out__rdy[1'd0];
        recv_opt__rdy = recv_all_val & send_out__rdy[1'd0];
      end
      else if ( recv_opt__msg.operation == 7'( __const__OPT_MUL_CONST ) ) begin
        send_out__msg[1'd0].payload = recv_in__msg[in0_idx].payload * recv_const__msg.payload;
        send_out__msg[1'd0].predicate = recv_in__msg[in0_idx].predicate & reached_vector_factor;
        recv_all_val = recv_in__val[in0_idx] & recv_const__val;
        send_out__val[1'd0] = recv_all_val;
        recv_in__rdy[in0_idx] = recv_all_val & send_out__rdy[1'd0];
        recv_const__rdy = recv_all_val & send_out__rdy[1'd0];
        recv_opt__rdy = recv_all_val & send_out__rdy[1'd0];
      end
      else begin
        for ( int unsigned j = 1'd0; j < 2'( __const__num_outports_at_comb_logic ); j += 1'd1 )
          send_out__val[1'(j)] = 1'd0;
        recv_opt__rdy = 1'd0;
        recv_in__rdy[in0_idx] = 1'd0;
        recv_in__rdy[in1_idx] = 1'd0;
      end
    end
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/fu/basic/Fu.py:68
  // @update
  // def update_mem():
  //   s.to_mem_waddr.val @= b1(0)
  //   s.to_mem_wdata.val @= b1(0)
  //   s.to_mem_wdata.msg @= s.const_zero
  //   s.to_mem_waddr.msg @= s.DataAddrType(0)
  //   s.to_mem_raddr.msg @= s.DataAddrType(0)
  //   s.to_mem_raddr.val @= b1(0)
  //   s.from_mem_rdata.rdy @= b1(0)
  
  always_comb begin : update_mem
    to_mem_waddr__val = 1'd0;
    to_mem_wdata__val = 1'd0;
    to_mem_wdata__msg = const_zero;
    to_mem_waddr__msg = 9'd0;
    to_mem_raddr__msg = 9'd0;
    to_mem_raddr__val = 1'd0;
    from_mem_rdata__rdy = 1'd0;
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/fu/basic/Fu.py:87
  // @update
  // def update_reached_vector_factor():
  //   s.reached_vector_factor @= 0
  //   if s.recv_opt.val & (s.vector_factor_counter + \
  //                        (VectorFactorType(1) << zext(s.vector_factor_power, VectorFactorType)) >= \
  //                        (VectorFactorType(1) << zext(s.recv_opt.msg.vector_factor_power, VectorFactorType))):
  //     s.reached_vector_factor @= 1
  
  always_comb begin : update_reached_vector_factor
    reached_vector_factor = 1'd0;
    if ( recv_opt__val & ( ( vector_factor_counter + ( 8'd1 << { { 5 { 1'b0 } }, vector_factor_power } ) ) >= ( 8'd1 << { { 5 { 1'b0 } }, recv_opt__msg.vector_factor_power } ) ) ) begin
      reached_vector_factor = 1'd1;
    end
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/fu/basic/Fu.py:78
  // @update_ff
  // def proceed_latency():
  //   if s.recv_opt.msg.operation == OPT_START:
  //     s.latency <<= LatencyType(0)
  //   elif s.latency == latency - 1:
  //     s.latency <<= LatencyType(0)
  //   else:
  //     s.latency <<= s.latency + LatencyType(1)
  
  always_ff @(posedge clk) begin : proceed_latency
    if ( recv_opt__msg.operation == 7'( __const__OPT_START ) ) begin
      latency <= 1'd0;
    end
    else if ( latency == ( 1'( __const__latency_at_proceed_latency ) - 1'd1 ) ) begin
      latency <= 1'd0;
    end
    else
      latency <= latency + 1'd1;
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/fu/basic/Fu.py:95
  // @update_ff
  // def update_vector_factor_counter():
  //   if s.reset:
  //     s.vector_factor_counter <<= 0
  //   else:
  //     if s.recv_opt.val:
  //       if s.recv_opt.msg.is_last_ctrl & \
  //          (s.vector_factor_counter + \
  //           (VectorFactorType(1) << zext(s.vector_factor_power, VectorFactorType)) < \
  //           (VectorFactorType(1) << zext(s.recv_opt.msg.vector_factor_power, VectorFactorType))):
  //         s.vector_factor_counter <<= s.vector_factor_counter + \
  //                                     (VectorFactorType(1) << zext(s.vector_factor_power, \
  //                                                                  VectorFactorType))
  //       elif s.recv_opt.msg.is_last_ctrl & s.reached_vector_factor:
  //         s.vector_factor_counter <<= 0
  
  always_ff @(posedge clk) begin : update_vector_factor_counter
    if ( reset ) begin
      vector_factor_counter <= 8'd0;
    end
    else if ( recv_opt__val ) begin
      if ( recv_opt__msg.is_last_ctrl & ( ( vector_factor_counter + ( 8'd1 << { { 5 { 1'b0 } }, vector_factor_power } ) ) < ( 8'd1 << { { 5 { 1'b0 } }, recv_opt__msg.vector_factor_power } ) ) ) begin
        vector_factor_counter <= vector_factor_counter + ( 8'd1 << { { 5 { 1'b0 } }, vector_factor_power } );
      end
      else if ( recv_opt__msg.is_last_ctrl & reached_vector_factor ) begin
        vector_factor_counter <= 8'd0;
      end
    end
  end

  assign vector_factor_power = 3'd0;
  assign in0_idx = in0[1:0];
  assign in1_idx = in1[1:0];

endmodule


// PyMTL Component LoopControlRTL Definition
// Full name: LoopControlRTL__CtrlPktType_IntraCgraPacket_4_4x1_4_8_2_CgraPayload__11cd3f8c0d91825c__num_inports_4__num_outports_2__vector_factor_power_0
// At /cgra/VectorCGRA/fu/single/LoopControlRTL.py

module LoopControlRTL__1a7eacb70e3ca1c4
(
  input  logic [0:0] clear ,
  input  logic [0:0] clk ,
  input  logic [2:0] ctrl_addr_inport ,
  input  logic [0:0] reset ,
  input CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 from_mem_rdata__msg  ,
  output logic [0:0] from_mem_rdata__rdy  ,
  input logic [0:0] from_mem_rdata__val  ,
  input CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 recv_const__msg  ,
  output logic [0:0] recv_const__rdy  ,
  input logic [0:0] recv_const__val  ,
  input MultiCgraPayload_Cmd_Data_DataAddr_Ctrl_CtrlAddr__a0427cd98cfcae6f recv_from_ctrl_mem__msg  ,
  output logic [0:0] recv_from_ctrl_mem__rdy  ,
  input logic [0:0] recv_from_ctrl_mem__val  ,
  input CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 recv_in__msg [0:3] ,
  output logic [0:0] recv_in__rdy [0:3] ,
  input logic [0:0] recv_in__val [0:3] ,
  input CGRAConfig_7_4_2_8_8_3__603a41f5d0e2436f recv_opt__msg  ,
  output logic [0:0] recv_opt__rdy  ,
  input logic [0:0] recv_opt__val  ,
  output CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 send_out__msg [0:1] ,
  input logic [0:0] send_out__rdy [0:1] ,
  output logic [0:0] send_out__val [0:1] ,
  output MultiCgraPayload_Cmd_Data_DataAddr_Ctrl_CtrlAddr__a0427cd98cfcae6f send_to_ctrl_mem__msg  ,
  input logic [0:0] send_to_ctrl_mem__rdy  ,
  output logic [0:0] send_to_ctrl_mem__val  ,
  output logic [8:0] to_mem_raddr__msg  ,
  input logic [0:0] to_mem_raddr__rdy  ,
  output logic [0:0] to_mem_raddr__val  ,
  output logic [8:0] to_mem_waddr__msg  ,
  input logic [0:0] to_mem_waddr__rdy  ,
  output logic [0:0] to_mem_waddr__val  ,
  output CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 to_mem_wdata__msg  ,
  input logic [0:0] to_mem_wdata__rdy  ,
  output logic [0:0] to_mem_wdata__val  
);
  localparam CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 const_zero  = { 32'd0, 1'd0, 1'd0, 1'd0 };
  localparam logic [6:0] __const__OPT_START  = 7'd0;
  localparam logic [0:0] __const__latency_at_proceed_latency  = 1'd1;
  localparam logic [6:0] __const__OPT_LOOP_CONTROL  = 7'd83;
  localparam logic [2:0] __const__num_inports_at_comb_logic  = 3'd4;
  localparam logic [1:0] __const__num_outports_at_comb_logic  = 2'd2;
  logic [31:0] current_index;
  logic [31:0] end_value;
  logic [2:0] in0;
  logic [2:0] in0_idx;
  logic [2:0] in1;
  logic [2:0] in1_idx;
  logic [2:0] in2;
  logic [2:0] in2_idx;
  logic [2:0] in3;
  logic [2:0] in3_idx;
  logic [0:0] is_first_iter;
  logic [0:0] latency;
  logic [0:0] loop_active;
  logic [0:0] loop_initialized_reg;
  logic [0:0] loop_valid;
  logic [31:0] next_index;
  logic [0:0] reached_vector_factor;
  logic [31:0] start_value;
  logic [31:0] step_value;
  logic [7:0] vector_factor_counter;
  logic [2:0] vector_factor_power;
  logic [1:0] __tmpvar__update_index_in0_idx_ff;
  logic [1:0] __tmpvar__update_index_in1_idx_ff;
  logic [1:0] __tmpvar__update_index_in2_idx_ff;
  logic [1:0] __tmpvar__update_index_in3_idx_ff;
  logic [1:0] __tmpvar__comb_logic_in0_idx_local;
  logic [1:0] __tmpvar__comb_logic_in1_idx_local;
  logic [1:0] __tmpvar__comb_logic_in2_idx_local;
  logic [1:0] __tmpvar__comb_logic_in3_idx_local;
  logic [0:0] __tmpvar__comb_logic_all_inputs_valid;
  logic [0:0] __tmpvar__comb_logic_all_outputs_ready;
  logic [0:0] __tmpvar__comb_logic_parent_valid;
  logic [31:0] __tmpvar__comb_logic_current_idx;
  logic [31:0] __tmpvar__comb_logic_output_idx;

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/fu/single/LoopControlRTL.py:114
  // @update
  // def comb_logic():
  //   # Default signal values
  //   for i in range(num_inports):
  //     s.recv_in[i].rdy @= b1(0)
  //   for i in range(num_outports):
  //     s.send_out[i].val @= 0
  //     s.send_out[i].msg @= s.DataType()
  // 
  //   s.recv_const.rdy @= 0
  //   s.recv_opt.rdy @= 0
  // 
  //   s.send_to_ctrl_mem.val @= 0
  //   s.send_to_ctrl_mem.msg @= s.CgraPayloadType(0, 0, 0, 0, 0)
  //   s.recv_from_ctrl_mem.rdy @= 0
  //   
  //   # Default loop control values
  //   s.loop_valid @= PredicateType(0)
  //   s.loop_active @= b1(0)
  //   s.is_first_iter @= b1(0)
  //   s.next_index @= PayloadType(0)
  //   
  //   # Extract loop parameters - default values
  //   s.start_value @= PayloadType(0)
  //   s.end_value @= PayloadType(0)
  //   s.step_value @= PayloadType(1)
  // 
  //   # Configure input operand indices from operation message
  //   # Set default indices first, truncated to actual recv_in array size
  //   in0_idx_local = trunc(s.in0_idx, RecvInIdxType)
  //   in1_idx_local = trunc(s.in1_idx, RecvInIdxType)
  //   in2_idx_local = trunc(s.in2_idx, RecvInIdxType)
  //   in3_idx_local = trunc(s.in3_idx, RecvInIdxType)
  //   
  //   if s.recv_opt.val:
  //     if s.recv_opt.msg.fu_in[0] != 0:
  //       s.in0 @= zext(s.recv_opt.msg.fu_in[0] - 1, FuInType)
  //       in0_idx_local = trunc(zext(s.recv_opt.msg.fu_in[0] - 1, FuInType), RecvInIdxType)
  //     if s.recv_opt.msg.fu_in[1] != 0:
  //       s.in1 @= zext(s.recv_opt.msg.fu_in[1] - 1, FuInType)
  //       in1_idx_local = trunc(zext(s.recv_opt.msg.fu_in[1] - 1, FuInType), RecvInIdxType)
  //     if s.recv_opt.msg.fu_in[2] != 0:
  //       s.in2 @= zext(s.recv_opt.msg.fu_in[2] - 1, FuInType)
  //       in2_idx_local = trunc(zext(s.recv_opt.msg.fu_in[2] - 1, FuInType), RecvInIdxType)
  //     if s.recv_opt.msg.fu_in[3] != 0:
  //       s.in3 @= zext(s.recv_opt.msg.fu_in[3] - 1, FuInType)
  //       in3_idx_local = trunc(zext(s.recv_opt.msg.fu_in[3] - 1, FuInType), RecvInIdxType)
  // 
  //   # Only process when all required inputs are valid AND output is ready
  //   all_inputs_valid = (
  //     s.recv_opt.val &
  //     (s.recv_opt.msg.operation == OPT_LOOP_CONTROL) &
  //     s.recv_in[in0_idx_local].val &
  //     s.recv_in[in1_idx_local].val &
  //     s.recv_in[in2_idx_local].val &
  //     s.recv_in[in3_idx_local].val &
  //     s.send_out[0].rdy
  //   )
  //   
  //   # Check if all output ports are ready (for recv_opt.rdy)
  //   all_outputs_ready = s.send_out[0].rdy & s.send_out[1].rdy
  // 
  //   if all_inputs_valid:
  //     # Get inputs:
  //     # recv_in[in0]: parent_valid predicate
  //     # recv_in[in1]: start value
  //     # recv_in[in2]: end value  
  //     # recv_in[in3]: step value
  //     parent_valid = s.recv_in[in0_idx_local].msg.predicate
  //     s.start_value @= s.recv_in[in1_idx_local].msg.payload
  //     s.end_value @= s.recv_in[in2_idx_local].msg.payload
  //     s.step_value @= s.recv_in[in3_idx_local].msg.payload
  // 
  //     # Detect first iteration: loop not yet initialized
  //     # This correctly handles start_value=0 and loop reinvocation
  //     s.is_first_iter @= ~s.loop_initialized_reg
  // 
  //     # Compute next index and validity
  //     current_idx = s.current_index
  // 
  //     if s.is_first_iter:
  //       # First iteration: output start value
  //       output_idx = s.start_value
  //       s.next_index @= s.start_value + s.step_value
  //       # Check if start is within bounds
  //       if s.start_value < s.end_value:
  //         s.loop_active @= b1(1)
  //         s.loop_valid @= parent_valid
  //       else:
  //         s.loop_active @= b1(0)
  //         s.loop_valid @= PredicateType(0)
  //     else:
  //       # Subsequent iterations: output current index
  //       output_idx = current_idx
  //       s.next_index @= current_idx + s.step_value
  //       # Check if current index is within bounds
  //       if current_idx < s.end_value:
  //         s.loop_active @= b1(1)
  //         s.loop_valid @= parent_valid
  //       else:
  //         s.loop_active @= b1(0)
  //         s.loop_valid @= PredicateType(0)
  // 
  //     # Output 0: current loop index with predicate
  //     s.send_out[0].msg.payload @= output_idx
  //     s.send_out[0].msg.predicate @= s.loop_valid & s.reached_vector_factor
  //     s.send_out[0].val @= b1(1)
  //     
  //     # Output 1: loop_valid (boolean predicate indicating if loop should continue)
  //     s.send_out[1].msg.payload @= zext(s.loop_valid, PayloadType)
  //     s.send_out[1].msg.predicate @= s.reached_vector_factor
  //     s.send_out[1].val @= b1(1)
  //     
  //     # Set ready signals for inputs when all inputs are consumed
  //     s.recv_in[in0_idx_local].rdy @= b1(1)
  //     s.recv_in[in1_idx_local].rdy @= b1(1)
  //     s.recv_in[in2_idx_local].rdy @= b1(1)
  //     s.recv_in[in3_idx_local].rdy @= b1(1)
  //     
  //     # recv_opt.rdy depends on all outputs being ready
  //     # If send_out is not ready to consume results, we can't proceed to next opt
  //     s.recv_opt.rdy @= all_outputs_ready
  
  always_comb begin : comb_logic
    for ( int unsigned i = 1'd0; i < 3'( __const__num_inports_at_comb_logic ); i += 1'd1 )
      recv_in__rdy[2'(i)] = 1'd0;
    for ( int unsigned i = 1'd0; i < 2'( __const__num_outports_at_comb_logic ); i += 1'd1 ) begin
      send_out__val[1'(i)] = 1'd0;
      send_out__msg[1'(i)] = { 32'd0, 1'd0, 1'd0, 1'd0 };
    end
    recv_const__rdy = 1'd0;
    recv_opt__rdy = 1'd0;
    send_to_ctrl_mem__val = 1'd0;
    send_to_ctrl_mem__msg = { 5'd0, 35'd0, 9'd0, 139'd0, 3'd0 };
    recv_from_ctrl_mem__rdy = 1'd0;
    loop_valid = 1'd0;
    loop_active = 1'd0;
    is_first_iter = 1'd0;
    next_index = 32'd0;
    start_value = 32'd0;
    end_value = 32'd0;
    step_value = 32'd1;
    __tmpvar__comb_logic_in0_idx_local = 2'(in0_idx);
    __tmpvar__comb_logic_in1_idx_local = 2'(in1_idx);
    __tmpvar__comb_logic_in2_idx_local = 2'(in2_idx);
    __tmpvar__comb_logic_in3_idx_local = 2'(in3_idx);
    if ( recv_opt__val ) begin
      if ( recv_opt__msg.fu_in[2'd0] != 3'd0 ) begin
        in0 = recv_opt__msg.fu_in[2'd0] - 3'd1;
        __tmpvar__comb_logic_in0_idx_local = 2'(recv_opt__msg.fu_in[2'd0] - 3'd1);
      end
      if ( recv_opt__msg.fu_in[2'd1] != 3'd0 ) begin
        in1 = recv_opt__msg.fu_in[2'd1] - 3'd1;
        __tmpvar__comb_logic_in1_idx_local = 2'(recv_opt__msg.fu_in[2'd1] - 3'd1);
      end
      if ( recv_opt__msg.fu_in[2'd2] != 3'd0 ) begin
        in2 = recv_opt__msg.fu_in[2'd2] - 3'd1;
        __tmpvar__comb_logic_in2_idx_local = 2'(recv_opt__msg.fu_in[2'd2] - 3'd1);
      end
      if ( recv_opt__msg.fu_in[2'd3] != 3'd0 ) begin
        in3 = recv_opt__msg.fu_in[2'd3] - 3'd1;
        __tmpvar__comb_logic_in3_idx_local = 2'(recv_opt__msg.fu_in[2'd3] - 3'd1);
      end
    end
    __tmpvar__comb_logic_all_inputs_valid = ( ( ( ( ( recv_opt__val & ( recv_opt__msg.operation == 7'( __const__OPT_LOOP_CONTROL ) ) ) & recv_in__val[__tmpvar__comb_logic_in0_idx_local] ) & recv_in__val[__tmpvar__comb_logic_in1_idx_local] ) & recv_in__val[__tmpvar__comb_logic_in2_idx_local] ) & recv_in__val[__tmpvar__comb_logic_in3_idx_local] ) & send_out__rdy[1'd0];
    __tmpvar__comb_logic_all_outputs_ready = send_out__rdy[1'd0] & send_out__rdy[1'd1];
    if ( __tmpvar__comb_logic_all_inputs_valid ) begin
      __tmpvar__comb_logic_parent_valid = recv_in__msg[__tmpvar__comb_logic_in0_idx_local].predicate;
      start_value = recv_in__msg[__tmpvar__comb_logic_in1_idx_local].payload;
      end_value = recv_in__msg[__tmpvar__comb_logic_in2_idx_local].payload;
      step_value = recv_in__msg[__tmpvar__comb_logic_in3_idx_local].payload;
      is_first_iter = ~loop_initialized_reg;
      __tmpvar__comb_logic_current_idx = current_index;
      if ( is_first_iter ) begin
        __tmpvar__comb_logic_output_idx = start_value;
        next_index = start_value + step_value;
        if ( start_value < end_value ) begin
          loop_active = 1'd1;
          loop_valid = __tmpvar__comb_logic_parent_valid;
        end
        else begin
          loop_active = 1'd0;
          loop_valid = 1'd0;
        end
      end
      else begin
        __tmpvar__comb_logic_output_idx = __tmpvar__comb_logic_current_idx;
        next_index = __tmpvar__comb_logic_current_idx + step_value;
        if ( __tmpvar__comb_logic_current_idx < end_value ) begin
          loop_active = 1'd1;
          loop_valid = __tmpvar__comb_logic_parent_valid;
        end
        else begin
          loop_active = 1'd0;
          loop_valid = 1'd0;
        end
      end
      send_out__msg[1'd0].payload = __tmpvar__comb_logic_output_idx;
      send_out__msg[1'd0].predicate = loop_valid & reached_vector_factor;
      send_out__val[1'd0] = 1'd1;
      send_out__msg[1'd1].payload = { { 31 { 1'b0 } }, loop_valid };
      send_out__msg[1'd1].predicate = reached_vector_factor;
      send_out__val[1'd1] = 1'd1;
      recv_in__rdy[__tmpvar__comb_logic_in0_idx_local] = 1'd1;
      recv_in__rdy[__tmpvar__comb_logic_in1_idx_local] = 1'd1;
      recv_in__rdy[__tmpvar__comb_logic_in2_idx_local] = 1'd1;
      recv_in__rdy[__tmpvar__comb_logic_in3_idx_local] = 1'd1;
      recv_opt__rdy = __tmpvar__comb_logic_all_outputs_ready;
    end
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/fu/single/LoopControlRTL.py:67
  // @update
  // def update_indices():
  //   s.in0_idx @= s.in0
  //   s.in1_idx @= s.in1
  //   s.in2_idx @= s.in2
  //   s.in3_idx @= s.in3
  
  always_comb begin : update_indices
    in0_idx = in0;
    in1_idx = in1;
    in2_idx = in2;
    in3_idx = in3;
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/fu/basic/Fu.py:68
  // @update
  // def update_mem():
  //   s.to_mem_waddr.val @= b1(0)
  //   s.to_mem_wdata.val @= b1(0)
  //   s.to_mem_wdata.msg @= s.const_zero
  //   s.to_mem_waddr.msg @= s.DataAddrType(0)
  //   s.to_mem_raddr.msg @= s.DataAddrType(0)
  //   s.to_mem_raddr.val @= b1(0)
  //   s.from_mem_rdata.rdy @= b1(0)
  
  always_comb begin : update_mem
    to_mem_waddr__val = 1'd0;
    to_mem_wdata__val = 1'd0;
    to_mem_wdata__msg = const_zero;
    to_mem_waddr__msg = 9'd0;
    to_mem_raddr__msg = 9'd0;
    to_mem_raddr__val = 1'd0;
    from_mem_rdata__rdy = 1'd0;
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/fu/basic/Fu.py:87
  // @update
  // def update_reached_vector_factor():
  //   s.reached_vector_factor @= 0
  //   if s.recv_opt.val & (s.vector_factor_counter + \
  //                        (VectorFactorType(1) << zext(s.vector_factor_power, VectorFactorType)) >= \
  //                        (VectorFactorType(1) << zext(s.recv_opt.msg.vector_factor_power, VectorFactorType))):
  //     s.reached_vector_factor @= 1
  
  always_comb begin : update_reached_vector_factor
    reached_vector_factor = 1'd0;
    if ( recv_opt__val & ( ( vector_factor_counter + ( 8'd1 << { { 5 { 1'b0 } }, vector_factor_power } ) ) >= ( 8'd1 << { { 5 { 1'b0 } }, recv_opt__msg.vector_factor_power } ) ) ) begin
      reached_vector_factor = 1'd1;
    end
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/fu/basic/Fu.py:78
  // @update_ff
  // def proceed_latency():
  //   if s.recv_opt.msg.operation == OPT_START:
  //     s.latency <<= LatencyType(0)
  //   elif s.latency == latency - 1:
  //     s.latency <<= LatencyType(0)
  //   else:
  //     s.latency <<= s.latency + LatencyType(1)
  
  always_ff @(posedge clk) begin : proceed_latency
    if ( recv_opt__msg.operation == 7'( __const__OPT_START ) ) begin
      latency <= 1'd0;
    end
    else if ( latency == ( 1'( __const__latency_at_proceed_latency ) - 1'd1 ) ) begin
      latency <= 1'd0;
    end
    else
      latency <= latency + 1'd1;
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/fu/single/LoopControlRTL.py:78
  // @update_ff
  // def update_index():
  //   if s.reset:
  //     s.current_index <<= PayloadType(0)
  //     s.loop_initialized_reg <<= b1(0)
  //   else:
  //     # Compute indices locally for sequential logic to avoid using stale wire values
  //     in0_idx_ff = trunc(s.in0, RecvInIdxType)
  //     in1_idx_ff = trunc(s.in1, RecvInIdxType)
  //     in2_idx_ff = trunc(s.in2, RecvInIdxType)
  //     in3_idx_ff = trunc(s.in3, RecvInIdxType)
  //     
  //     # Update from recv_opt if valid
  //     if s.recv_opt.val & (s.recv_opt.msg.operation == OPT_LOOP_CONTROL):
  //       if s.recv_opt.msg.fu_in[0] != 0:
  //         in0_idx_ff = trunc(zext(s.recv_opt.msg.fu_in[0] - 1, FuInType), RecvInIdxType)
  //       if s.recv_opt.msg.fu_in[1] != 0:
  //         in1_idx_ff = trunc(zext(s.recv_opt.msg.fu_in[1] - 1, FuInType), RecvInIdxType)
  //       if s.recv_opt.msg.fu_in[2] != 0:
  //         in2_idx_ff = trunc(zext(s.recv_opt.msg.fu_in[2] - 1, FuInType), RecvInIdxType)
  //       if s.recv_opt.msg.fu_in[3] != 0:
  //         in3_idx_ff = trunc(zext(s.recv_opt.msg.fu_in[3] - 1, FuInType), RecvInIdxType)
  //     
  //     # Update state when we successfully process inputs
  //     # Check if valid operation is present and inputs are available
  //     if (s.recv_opt.val & (s.recv_opt.msg.operation == OPT_LOOP_CONTROL)
  //          & s.recv_in[in0_idx_ff].val & s.recv_in[in1_idx_ff].val
  //          & s.recv_in[in2_idx_ff].val & s.recv_in[in3_idx_ff].val
  //          & s.send_out[0].rdy):
  //       # Update current index after sending output
  //       s.current_index <<= s.next_index
  //       # Mark loop as initialized after first iteration
  //       # Use combinational signal check before state update
  //       if ~s.loop_initialized_reg:
  //         s.loop_initialized_reg <<= b1(1)
  
  always_ff @(posedge clk) begin : update_index
    if ( reset ) begin
      current_index <= 32'd0;
      loop_initialized_reg <= 1'd0;
    end
    else begin
      __tmpvar__update_index_in0_idx_ff = 2'(in0);
      __tmpvar__update_index_in1_idx_ff = 2'(in1);
      __tmpvar__update_index_in2_idx_ff = 2'(in2);
      __tmpvar__update_index_in3_idx_ff = 2'(in3);
      if ( recv_opt__val & ( recv_opt__msg.operation == 7'( __const__OPT_LOOP_CONTROL ) ) ) begin
        if ( recv_opt__msg.fu_in[2'd0] != 3'd0 ) begin
          __tmpvar__update_index_in0_idx_ff = 2'(recv_opt__msg.fu_in[2'd0] - 3'd1);
        end
        if ( recv_opt__msg.fu_in[2'd1] != 3'd0 ) begin
          __tmpvar__update_index_in1_idx_ff = 2'(recv_opt__msg.fu_in[2'd1] - 3'd1);
        end
        if ( recv_opt__msg.fu_in[2'd2] != 3'd0 ) begin
          __tmpvar__update_index_in2_idx_ff = 2'(recv_opt__msg.fu_in[2'd2] - 3'd1);
        end
        if ( recv_opt__msg.fu_in[2'd3] != 3'd0 ) begin
          __tmpvar__update_index_in3_idx_ff = 2'(recv_opt__msg.fu_in[2'd3] - 3'd1);
        end
      end
      if ( ( ( ( ( ( recv_opt__val & ( recv_opt__msg.operation == 7'( __const__OPT_LOOP_CONTROL ) ) ) & recv_in__val[__tmpvar__update_index_in0_idx_ff] ) & recv_in__val[__tmpvar__update_index_in1_idx_ff] ) & recv_in__val[__tmpvar__update_index_in2_idx_ff] ) & recv_in__val[__tmpvar__update_index_in3_idx_ff] ) & send_out__rdy[1'd0] ) begin
        current_index <= next_index;
        if ( ~loop_initialized_reg ) begin
          loop_initialized_reg <= 1'd1;
        end
      end
    end
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/fu/basic/Fu.py:95
  // @update_ff
  // def update_vector_factor_counter():
  //   if s.reset:
  //     s.vector_factor_counter <<= 0
  //   else:
  //     if s.recv_opt.val:
  //       if s.recv_opt.msg.is_last_ctrl & \
  //          (s.vector_factor_counter + \
  //           (VectorFactorType(1) << zext(s.vector_factor_power, VectorFactorType)) < \
  //           (VectorFactorType(1) << zext(s.recv_opt.msg.vector_factor_power, VectorFactorType))):
  //         s.vector_factor_counter <<= s.vector_factor_counter + \
  //                                     (VectorFactorType(1) << zext(s.vector_factor_power, \
  //                                                                  VectorFactorType))
  //       elif s.recv_opt.msg.is_last_ctrl & s.reached_vector_factor:
  //         s.vector_factor_counter <<= 0
  
  always_ff @(posedge clk) begin : update_vector_factor_counter
    if ( reset ) begin
      vector_factor_counter <= 8'd0;
    end
    else if ( recv_opt__val ) begin
      if ( recv_opt__msg.is_last_ctrl & ( ( vector_factor_counter + ( 8'd1 << { { 5 { 1'b0 } }, vector_factor_power } ) ) < ( 8'd1 << { { 5 { 1'b0 } }, recv_opt__msg.vector_factor_power } ) ) ) begin
        vector_factor_counter <= vector_factor_counter + ( 8'd1 << { { 5 { 1'b0 } }, vector_factor_power } );
      end
      else if ( recv_opt__msg.is_last_ctrl & reached_vector_factor ) begin
        vector_factor_counter <= 8'd0;
      end
    end
  end

  assign vector_factor_power = 3'd0;

endmodule


// PyMTL Component RetRTL Definition
// Full name: RetRTL__CtrlPktType_IntraCgraPacket_4_4x1_4_8_2_CgraPayload__11cd3f8c0d91825c__num_inports_4__num_outports_2__vector_factor_power_0
// At /cgra/VectorCGRA/fu/single/RetRTL.py

module RetRTL__1a7eacb70e3ca1c4
(
  input  logic [0:0] clear ,
  input  logic [0:0] clk ,
  input  logic [2:0] ctrl_addr_inport ,
  input  logic [0:0] reset ,
  input CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 from_mem_rdata__msg  ,
  output logic [0:0] from_mem_rdata__rdy  ,
  input logic [0:0] from_mem_rdata__val  ,
  input CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 recv_const__msg  ,
  output logic [0:0] recv_const__rdy  ,
  input logic [0:0] recv_const__val  ,
  input MultiCgraPayload_Cmd_Data_DataAddr_Ctrl_CtrlAddr__a0427cd98cfcae6f recv_from_ctrl_mem__msg  ,
  output logic [0:0] recv_from_ctrl_mem__rdy  ,
  input logic [0:0] recv_from_ctrl_mem__val  ,
  input CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 recv_in__msg [0:3] ,
  output logic [0:0] recv_in__rdy [0:3] ,
  input logic [0:0] recv_in__val [0:3] ,
  input CGRAConfig_7_4_2_8_8_3__603a41f5d0e2436f recv_opt__msg  ,
  output logic [0:0] recv_opt__rdy  ,
  input logic [0:0] recv_opt__val  ,
  output CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 send_out__msg [0:1] ,
  input logic [0:0] send_out__rdy [0:1] ,
  output logic [0:0] send_out__val [0:1] ,
  output MultiCgraPayload_Cmd_Data_DataAddr_Ctrl_CtrlAddr__a0427cd98cfcae6f send_to_ctrl_mem__msg  ,
  input logic [0:0] send_to_ctrl_mem__rdy  ,
  output logic [0:0] send_to_ctrl_mem__val  ,
  output logic [8:0] to_mem_raddr__msg  ,
  input logic [0:0] to_mem_raddr__rdy  ,
  output logic [0:0] to_mem_raddr__val  ,
  output logic [8:0] to_mem_waddr__msg  ,
  input logic [0:0] to_mem_waddr__rdy  ,
  output logic [0:0] to_mem_waddr__val  ,
  output CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 to_mem_wdata__msg  ,
  input logic [0:0] to_mem_wdata__rdy  ,
  output logic [0:0] to_mem_wdata__val  
);
  localparam CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 const_zero  = { 32'd0, 1'd0, 1'd0, 1'd0 };
  localparam logic [6:0] __const__OPT_START  = 7'd0;
  localparam logic [0:0] __const__latency_at_proceed_latency  = 1'd1;
  localparam logic [2:0] __const__num_inports_at_comb_logic  = 3'd4;
  localparam logic [1:0] __const__num_outports_at_comb_logic  = 2'd2;
  localparam logic [6:0] __const__OPT_RET  = 7'd35;
  localparam logic [3:0] __const__CMD_COMPLETE  = 4'd14;
  localparam logic [6:0] __const__OPT_RET_VOID  = 7'd64;
  localparam logic [3:0] __const__ctrl_mem_size_at_update_already_done  = 4'd8;
  logic [0:0] already_done [0:7];
  logic [2:0] in0;
  logic [1:0] in0_idx;
  logic [0:0] latency;
  logic [0:0] reached_vector_factor;
  logic [0:0] recv_all_val;
  logic [7:0] vector_factor_counter;
  logic [2:0] vector_factor_power;

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/fu/single/RetRTL.py:44
  // @update
  // def comb_logic():
  // 
  //   s.recv_all_val @= 0
  //   # For pick input register.
  //   s.in0 @= 0
  //   for i in range(num_inports):
  //     s.recv_in[i].rdy @= b1(0)
  // 
  //   for j in range(num_outports):
  //     s.send_out[j].val @= 0
  //     s.send_out[j].msg @= s.DataType()
  // 
  //   s.send_to_ctrl_mem.val @= 0
  //   s.send_to_ctrl_mem.msg @= s.CgraPayloadType(0, 0, 0, 0, 0)
  //   s.recv_from_ctrl_mem.rdy @= 0
  // 
  //   s.recv_const.rdy @= 0
  //   s.recv_opt.rdy @= 0
  // 
  //   if s.recv_opt.val:
  //     if s.recv_opt.msg.fu_in[0] != FuInType(0):
  //       s.in0 @= s.recv_opt.msg.fu_in[0] - FuInType(1)
  // 
  //   if s.recv_opt.val:
  //     if s.recv_opt.msg.operation == OPT_RET:
  //       s.recv_all_val @= s.recv_in[s.in0_idx].val
  //       # Value to be returned is usually granted with a predicate:
  //       # https://github.com/coredac/dataflow/blob/b9ffc097d67429017323e3d50d3984655f756b91/test/neura/ctrl/branch_for.mlir#L150.
  //       if s.already_done[s.ctrl_addr_inport]:
  //         s.recv_in[s.in0_idx].rdy @= s.recv_all_val
  //         s.recv_opt.rdy @= s.recv_all_val
  //       elif s.recv_in[s.in0_idx].msg.predicate:
  //         # Only when the predicate is true, the value will be sent back to CPU.
  //         s.send_to_ctrl_mem.val @= s.recv_all_val & s.reached_vector_factor
  //         # s.send_to_ctrl_mem.msg @= s.recv_in[s.in0_idx].msg
  //         s.send_to_ctrl_mem.msg @= s.CgraPayloadType(CMD_COMPLETE, s.recv_in[s.in0_idx].msg, 0, s.recv_opt.msg, 0)
  //         s.recv_in[s.in0_idx].rdy @= s.recv_all_val & s.reached_vector_factor & s.send_to_ctrl_mem.rdy
  //         s.recv_opt.rdy @= s.recv_all_val & s.reached_vector_factor & s.send_to_ctrl_mem.rdy
  //       else:
  //         s.recv_in[s.in0_idx].rdy @= s.recv_all_val & s.reached_vector_factor
  //         s.recv_opt.rdy @= s.recv_all_val & s.reached_vector_factor
  //     elif s.recv_opt.msg.operation == OPT_RET_VOID:
  //       s.recv_all_val @= s.recv_in[s.in0_idx].val
  //       if s.already_done[s.ctrl_addr_inport]:
  //         s.recv_in[s.in0_idx].rdy @= s.recv_all_val
  //         s.recv_opt.rdy @= s.recv_all_val
  //       elif s.recv_in[s.in0_idx].msg.predicate:
  //         # RET_VOID: only notifies the ctrl mem to send CMD_COMPLETE without data.
  //         s.send_to_ctrl_mem.val @= s.recv_all_val & s.reached_vector_factor
  //         # Sends 0 as data (controller is supposed to know it's RET_VOID based on the operation and data type).
  //         s.send_to_ctrl_mem.msg @= s.CgraPayloadType(CMD_COMPLETE, 0, 0, s.recv_opt.msg, 0)
  //         s.recv_in[s.in0_idx].rdy @= s.recv_all_val & s.reached_vector_factor & s.send_to_ctrl_mem.rdy
  //         s.recv_opt.rdy @= s.recv_all_val & s.reached_vector_factor & s.send_to_ctrl_mem.rdy
  //       else:
  //         # Predicate is false, just consumes the input.
  //         s.recv_in[s.in0_idx].rdy @= s.recv_all_val & s.reached_vector_factor
  //         s.recv_opt.rdy @= s.recv_all_val & s.reached_vector_factor
  
  always_comb begin : comb_logic
    recv_all_val = 1'd0;
    in0 = 3'd0;
    for ( int unsigned i = 1'd0; i < 3'( __const__num_inports_at_comb_logic ); i += 1'd1 )
      recv_in__rdy[2'(i)] = 1'd0;
    for ( int unsigned j = 1'd0; j < 2'( __const__num_outports_at_comb_logic ); j += 1'd1 ) begin
      send_out__val[1'(j)] = 1'd0;
      send_out__msg[1'(j)] = { 32'd0, 1'd0, 1'd0, 1'd0 };
    end
    send_to_ctrl_mem__val = 1'd0;
    send_to_ctrl_mem__msg = { 5'd0, 35'd0, 9'd0, 139'd0, 3'd0 };
    recv_from_ctrl_mem__rdy = 1'd0;
    recv_const__rdy = 1'd0;
    recv_opt__rdy = 1'd0;
    if ( recv_opt__val ) begin
      if ( recv_opt__msg.fu_in[2'd0] != 3'd0 ) begin
        in0 = recv_opt__msg.fu_in[2'd0] - 3'd1;
      end
    end
    if ( recv_opt__val ) begin
      if ( recv_opt__msg.operation == 7'( __const__OPT_RET ) ) begin
        recv_all_val = recv_in__val[in0_idx];
        if ( already_done[ctrl_addr_inport] ) begin
          recv_in__rdy[in0_idx] = recv_all_val;
          recv_opt__rdy = recv_all_val;
        end
        else if ( recv_in__msg[in0_idx].predicate ) begin
          send_to_ctrl_mem__val = recv_all_val & reached_vector_factor;
          send_to_ctrl_mem__msg = { 5'( __const__CMD_COMPLETE ), recv_in__msg[in0_idx], 9'd0, recv_opt__msg, 3'd0 };
          recv_in__rdy[in0_idx] = ( recv_all_val & reached_vector_factor ) & send_to_ctrl_mem__rdy;
          recv_opt__rdy = ( recv_all_val & reached_vector_factor ) & send_to_ctrl_mem__rdy;
        end
        else begin
          recv_in__rdy[in0_idx] = recv_all_val & reached_vector_factor;
          recv_opt__rdy = recv_all_val & reached_vector_factor;
        end
      end
      else if ( recv_opt__msg.operation == 7'( __const__OPT_RET_VOID ) ) begin
        recv_all_val = recv_in__val[in0_idx];
        if ( already_done[ctrl_addr_inport] ) begin
          recv_in__rdy[in0_idx] = recv_all_val;
          recv_opt__rdy = recv_all_val;
        end
        else if ( recv_in__msg[in0_idx].predicate ) begin
          send_to_ctrl_mem__val = recv_all_val & reached_vector_factor;
          send_to_ctrl_mem__msg = { 5'( __const__CMD_COMPLETE ), 35'd0, 9'd0, recv_opt__msg, 3'd0 };
          recv_in__rdy[in0_idx] = ( recv_all_val & reached_vector_factor ) & send_to_ctrl_mem__rdy;
          recv_opt__rdy = ( recv_all_val & reached_vector_factor ) & send_to_ctrl_mem__rdy;
        end
        else begin
          recv_in__rdy[in0_idx] = recv_all_val & reached_vector_factor;
          recv_opt__rdy = recv_all_val & reached_vector_factor;
        end
      end
    end
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/fu/basic/Fu.py:68
  // @update
  // def update_mem():
  //   s.to_mem_waddr.val @= b1(0)
  //   s.to_mem_wdata.val @= b1(0)
  //   s.to_mem_wdata.msg @= s.const_zero
  //   s.to_mem_waddr.msg @= s.DataAddrType(0)
  //   s.to_mem_raddr.msg @= s.DataAddrType(0)
  //   s.to_mem_raddr.val @= b1(0)
  //   s.from_mem_rdata.rdy @= b1(0)
  
  always_comb begin : update_mem
    to_mem_waddr__val = 1'd0;
    to_mem_wdata__val = 1'd0;
    to_mem_wdata__msg = const_zero;
    to_mem_waddr__msg = 9'd0;
    to_mem_raddr__msg = 9'd0;
    to_mem_raddr__val = 1'd0;
    from_mem_rdata__rdy = 1'd0;
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/fu/basic/Fu.py:87
  // @update
  // def update_reached_vector_factor():
  //   s.reached_vector_factor @= 0
  //   if s.recv_opt.val & (s.vector_factor_counter + \
  //                        (VectorFactorType(1) << zext(s.vector_factor_power, VectorFactorType)) >= \
  //                        (VectorFactorType(1) << zext(s.recv_opt.msg.vector_factor_power, VectorFactorType))):
  //     s.reached_vector_factor @= 1
  
  always_comb begin : update_reached_vector_factor
    reached_vector_factor = 1'd0;
    if ( recv_opt__val & ( ( vector_factor_counter + ( 8'd1 << { { 5 { 1'b0 } }, vector_factor_power } ) ) >= ( 8'd1 << { { 5 { 1'b0 } }, recv_opt__msg.vector_factor_power } ) ) ) begin
      reached_vector_factor = 1'd1;
    end
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/fu/basic/Fu.py:78
  // @update_ff
  // def proceed_latency():
  //   if s.recv_opt.msg.operation == OPT_START:
  //     s.latency <<= LatencyType(0)
  //   elif s.latency == latency - 1:
  //     s.latency <<= LatencyType(0)
  //   else:
  //     s.latency <<= s.latency + LatencyType(1)
  
  always_ff @(posedge clk) begin : proceed_latency
    if ( recv_opt__msg.operation == 7'( __const__OPT_START ) ) begin
      latency <= 1'd0;
    end
    else if ( latency == ( 1'( __const__latency_at_proceed_latency ) - 1'd1 ) ) begin
      latency <= 1'd0;
    end
    else
      latency <= latency + 1'd1;
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/fu/single/RetRTL.py:105
  // @update_ff
  // def update_already_done():
  //   if s.reset | s.clear:
  //     for i in range(ctrl_mem_size):
  //       s.already_done[i] <<= 0
  //   else:
  //     if s.recv_opt.val & \
  //        ((s.recv_opt.msg.operation == OPT_RET) | (s.recv_opt.msg.operation == OPT_RET_VOID)) & \
  //         ~s.already_done[s.ctrl_addr_inport] & \
  //         s.recv_all_val & \
  //         s.recv_in[s.in0_idx].msg.predicate & \
  //         s.send_to_ctrl_mem.val & \
  //         s.send_to_ctrl_mem.rdy:
  //       for i in range(ctrl_mem_size):
  //         if i == s.ctrl_addr_inport:
  //           s.already_done[i] <<= 1
  //         else:
  //           s.already_done[i] <<= s.already_done[i]
  //     else:
  //       for i in range(ctrl_mem_size):
  //         s.already_done[i] <<= s.already_done[i]
  
  always_ff @(posedge clk) begin : update_already_done
    if ( reset | clear ) begin
      for ( int unsigned i = 1'd0; i < 4'( __const__ctrl_mem_size_at_update_already_done ); i += 1'd1 )
        already_done[3'(i)] <= 1'd0;
    end
    else if ( ( ( ( ( ( recv_opt__val & ( ( recv_opt__msg.operation == 7'( __const__OPT_RET ) ) | ( recv_opt__msg.operation == 7'( __const__OPT_RET_VOID ) ) ) ) & ( ~already_done[ctrl_addr_inport] ) ) & recv_all_val ) & recv_in__msg[in0_idx].predicate ) & send_to_ctrl_mem__val ) & send_to_ctrl_mem__rdy ) begin
      for ( int unsigned i = 1'd0; i < 4'( __const__ctrl_mem_size_at_update_already_done ); i += 1'd1 )
        if ( 3'(i) == ctrl_addr_inport ) begin
          already_done[3'(i)] <= 1'd1;
        end
        else
          already_done[3'(i)] <= already_done[3'(i)];
    end
    else
      for ( int unsigned i = 1'd0; i < 4'( __const__ctrl_mem_size_at_update_already_done ); i += 1'd1 )
        already_done[3'(i)] <= already_done[3'(i)];
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/fu/basic/Fu.py:95
  // @update_ff
  // def update_vector_factor_counter():
  //   if s.reset:
  //     s.vector_factor_counter <<= 0
  //   else:
  //     if s.recv_opt.val:
  //       if s.recv_opt.msg.is_last_ctrl & \
  //          (s.vector_factor_counter + \
  //           (VectorFactorType(1) << zext(s.vector_factor_power, VectorFactorType)) < \
  //           (VectorFactorType(1) << zext(s.recv_opt.msg.vector_factor_power, VectorFactorType))):
  //         s.vector_factor_counter <<= s.vector_factor_counter + \
  //                                     (VectorFactorType(1) << zext(s.vector_factor_power, \
  //                                                                  VectorFactorType))
  //       elif s.recv_opt.msg.is_last_ctrl & s.reached_vector_factor:
  //         s.vector_factor_counter <<= 0
  
  always_ff @(posedge clk) begin : update_vector_factor_counter
    if ( reset ) begin
      vector_factor_counter <= 8'd0;
    end
    else if ( recv_opt__val ) begin
      if ( recv_opt__msg.is_last_ctrl & ( ( vector_factor_counter + ( 8'd1 << { { 5 { 1'b0 } }, vector_factor_power } ) ) < ( 8'd1 << { { 5 { 1'b0 } }, recv_opt__msg.vector_factor_power } ) ) ) begin
        vector_factor_counter <= vector_factor_counter + ( 8'd1 << { { 5 { 1'b0 } }, vector_factor_power } );
      end
      else if ( recv_opt__msg.is_last_ctrl & reached_vector_factor ) begin
        vector_factor_counter <= 8'd0;
      end
    end
  end

  assign vector_factor_power = 3'd0;
  assign in0_idx = in0[1:0];

endmodule


// PyMTL VerilogPlaceholder Div Definition
// At /cgra/VectorCGRA/fu/single/ExclusiveDivRTL.py

//***********************************************************
// Pickled source file of placeholder Div__WIDTH_32__CYCLE_4
//***********************************************************

//-----------------------------------------------------------
// Dependency of placeholder Div
//-----------------------------------------------------------

`ifndef DIV
`define DIV

// The source code below are included because they are specified
// as the v_libs Verilog placeholder option of component Div__WIDTH_32__CYCLE_4.

// If you get a duplicated def error from files included below, please
// make sure they are included either through the v_libs option or the
// explicit `include statement in the Verilog source code -- if they
// appear in both then they will be included twice!


// End of all v_libs files for component Div__WIDTH_32__CYCLE_4

`line 1 "/cgra/VectorCGRA/fu/single/division.v" 0
/*
==========================================================================
division.v
==========================================================================
Integer division module for VectorCGRA.

Author : Jiajun Qin
  Date : 9 July, 2025
*/

module division #(
    parameter WIDTH      = 32,
    parameter ITER_BEGIN = 0,
    parameter ITER_END   = 32
) (
    input  [WIDTH-1:0] dividend,
    input  [WIDTH-1:0] divisor,
    input  [WIDTH:0]   r_i,
    input  [WIDTH-1:0] q_i,
    output  [WIDTH:0]   r_o,
    output  [WIDTH-1:0] q_o
);

    reg [WIDTH:0]   r;    // 33-bit remainder (extra bit for overflow)
    reg [WIDTH-1:0] q;    // Quotient

    parameter HIGHEST_BIT = WIDTH - 1;

    always @(*) begin
        integer i;

        r = r_i;
        q = q_i;

        for (i = ITER_BEGIN; i < ITER_END; i = i + 1) begin
            // Shift remainder left and insert next bit of dividend
            r = (r << 1) | ((dividend >> (HIGHEST_BIT - i)) & 1'b1);
            
            // Compare and subtract if possible
            if (r >= divisor) begin
                r = r - divisor;
                q[HIGHEST_BIT - i] = 1'b1;  // Set cur_ient quotient bit
            end else begin
                q[HIGHEST_BIT - i] = 1'b0;
            end
        end
    end

    assign r_o = r;
    assign q_o = q;

endmodule

module pipeline_division #(
    parameter WIDTH = 32,
    parameter CYCLE = 8
) (
    input  clk,
    input  reset,
    input  [WIDTH-1:0] dividend,
    input  [WIDTH-1:0] divisor,
    output [WIDTH-1:0] quotient,
    output [WIDTH-1:0] remainder
);

    parameter num_div = WIDTH / CYCLE;
    parameter res_div = WIDTH - CYCLE * num_div;

    // Pipeline registers between stages
    reg [WIDTH-1:0] q_i[0:CYCLE-1];             // Temporal quotient          
    reg [WIDTH:0]   r_i[0:CYCLE-1];             // Temporal remainder
    wire [WIDTH-1:0] q_o[0:CYCLE-1];
    wire [WIDTH:0]   r_o[0:CYCLE-1];

    // Pipeline registers for dividend and divisor
    // Since there could be CYCLE divisions in parallel,
    // we need to store the dividend and divisor for each stage.
    reg [WIDTH-1:0] dividend_reg[0:CYCLE-1];    
    reg [WIDTH-1:0] divisor_reg [0:CYCLE-1];

    genvar i; 

    always @(*) begin
        dividend_reg[0] = dividend;
        divisor_reg[0] = divisor;
        q_i[0] = 0;
        r_i[0] = 0;
    end

    generate
        for (i = 1; i < CYCLE; i++) begin
            always @(posedge clk) begin
                if (reset) begin
                    q_i[i] <= 0;
                    r_i[i] <= 0;
                    dividend_reg[i] <= 0;
                    divisor_reg[i]  <= 0;
                end
                else begin             // Propagate values through pipeline
                    q_i[i] <= q_o[i-1];           // Temporal quotient to next stage
                    r_i[i] <= r_o[i-1];           // Temporal remainder to next stage
                    dividend_reg[i] <= dividend_reg[i-1];       // Forward dividend
                    divisor_reg[i]  <= divisor_reg[i-1];        // Forward divisor
                end
            end
        end
    endgenerate

    generate
        for (i = 0; i < CYCLE; i++) begin
            division #(
                .WIDTH(WIDTH),
                .ITER_BEGIN(i * num_div),
                .ITER_END((i + 1) * num_div)
            ) u0 (
                .dividend(dividend_reg[i]),
                .divisor(divisor_reg[i]),
                .q_i(q_i[i]),
                .r_i(r_i[i]),
                .q_o(q_o[i]),
                .r_o(r_o[i])
            );
        end
    endgenerate

    // Final outputs from last pipeline stage
    assign quotient  = q_o[CYCLE-1];
    assign remainder = r_o[CYCLE-1][WIDTH-1:0];

endmodule
`endif /* DIV */

//-----------------------------------------------------------
// Wrapper of placeholder Div__WIDTH_32__CYCLE_4
//-----------------------------------------------------------

`ifndef DIV__WIDTH_32__CYCLE_4
`define DIV__WIDTH_32__CYCLE_4

module Div__WIDTH_32__CYCLE_4
(
  input logic [1-1:0] clk ,
  input logic [32-1:0] dividend ,
  input logic [32-1:0] divisor ,
  output logic [32-1:0] quotient ,
  output logic [32-1:0] remainder ,
  input logic [1-1:0] reset 
);
  pipeline_division
  #(
    .WIDTH( 32 ),
    .CYCLE( 4 )
  ) v
  (
    .clk( clk ),
    .dividend( dividend ),
    .divisor( divisor ),
    .quotient( quotient ),
    .remainder( remainder ),
    .reset( reset )
  );
endmodule

`endif /* DIV__WIDTH_32__CYCLE_4 */



// PyMTL Component ExclusiveDivRTL Definition
// Full name: ExclusiveDivRTL__CtrlPktType_IntraCgraPacket_4_4x1_4_8_2_CgraPayload__11cd3f8c0d91825c__num_inports_4__num_outports_2__latency_4__vector_factor_power_0
// At /cgra/VectorCGRA/fu/single/ExclusiveDivRTL.py

module ExclusiveDivRTL__0770bc9caceb7e60
(
  input  logic [0:0] clear ,
  input  logic [0:0] clk ,
  input  logic [2:0] ctrl_addr_inport ,
  input  logic [0:0] reset ,
  input CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 from_mem_rdata__msg  ,
  output logic [0:0] from_mem_rdata__rdy  ,
  input logic [0:0] from_mem_rdata__val  ,
  input CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 recv_const__msg  ,
  output logic [0:0] recv_const__rdy  ,
  input logic [0:0] recv_const__val  ,
  input MultiCgraPayload_Cmd_Data_DataAddr_Ctrl_CtrlAddr__a0427cd98cfcae6f recv_from_ctrl_mem__msg  ,
  output logic [0:0] recv_from_ctrl_mem__rdy  ,
  input logic [0:0] recv_from_ctrl_mem__val  ,
  input CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 recv_in__msg [0:3] ,
  output logic [0:0] recv_in__rdy [0:3] ,
  input logic [0:0] recv_in__val [0:3] ,
  input CGRAConfig_7_4_2_8_8_3__603a41f5d0e2436f recv_opt__msg  ,
  output logic [0:0] recv_opt__rdy  ,
  input logic [0:0] recv_opt__val  ,
  output CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 send_out__msg [0:1] ,
  input logic [0:0] send_out__rdy [0:1] ,
  output logic [0:0] send_out__val [0:1] ,
  output MultiCgraPayload_Cmd_Data_DataAddr_Ctrl_CtrlAddr__a0427cd98cfcae6f send_to_ctrl_mem__msg  ,
  input logic [0:0] send_to_ctrl_mem__rdy  ,
  output logic [0:0] send_to_ctrl_mem__val  ,
  output logic [8:0] to_mem_raddr__msg  ,
  input logic [0:0] to_mem_raddr__rdy  ,
  output logic [0:0] to_mem_raddr__val  ,
  output logic [8:0] to_mem_waddr__msg  ,
  input logic [0:0] to_mem_waddr__rdy  ,
  output logic [0:0] to_mem_waddr__val  ,
  output CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 to_mem_wdata__msg  ,
  input logic [0:0] to_mem_wdata__rdy  ,
  output logic [0:0] to_mem_wdata__val  
);
  localparam CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 const_zero  = { 32'd0, 1'd0, 1'd0, 1'd0 };
  localparam logic [6:0] __const__OPT_START  = 7'd0;
  localparam logic [2:0] __const__latency_at_proceed_latency  = 3'd4;
  localparam logic [2:0] __const__latency_at_comb_ff  = 3'd4;
  localparam logic [6:0] __const__OPT_DIV  = 7'd26;
  localparam logic [2:0] __const__num_inports_at_comb_logic  = 3'd4;
  localparam logic [1:0] __const__num_outports_at_comb_logic  = 2'd2;
  localparam logic [6:0] __const__OPT_REM  = 7'd44;
  localparam logic [2:0] __const__latency_at_comb_logic  = 3'd4;
  logic [2:0] cur_cycle;
  logic [0:0] do_div;
  logic [2:0] in0;
  logic [1:0] in0_idx;
  logic [2:0] in1;
  logic [1:0] in1_idx;
  logic [2:0] latency;
  logic [0:0] reached_vector_factor;
  logic [0:0] recv_all_val;
  logic [7:0] vector_factor_counter;
  logic [2:0] vector_factor_power;
  //-------------------------------------------------------------
  // Component div
  //-------------------------------------------------------------

  logic [0:0] div_clk;
  logic [31:0] div_dividend;
  logic [31:0] div_divisor;
  logic [31:0] div_quotient;
  logic [31:0] div_remainder;
  logic [0:0] div_reset;

  Div__WIDTH_32__CYCLE_4 div
  (
    .clk( div_clk ),
    .dividend( div_dividend ),
    .divisor( div_divisor ),
    .quotient( div_quotient ),
    .remainder( div_remainder ),
    .reset( div_reset )
  );

  //-------------------------------------------------------------
  // End of component div
  //-------------------------------------------------------------

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/fu/single/ExclusiveDivRTL.py:59
  // @update
  // def comb_logic():
  // 
  //   s.recv_all_val @= 0
  //   # For pick input register
  //   s.in0 @= 0
  //   s.in1 @= 0
  //   for i in range(num_inports):
  //     s.recv_in[i].rdy @= b1(0)
  //   for i in range(num_outports):
  //     s.send_out[i].val @= 0
  //     s.send_out[i].msg @= s.DataType()
  // 
  //   s.recv_const.rdy @= 0
  //   s.recv_opt.rdy @= 0
  // 
  //   s.send_to_ctrl_mem.val @= 0
  //   s.send_to_ctrl_mem.msg @= s.CgraPayloadType(0, 0, 0, 0, 0)
  //   s.recv_from_ctrl_mem.rdy @= 0
  // 
  //   if s.recv_opt.val:
  //     if s.recv_opt.msg.fu_in[0] != 0:
  //       s.in0 @= zext(s.recv_opt.msg.fu_in[0] - 1, FuInType)
  //     if s.recv_opt.msg.fu_in[1] != 0:
  //       s.in1 @= zext(s.recv_opt.msg.fu_in[1] - 1, FuInType)
  // 
  //   if s.recv_opt.val:
  //     if (s.recv_opt.msg.operation == OPT_DIV) | (s.recv_opt.msg.operation == OPT_REM):
  //       s.div.dividend @= s.recv_in[s.in0_idx].msg.payload
  //       s.div.divisor @= s.recv_in[s.in1_idx].msg.payload
  //       if s.recv_opt.msg.operation == OPT_DIV:
  //         s.send_out[0].msg.payload @= s.div.quotient
  //       else:
  //         s.send_out[0].msg.payload @= s.div.remainder
  //       s.send_out[0].msg.predicate @= s.recv_in[s.in0_idx].msg.predicate & \
  //                                      s.recv_in[s.in1_idx].msg.predicate & \
  //                                      s.reached_vector_factor
  //       s.recv_all_val @= s.recv_in[s.in0_idx].val & s.recv_in[s.in1_idx].val
  //       s.send_out[0].val @= (latency - 1 == s.cur_cycle)
  //       s.recv_in[s.in0_idx].rdy @= s.send_out[0].val & s.send_out[0].rdy
  //       s.recv_in[s.in1_idx].rdy @= s.send_out[0].val & s.send_out[0].rdy
  //       s.do_div @= 1
  //       s.recv_opt.rdy @= s.send_out[0].val & s.send_out[0].rdy
  //     else:
  //       for j in range(num_outports):
  //         s.send_out[j].val @= b1(0)
  //       s.recv_opt.rdy @= 0
  //       s.recv_in[s.in0_idx].rdy @= 0
  //       s.recv_in[s.in1_idx].rdy @= 0
  //       s.do_div @= 0
  //   else:
  //     s.do_div @= 0
  
  always_comb begin : comb_logic
    recv_all_val = 1'd0;
    in0 = 3'd0;
    in1 = 3'd0;
    for ( int unsigned i = 1'd0; i < 3'( __const__num_inports_at_comb_logic ); i += 1'd1 )
      recv_in__rdy[2'(i)] = 1'd0;
    for ( int unsigned i = 1'd0; i < 2'( __const__num_outports_at_comb_logic ); i += 1'd1 ) begin
      send_out__val[1'(i)] = 1'd0;
      send_out__msg[1'(i)] = { 32'd0, 1'd0, 1'd0, 1'd0 };
    end
    recv_const__rdy = 1'd0;
    recv_opt__rdy = 1'd0;
    send_to_ctrl_mem__val = 1'd0;
    send_to_ctrl_mem__msg = { 5'd0, 35'd0, 9'd0, 139'd0, 3'd0 };
    recv_from_ctrl_mem__rdy = 1'd0;
    if ( recv_opt__val ) begin
      if ( recv_opt__msg.fu_in[2'd0] != 3'd0 ) begin
        in0 = recv_opt__msg.fu_in[2'd0] - 3'd1;
      end
      if ( recv_opt__msg.fu_in[2'd1] != 3'd0 ) begin
        in1 = recv_opt__msg.fu_in[2'd1] - 3'd1;
      end
    end
    if ( recv_opt__val ) begin
      if ( ( recv_opt__msg.operation == 7'( __const__OPT_DIV ) ) | ( recv_opt__msg.operation == 7'( __const__OPT_REM ) ) ) begin
        div_dividend = recv_in__msg[in0_idx].payload;
        div_divisor = recv_in__msg[in1_idx].payload;
        if ( recv_opt__msg.operation == 7'( __const__OPT_DIV ) ) begin
          send_out__msg[1'd0].payload = div_quotient;
        end
        else
          send_out__msg[1'd0].payload = div_remainder;
        send_out__msg[1'd0].predicate = ( recv_in__msg[in0_idx].predicate & recv_in__msg[in1_idx].predicate ) & reached_vector_factor;
        recv_all_val = recv_in__val[in0_idx] & recv_in__val[in1_idx];
        send_out__val[1'd0] = ( 3'( __const__latency_at_comb_logic ) - 3'd1 ) == cur_cycle;
        recv_in__rdy[in0_idx] = send_out__val[1'd0] & send_out__rdy[1'd0];
        recv_in__rdy[in1_idx] = send_out__val[1'd0] & send_out__rdy[1'd0];
        do_div = 1'd1;
        recv_opt__rdy = send_out__val[1'd0] & send_out__rdy[1'd0];
      end
      else begin
        for ( int unsigned j = 1'd0; j < 2'( __const__num_outports_at_comb_logic ); j += 1'd1 )
          send_out__val[1'(j)] = 1'd0;
        recv_opt__rdy = 1'd0;
        recv_in__rdy[in0_idx] = 1'd0;
        recv_in__rdy[in1_idx] = 1'd0;
        do_div = 1'd0;
      end
    end
    else
      do_div = 1'd0;
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/fu/basic/Fu.py:68
  // @update
  // def update_mem():
  //   s.to_mem_waddr.val @= b1(0)
  //   s.to_mem_wdata.val @= b1(0)
  //   s.to_mem_wdata.msg @= s.const_zero
  //   s.to_mem_waddr.msg @= s.DataAddrType(0)
  //   s.to_mem_raddr.msg @= s.DataAddrType(0)
  //   s.to_mem_raddr.val @= b1(0)
  //   s.from_mem_rdata.rdy @= b1(0)
  
  always_comb begin : update_mem
    to_mem_waddr__val = 1'd0;
    to_mem_wdata__val = 1'd0;
    to_mem_wdata__msg = const_zero;
    to_mem_waddr__msg = 9'd0;
    to_mem_raddr__msg = 9'd0;
    to_mem_raddr__val = 1'd0;
    from_mem_rdata__rdy = 1'd0;
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/fu/basic/Fu.py:87
  // @update
  // def update_reached_vector_factor():
  //   s.reached_vector_factor @= 0
  //   if s.recv_opt.val & (s.vector_factor_counter + \
  //                        (VectorFactorType(1) << zext(s.vector_factor_power, VectorFactorType)) >= \
  //                        (VectorFactorType(1) << zext(s.recv_opt.msg.vector_factor_power, VectorFactorType))):
  //     s.reached_vector_factor @= 1
  
  always_comb begin : update_reached_vector_factor
    reached_vector_factor = 1'd0;
    if ( recv_opt__val & ( ( vector_factor_counter + ( 8'd1 << { { 5 { 1'b0 } }, vector_factor_power } ) ) >= ( 8'd1 << { { 5 { 1'b0 } }, recv_opt__msg.vector_factor_power } ) ) ) begin
      reached_vector_factor = 1'd1;
    end
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/fu/single/ExclusiveDivRTL.py:46
  // @update_ff
  // def comb_ff():
  //   if (s.cur_cycle == latency - 1) & s.send_out[0].rdy:
  //       s.cur_cycle <<= 0
  //   elif s.cur_cycle == latency - 1:
  //     s.cur_cycle <<= s.cur_cycle
  //   elif s.do_div:
  //     s.cur_cycle <<= s.cur_cycle + 1
  //   elif (s.recv_all_val & (s.recv_opt.msg.operation == OPT_DIV)):
  //     s.cur_cycle <<= 1
  //   else:
  //     s.cur_cycle <<= 0
  
  always_ff @(posedge clk) begin : comb_ff
    if ( ( cur_cycle == ( 3'( __const__latency_at_comb_ff ) - 3'd1 ) ) & send_out__rdy[1'd0] ) begin
      cur_cycle <= 3'd0;
    end
    else if ( cur_cycle == ( 3'( __const__latency_at_comb_ff ) - 3'd1 ) ) begin
      cur_cycle <= cur_cycle;
    end
    else if ( do_div ) begin
      cur_cycle <= cur_cycle + 3'd1;
    end
    else if ( recv_all_val & ( recv_opt__msg.operation == 7'( __const__OPT_DIV ) ) ) begin
      cur_cycle <= 3'd1;
    end
    else
      cur_cycle <= 3'd0;
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/fu/basic/Fu.py:78
  // @update_ff
  // def proceed_latency():
  //   if s.recv_opt.msg.operation == OPT_START:
  //     s.latency <<= LatencyType(0)
  //   elif s.latency == latency - 1:
  //     s.latency <<= LatencyType(0)
  //   else:
  //     s.latency <<= s.latency + LatencyType(1)
  
  always_ff @(posedge clk) begin : proceed_latency
    if ( recv_opt__msg.operation == 7'( __const__OPT_START ) ) begin
      latency <= 3'd0;
    end
    else if ( latency == ( 3'( __const__latency_at_proceed_latency ) - 3'd1 ) ) begin
      latency <= 3'd0;
    end
    else
      latency <= latency + 3'd1;
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/fu/basic/Fu.py:95
  // @update_ff
  // def update_vector_factor_counter():
  //   if s.reset:
  //     s.vector_factor_counter <<= 0
  //   else:
  //     if s.recv_opt.val:
  //       if s.recv_opt.msg.is_last_ctrl & \
  //          (s.vector_factor_counter + \
  //           (VectorFactorType(1) << zext(s.vector_factor_power, VectorFactorType)) < \
  //           (VectorFactorType(1) << zext(s.recv_opt.msg.vector_factor_power, VectorFactorType))):
  //         s.vector_factor_counter <<= s.vector_factor_counter + \
  //                                     (VectorFactorType(1) << zext(s.vector_factor_power, \
  //                                                                  VectorFactorType))
  //       elif s.recv_opt.msg.is_last_ctrl & s.reached_vector_factor:
  //         s.vector_factor_counter <<= 0
  
  always_ff @(posedge clk) begin : update_vector_factor_counter
    if ( reset ) begin
      vector_factor_counter <= 8'd0;
    end
    else if ( recv_opt__val ) begin
      if ( recv_opt__msg.is_last_ctrl & ( ( vector_factor_counter + ( 8'd1 << { { 5 { 1'b0 } }, vector_factor_power } ) ) < ( 8'd1 << { { 5 { 1'b0 } }, recv_opt__msg.vector_factor_power } ) ) ) begin
        vector_factor_counter <= vector_factor_counter + ( 8'd1 << { { 5 { 1'b0 } }, vector_factor_power } );
      end
      else if ( recv_opt__msg.is_last_ctrl & reached_vector_factor ) begin
        vector_factor_counter <= 8'd0;
      end
    end
  end

  assign vector_factor_power = 3'd0;
  assign div_clk = clk;
  assign div_reset = reset;
  assign in0_idx = in0[1:0];
  assign in1_idx = in1[1:0];

endmodule


// PyMTL Component AdderRTL Definition
// Full name: AdderRTL__CtrlPktType_IntraCgraPacket_4_4x1_4_8_2_CgraPayload__11cd3f8c0d91825c__num_inports_4__num_outports_2__vector_factor_power_0
// At /cgra/VectorCGRA/fu/single/AdderRTL.py

module AdderRTL__1a7eacb70e3ca1c4
(
  input  logic [0:0] clear ,
  input  logic [0:0] clk ,
  input  logic [2:0] ctrl_addr_inport ,
  input  logic [0:0] reset ,
  input CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 from_mem_rdata__msg  ,
  output logic [0:0] from_mem_rdata__rdy  ,
  input logic [0:0] from_mem_rdata__val  ,
  input CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 recv_const__msg  ,
  output logic [0:0] recv_const__rdy  ,
  input logic [0:0] recv_const__val  ,
  input MultiCgraPayload_Cmd_Data_DataAddr_Ctrl_CtrlAddr__a0427cd98cfcae6f recv_from_ctrl_mem__msg  ,
  output logic [0:0] recv_from_ctrl_mem__rdy  ,
  input logic [0:0] recv_from_ctrl_mem__val  ,
  input CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 recv_in__msg [0:3] ,
  output logic [0:0] recv_in__rdy [0:3] ,
  input logic [0:0] recv_in__val [0:3] ,
  input CGRAConfig_7_4_2_8_8_3__603a41f5d0e2436f recv_opt__msg  ,
  output logic [0:0] recv_opt__rdy  ,
  input logic [0:0] recv_opt__val  ,
  output CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 send_out__msg [0:1] ,
  input logic [0:0] send_out__rdy [0:1] ,
  output logic [0:0] send_out__val [0:1] ,
  output MultiCgraPayload_Cmd_Data_DataAddr_Ctrl_CtrlAddr__a0427cd98cfcae6f send_to_ctrl_mem__msg  ,
  input logic [0:0] send_to_ctrl_mem__rdy  ,
  output logic [0:0] send_to_ctrl_mem__val  ,
  output logic [8:0] to_mem_raddr__msg  ,
  input logic [0:0] to_mem_raddr__rdy  ,
  output logic [0:0] to_mem_raddr__val  ,
  output logic [8:0] to_mem_waddr__msg  ,
  input logic [0:0] to_mem_waddr__rdy  ,
  output logic [0:0] to_mem_waddr__val  ,
  output CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 to_mem_wdata__msg  ,
  input logic [0:0] to_mem_wdata__rdy  ,
  output logic [0:0] to_mem_wdata__val  
);
  localparam CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 const_zero  = { 32'd0, 1'd0, 1'd0, 1'd0 };
  localparam logic [6:0] __const__OPT_START  = 7'd0;
  localparam logic [0:0] __const__latency_at_proceed_latency  = 1'd1;
  localparam logic [2:0] __const__num_inports_at_comb_logic  = 3'd4;
  localparam logic [1:0] __const__num_outports_at_comb_logic  = 2'd2;
  localparam logic [6:0] __const__OPT_ADD  = 7'd2;
  localparam logic [6:0] __const__OPT_ADD_CONST  = 7'd25;
  localparam logic [6:0] __const__OPT_INC  = 7'd3;
  localparam logic [6:0] __const__OPT_SUB  = 7'd4;
  localparam logic [6:0] __const__OPT_SUB_CONST  = 7'd36;
  localparam logic [6:0] __const__OPT_PAS  = 7'd31;
  logic [2:0] in0;
  logic [1:0] in0_idx;
  logic [2:0] in1;
  logic [1:0] in1_idx;
  logic [0:0] latency;
  logic [0:0] reached_vector_factor;
  logic [0:0] recv_all_val;
  logic [7:0] vector_factor_counter;
  logic [2:0] vector_factor_power;

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/fu/single/AdderRTL.py:38
  // @update
  // def comb_logic():
  // 
  //   s.recv_all_val @= 0
  //   s.in0 @= 0
  //   s.in1 @= 0
  //   # For pick input register
  //   for i in range(num_inports):
  //     s.recv_in[i].rdy @= b1(0)
  //   for i in range(num_outports):
  //     s.send_out[i].val @= 0
  //     s.send_out[i].msg @= s.DataType()
  // 
  //   s.recv_const.rdy @= 0
  //   s.recv_opt.rdy @= 0
  // 
  //   s.send_to_ctrl_mem.val @= 0
  //   s.send_to_ctrl_mem.msg @= s.CgraPayloadType(0, 0, 0, 0, 0)
  //   s.recv_from_ctrl_mem.rdy @= 0
  // 
  //   # Though different operations might not need to consume
  //   # all the operands, as long as the opcode indicating it
  //   # is an operand, the data would disappear from the register.
  //   if s.recv_opt.val:
  //     if s.recv_opt.msg.fu_in[0] != 0:
  //       s.in0 @= zext(s.recv_opt.msg.fu_in[0] - 1, FuInType)
  //     if s.recv_opt.msg.fu_in[1] != 0:
  //       s.in1 @= zext(s.recv_opt.msg.fu_in[1] - 1, FuInType)
  // 
  //   if s.recv_opt.val:
  //     if s.recv_opt.msg.operation == OPT_ADD:
  //       s.send_out[0].msg.payload @= s.recv_in[s.in0_idx].msg.payload + s.recv_in[s.in1_idx].msg.payload
  //       s.send_out[0].msg.predicate @= s.recv_in[s.in0_idx].msg.predicate & \
  //                                      s.recv_in[s.in1_idx].msg.predicate & \
  //                                      s.reached_vector_factor
  //       s.recv_all_val @= s.recv_in[s.in0_idx].val & s.recv_in[s.in1_idx].val
  //       s.send_out[0].val @= s.recv_all_val
  //       s.recv_in[s.in0_idx].rdy @= s.recv_all_val & s.send_out[0].rdy
  //       s.recv_in[s.in1_idx].rdy @= s.recv_all_val & s.send_out[0].rdy
  //       s.recv_opt.rdy @= s.recv_all_val & s.send_out[0].rdy
  // 
  //     elif s.recv_opt.msg.operation == OPT_ADD_CONST:
  //       s.send_out[0].msg.payload @= s.recv_in[s.in0_idx].msg.payload + s.recv_const.msg.payload
  //       s.send_out[0].msg.predicate @= s.recv_in[s.in0_idx].msg.predicate & \
  //                                      s.recv_const.msg.predicate & \
  //                                      s.reached_vector_factor
  //       s.recv_const.rdy @= s.send_out[0].rdy
  //       s.recv_all_val @= s.recv_in[s.in0_idx].val & s.recv_const.val
  //       s.send_out[0].val @= s.recv_all_val
  //       s.recv_in[s.in0_idx].rdy @= s.recv_all_val & s.send_out[0].rdy
  //       s.recv_const.rdy @= s.recv_all_val & s.send_out[0].rdy
  //       s.recv_opt.rdy @= s.recv_all_val & s.send_out[0].rdy
  // 
  //     elif s.recv_opt.msg.operation == OPT_INC:
  //       s.send_out[0].msg.payload @= s.recv_in[s.in0_idx].msg.payload + s.const_one.payload
  //       s.send_out[0].msg.predicate @= s.recv_in[s.in0_idx].msg.predicate & \
  //                                      s.reached_vector_factor
  //       s.recv_all_val @= s.recv_in[s.in0_idx].val
  //       s.send_out[0].val @= s.recv_all_val
  //       s.recv_in[s.in0_idx].rdy @= s.recv_all_val & s.send_out[0].rdy
  //       s.recv_opt.rdy @= s.recv_all_val & s.send_out[0].rdy
  // 
  //     elif s.recv_opt.msg.operation == OPT_SUB:
  //       s.send_out[0].msg.payload @= s.recv_in[s.in0_idx].msg.payload - s.recv_in[s.in1_idx].msg.payload
  //       s.send_out[0].msg.predicate @= s.recv_in[s.in0_idx].msg.predicate & \
  //                                      s.recv_in[s.in1_idx].msg.predicate & \
  //                                      s.reached_vector_factor
  //       s.recv_all_val @= s.recv_in[s.in0_idx].val & s.recv_in[s.in1_idx].val
  //       s.send_out[0].val @= s.recv_all_val
  //       s.recv_in[s.in0_idx].rdy @= s.recv_all_val & s.send_out[0].rdy
  //       s.recv_in[s.in1_idx].rdy @= s.recv_all_val & s.send_out[0].rdy
  //       s.recv_opt.rdy @= s.recv_all_val & s.send_out[0].rdy
  // 
  //     elif s.recv_opt.msg.operation == OPT_SUB_CONST:
  //       s.send_out[0].msg.payload @= s.recv_in[s.in0_idx].msg.payload - s.recv_const.msg.payload
  //       s.send_out[0].msg.predicate @= s.recv_in[s.in0_idx].msg.predicate & \
  //                                      s.recv_const.msg.predicate & \
  //                                      s.reached_vector_factor
  //       s.recv_all_val @= s.recv_in[s.in0_idx].val & s.recv_const.val
  //       s.send_out[0].val @= s.recv_all_val
  //       s.recv_in[s.in0_idx].rdy @= s.recv_all_val & s.send_out[0].rdy
  //       s.recv_in[s.in1_idx].rdy @= s.recv_all_val & s.send_out[0].rdy
  //       s.recv_opt.rdy @= s.recv_all_val & s.send_out[0].rdy
  // 
  //     elif s.recv_opt.msg.operation == OPT_PAS:
  //       s.send_out[0].msg.payload @= s.recv_in[s.in0_idx].msg.payload
  //       s.send_out[0].msg.predicate @= s.recv_in[s.in0_idx].msg.predicate & \
  //                                      s.reached_vector_factor
  //       s.recv_all_val @= s.recv_in[s.in0_idx].val
  //       s.send_out[0].val @= s.recv_all_val
  //       s.recv_in[s.in0_idx].rdy @= s.recv_all_val & s.send_out[0].rdy
  //       s.recv_opt.rdy @= s.recv_all_val & s.send_out[0].rdy
  // 
  //     else:
  //       for j in range(num_outports):
  //         s.send_out[j].val @= b1(0)
  //       s.recv_opt.rdy @= 0
  //       s.recv_in[s.in0_idx].rdy @= 0
  //       s.recv_in[s.in1_idx].rdy @= 0
  
  always_comb begin : comb_logic
    recv_all_val = 1'd0;
    in0 = 3'd0;
    in1 = 3'd0;
    for ( int unsigned i = 1'd0; i < 3'( __const__num_inports_at_comb_logic ); i += 1'd1 )
      recv_in__rdy[2'(i)] = 1'd0;
    for ( int unsigned i = 1'd0; i < 2'( __const__num_outports_at_comb_logic ); i += 1'd1 ) begin
      send_out__val[1'(i)] = 1'd0;
      send_out__msg[1'(i)] = { 32'd0, 1'd0, 1'd0, 1'd0 };
    end
    recv_const__rdy = 1'd0;
    recv_opt__rdy = 1'd0;
    send_to_ctrl_mem__val = 1'd0;
    send_to_ctrl_mem__msg = { 5'd0, 35'd0, 9'd0, 139'd0, 3'd0 };
    recv_from_ctrl_mem__rdy = 1'd0;
    if ( recv_opt__val ) begin
      if ( recv_opt__msg.fu_in[2'd0] != 3'd0 ) begin
        in0 = recv_opt__msg.fu_in[2'd0] - 3'd1;
      end
      if ( recv_opt__msg.fu_in[2'd1] != 3'd0 ) begin
        in1 = recv_opt__msg.fu_in[2'd1] - 3'd1;
      end
    end
    if ( recv_opt__val ) begin
      if ( recv_opt__msg.operation == 7'( __const__OPT_ADD ) ) begin
        send_out__msg[1'd0].payload = recv_in__msg[in0_idx].payload + recv_in__msg[in1_idx].payload;
        send_out__msg[1'd0].predicate = ( recv_in__msg[in0_idx].predicate & recv_in__msg[in1_idx].predicate ) & reached_vector_factor;
        recv_all_val = recv_in__val[in0_idx] & recv_in__val[in1_idx];
        send_out__val[1'd0] = recv_all_val;
        recv_in__rdy[in0_idx] = recv_all_val & send_out__rdy[1'd0];
        recv_in__rdy[in1_idx] = recv_all_val & send_out__rdy[1'd0];
        recv_opt__rdy = recv_all_val & send_out__rdy[1'd0];
      end
      else if ( recv_opt__msg.operation == 7'( __const__OPT_ADD_CONST ) ) begin
        send_out__msg[1'd0].payload = recv_in__msg[in0_idx].payload + recv_const__msg.payload;
        send_out__msg[1'd0].predicate = ( recv_in__msg[in0_idx].predicate & recv_const__msg.predicate ) & reached_vector_factor;
        recv_const__rdy = send_out__rdy[1'd0];
        recv_all_val = recv_in__val[in0_idx] & recv_const__val;
        send_out__val[1'd0] = recv_all_val;
        recv_in__rdy[in0_idx] = recv_all_val & send_out__rdy[1'd0];
        recv_const__rdy = recv_all_val & send_out__rdy[1'd0];
        recv_opt__rdy = recv_all_val & send_out__rdy[1'd0];
      end
      else if ( recv_opt__msg.operation == 7'( __const__OPT_INC ) ) begin
        send_out__msg[1'd0].payload = recv_in__msg[in0_idx].payload + 32'd1;
        send_out__msg[1'd0].predicate = recv_in__msg[in0_idx].predicate & reached_vector_factor;
        recv_all_val = recv_in__val[in0_idx];
        send_out__val[1'd0] = recv_all_val;
        recv_in__rdy[in0_idx] = recv_all_val & send_out__rdy[1'd0];
        recv_opt__rdy = recv_all_val & send_out__rdy[1'd0];
      end
      else if ( recv_opt__msg.operation == 7'( __const__OPT_SUB ) ) begin
        send_out__msg[1'd0].payload = recv_in__msg[in0_idx].payload - recv_in__msg[in1_idx].payload;
        send_out__msg[1'd0].predicate = ( recv_in__msg[in0_idx].predicate & recv_in__msg[in1_idx].predicate ) & reached_vector_factor;
        recv_all_val = recv_in__val[in0_idx] & recv_in__val[in1_idx];
        send_out__val[1'd0] = recv_all_val;
        recv_in__rdy[in0_idx] = recv_all_val & send_out__rdy[1'd0];
        recv_in__rdy[in1_idx] = recv_all_val & send_out__rdy[1'd0];
        recv_opt__rdy = recv_all_val & send_out__rdy[1'd0];
      end
      else if ( recv_opt__msg.operation == 7'( __const__OPT_SUB_CONST ) ) begin
        send_out__msg[1'd0].payload = recv_in__msg[in0_idx].payload - recv_const__msg.payload;
        send_out__msg[1'd0].predicate = ( recv_in__msg[in0_idx].predicate & recv_const__msg.predicate ) & reached_vector_factor;
        recv_all_val = recv_in__val[in0_idx] & recv_const__val;
        send_out__val[1'd0] = recv_all_val;
        recv_in__rdy[in0_idx] = recv_all_val & send_out__rdy[1'd0];
        recv_in__rdy[in1_idx] = recv_all_val & send_out__rdy[1'd0];
        recv_opt__rdy = recv_all_val & send_out__rdy[1'd0];
      end
      else if ( recv_opt__msg.operation == 7'( __const__OPT_PAS ) ) begin
        send_out__msg[1'd0].payload = recv_in__msg[in0_idx].payload;
        send_out__msg[1'd0].predicate = recv_in__msg[in0_idx].predicate & reached_vector_factor;
        recv_all_val = recv_in__val[in0_idx];
        send_out__val[1'd0] = recv_all_val;
        recv_in__rdy[in0_idx] = recv_all_val & send_out__rdy[1'd0];
        recv_opt__rdy = recv_all_val & send_out__rdy[1'd0];
      end
      else begin
        for ( int unsigned j = 1'd0; j < 2'( __const__num_outports_at_comb_logic ); j += 1'd1 )
          send_out__val[1'(j)] = 1'd0;
        recv_opt__rdy = 1'd0;
        recv_in__rdy[in0_idx] = 1'd0;
        recv_in__rdy[in1_idx] = 1'd0;
      end
    end
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/fu/basic/Fu.py:68
  // @update
  // def update_mem():
  //   s.to_mem_waddr.val @= b1(0)
  //   s.to_mem_wdata.val @= b1(0)
  //   s.to_mem_wdata.msg @= s.const_zero
  //   s.to_mem_waddr.msg @= s.DataAddrType(0)
  //   s.to_mem_raddr.msg @= s.DataAddrType(0)
  //   s.to_mem_raddr.val @= b1(0)
  //   s.from_mem_rdata.rdy @= b1(0)
  
  always_comb begin : update_mem
    to_mem_waddr__val = 1'd0;
    to_mem_wdata__val = 1'd0;
    to_mem_wdata__msg = const_zero;
    to_mem_waddr__msg = 9'd0;
    to_mem_raddr__msg = 9'd0;
    to_mem_raddr__val = 1'd0;
    from_mem_rdata__rdy = 1'd0;
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/fu/basic/Fu.py:87
  // @update
  // def update_reached_vector_factor():
  //   s.reached_vector_factor @= 0
  //   if s.recv_opt.val & (s.vector_factor_counter + \
  //                        (VectorFactorType(1) << zext(s.vector_factor_power, VectorFactorType)) >= \
  //                        (VectorFactorType(1) << zext(s.recv_opt.msg.vector_factor_power, VectorFactorType))):
  //     s.reached_vector_factor @= 1
  
  always_comb begin : update_reached_vector_factor
    reached_vector_factor = 1'd0;
    if ( recv_opt__val & ( ( vector_factor_counter + ( 8'd1 << { { 5 { 1'b0 } }, vector_factor_power } ) ) >= ( 8'd1 << { { 5 { 1'b0 } }, recv_opt__msg.vector_factor_power } ) ) ) begin
      reached_vector_factor = 1'd1;
    end
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/fu/basic/Fu.py:78
  // @update_ff
  // def proceed_latency():
  //   if s.recv_opt.msg.operation == OPT_START:
  //     s.latency <<= LatencyType(0)
  //   elif s.latency == latency - 1:
  //     s.latency <<= LatencyType(0)
  //   else:
  //     s.latency <<= s.latency + LatencyType(1)
  
  always_ff @(posedge clk) begin : proceed_latency
    if ( recv_opt__msg.operation == 7'( __const__OPT_START ) ) begin
      latency <= 1'd0;
    end
    else if ( latency == ( 1'( __const__latency_at_proceed_latency ) - 1'd1 ) ) begin
      latency <= 1'd0;
    end
    else
      latency <= latency + 1'd1;
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/fu/basic/Fu.py:95
  // @update_ff
  // def update_vector_factor_counter():
  //   if s.reset:
  //     s.vector_factor_counter <<= 0
  //   else:
  //     if s.recv_opt.val:
  //       if s.recv_opt.msg.is_last_ctrl & \
  //          (s.vector_factor_counter + \
  //           (VectorFactorType(1) << zext(s.vector_factor_power, VectorFactorType)) < \
  //           (VectorFactorType(1) << zext(s.recv_opt.msg.vector_factor_power, VectorFactorType))):
  //         s.vector_factor_counter <<= s.vector_factor_counter + \
  //                                     (VectorFactorType(1) << zext(s.vector_factor_power, \
  //                                                                  VectorFactorType))
  //       elif s.recv_opt.msg.is_last_ctrl & s.reached_vector_factor:
  //         s.vector_factor_counter <<= 0
  
  always_ff @(posedge clk) begin : update_vector_factor_counter
    if ( reset ) begin
      vector_factor_counter <= 8'd0;
    end
    else if ( recv_opt__val ) begin
      if ( recv_opt__msg.is_last_ctrl & ( ( vector_factor_counter + ( 8'd1 << { { 5 { 1'b0 } }, vector_factor_power } ) ) < ( 8'd1 << { { 5 { 1'b0 } }, recv_opt__msg.vector_factor_power } ) ) ) begin
        vector_factor_counter <= vector_factor_counter + ( 8'd1 << { { 5 { 1'b0 } }, vector_factor_power } );
      end
      else if ( recv_opt__msg.is_last_ctrl & reached_vector_factor ) begin
        vector_factor_counter <= 8'd0;
      end
    end
  end

  assign vector_factor_power = 3'd0;
  assign in0_idx = in0[1:0];
  assign in1_idx = in1[1:0];

endmodule


// PyMTL Component MemUnitRTL Definition
// Full name: MemUnitRTL__CtrlPktType_IntraCgraPacket_4_4x1_4_8_2_CgraPayload__11cd3f8c0d91825c__num_inports_4__num_outports_2__vector_factor_power_0
// At /cgra/VectorCGRA/fu/single/MemUnitRTL.py

module MemUnitRTL__1a7eacb70e3ca1c4
(
  input  logic [0:0] clear ,
  input  logic [0:0] clk ,
  input  logic [2:0] ctrl_addr_inport ,
  input  logic [0:0] reset ,
  input CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 from_mem_rdata__msg  ,
  output logic [0:0] from_mem_rdata__rdy  ,
  input logic [0:0] from_mem_rdata__val  ,
  input CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 recv_const__msg  ,
  output logic [0:0] recv_const__rdy  ,
  input logic [0:0] recv_const__val  ,
  input MultiCgraPayload_Cmd_Data_DataAddr_Ctrl_CtrlAddr__a0427cd98cfcae6f recv_from_ctrl_mem__msg  ,
  output logic [0:0] recv_from_ctrl_mem__rdy  ,
  input logic [0:0] recv_from_ctrl_mem__val  ,
  input CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 recv_in__msg [0:3] ,
  output logic [0:0] recv_in__rdy [0:3] ,
  input logic [0:0] recv_in__val [0:3] ,
  input CGRAConfig_7_4_2_8_8_3__603a41f5d0e2436f recv_opt__msg  ,
  output logic [0:0] recv_opt__rdy  ,
  input logic [0:0] recv_opt__val  ,
  output CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 send_out__msg [0:1] ,
  input logic [0:0] send_out__rdy [0:1] ,
  output logic [0:0] send_out__val [0:1] ,
  output MultiCgraPayload_Cmd_Data_DataAddr_Ctrl_CtrlAddr__a0427cd98cfcae6f send_to_ctrl_mem__msg  ,
  input logic [0:0] send_to_ctrl_mem__rdy  ,
  output logic [0:0] send_to_ctrl_mem__val  ,
  output logic [8:0] to_mem_raddr__msg  ,
  input logic [0:0] to_mem_raddr__rdy  ,
  output logic [0:0] to_mem_raddr__val  ,
  output logic [8:0] to_mem_waddr__msg  ,
  input logic [0:0] to_mem_waddr__rdy  ,
  output logic [0:0] to_mem_waddr__val  ,
  output CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 to_mem_wdata__msg  ,
  input logic [0:0] to_mem_wdata__rdy  ,
  output logic [0:0] to_mem_wdata__val  
);
  localparam logic [2:0] __const__num_inports_at_comb_logic  = 3'd4;
  localparam logic [1:0] __const__num_outports_at_comb_logic  = 2'd2;
  localparam logic [6:0] __const__OPT_LD  = 7'd12;
  localparam logic [6:0] __const__OPT_ADD_CONST_LD  = 7'd81;
  localparam logic [6:0] __const__OPT_LD_CONST  = 7'd28;
  localparam logic [6:0] __const__OPT_STR  = 7'd13;
  localparam logic [6:0] __const__OPT_STR_CONST  = 7'd58;
  logic [0:0] already_sent_raddr;
  logic [2:0] in0;
  logic [1:0] in0_idx;
  logic [2:0] in1;
  logic [1:0] in1_idx;
  logic [0:0] reached_vector_factor;
  logic [0:0] recv_all_val;
  logic [3:0] recv_in_val_vector;
  logic [7:0] vector_factor_counter;
  logic [2:0] vector_factor_power;

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/fu/single/MemUnitRTL.py:80
  // @update
  // def comb_logic():
  // 
  //   s.recv_all_val @= 0
  //   # For pick input register
  //   s.in0 @= FuInType(0)
  //   s.in1 @= FuInType(0)
  //   for i in range(num_inports):
  //     s.recv_in[i].rdy @= b1(0)
  //   for i in range(num_outports):
  //     s.send_out[i].val @= 0
  //     s.send_out[i].msg @= DataType()
  // 
  //   s.recv_const.rdy @= 0
  //   s.recv_opt.rdy @= 0
  // 
  //   s.send_to_ctrl_mem.val @= 0
  //   s.send_to_ctrl_mem.msg @= s.CgraPayloadType(0, 0, 0, 0, 0)
  //   s.recv_from_ctrl_mem.rdy @= 0
  // 
  //   if s.recv_opt.val:
  //     if s.recv_opt.msg.fu_in[0] != 0:
  //       s.in0 @= zext(s.recv_opt.msg.fu_in[0] - 1, FuInType)
  //     if s.recv_opt.msg.fu_in[1] != 0:
  //       s.in1 @= zext(s.recv_opt.msg.fu_in[1] - 1, FuInType)
  // 
  //   s.to_mem_waddr.val @= 0
  //   s.to_mem_waddr.msg @= AddrType()
  //   s.to_mem_wdata.val @= 0
  //   s.to_mem_wdata.msg @= DataType()
  //   s.to_mem_raddr.val @= 0
  //   s.to_mem_raddr.msg @= AddrType()
  //   s.from_mem_rdata.rdy @= 0
  // 
  //   if s.recv_opt.val:
  //     if s.recv_opt.msg.operation == OPT_LD:
  //       s.recv_all_val @= s.recv_in[s.in0_idx].val
  //       s.recv_in[s.in0_idx].rdy @= s.recv_all_val & s.to_mem_raddr.rdy
  //       s.to_mem_raddr.msg @= AddrType(s.recv_in[s.in0_idx].msg.payload[0:AddrType.nbits])
  //       # Do not access memory by setting raddr.val=0 if the raddr has predicate=0.
  //       # Note that this only happends "once" when all the required inputs are arrived.
  //       if s.recv_all_val & (s.recv_in[s.in0_idx].msg.predicate == 0):
  //         s.to_mem_raddr.val @= 0
  //       else:
  //         s.to_mem_raddr.val @= s.recv_all_val & ~s.already_sent_raddr
  //       s.from_mem_rdata.rdy @= s.send_out[0].rdy
  //       # Although we do not access memory when raddr has predicate=0,
  //       # we still need to simulate that memory returns a fake data with predicate=0,
  //       # so that the consumer will not block due to the lack of data.
  //       # Then all initiated iterations can be normally drained.
  //       # Note that this only happends "after" all the required inputs are arrived.
  //       # Otherwise, the recv_opt's opcode would be consumed at the wrong timing.
  //       if s.recv_all_val & (s.recv_in[s.in0_idx].msg.predicate == 0):
  //         s.send_out[0].val @= s.recv_all_val
  //         s.send_out[0].msg.predicate @= 0
  //         s.recv_opt.rdy @= s.send_out[0].rdy
  //       else:
  //         s.send_out[0].val @= s.from_mem_rdata.val
  //         s.send_out[0].msg @= s.from_mem_rdata.msg
  //         # Predicate of 0 is already handled and returned with fake data. So just
  //         # use the from_mem_rdata's predicate here.
  //         s.send_out[0].msg.predicate @= s.from_mem_rdata.msg.predicate & \
  //                                        s.reached_vector_factor
  //         s.recv_opt.rdy @= s.send_out[0].rdy & s.from_mem_rdata.val
  // 
  //     # ADD_CONST_LD indicates the address is added on a const, then perform load.
  //     elif s.recv_opt.msg.operation == OPT_ADD_CONST_LD:
  //       s.recv_all_val @= s.recv_in[s.in0_idx].val & s.recv_const.val
  //       s.recv_in[s.in0_idx].rdy @= s.recv_all_val & s.to_mem_raddr.rdy
  //       # It is okay to always set recv_const.rdy=1 here, because the const queue
  //       # would only proceed once the operation is done executing.
  //       s.recv_const.rdy @= 1
  //       s.to_mem_raddr.msg @= AddrType(s.recv_in[s.in0_idx].msg.payload[0:AddrType.nbits] +
  //                                      s.recv_const.msg.payload[0:AddrType.nbits])
  //       # Do not access memory by setting raddr.val=0 if the raddr has predicate=0.
  //       # Note that this only happends "once" when all the required inputs are arrived.
  //       if s.recv_all_val & (s.recv_in[s.in0_idx].msg.predicate == 0):
  //         s.to_mem_raddr.val @= 0
  //       else:
  //         s.to_mem_raddr.val @= s.recv_all_val & ~s.already_sent_raddr
  //       s.from_mem_rdata.rdy @= s.send_out[0].rdy
  //       # Although we do not access memory when raddr has predicate=0,
  //       # we still need to simulate that memory returns a fake data with predicate=0,
  //       # so that the consumer will not block due to the lack of data.
  //       # Then all initiated iterations can be normally drained.
  //       # Note that this only happends "after" all the required inputs are arrived.
  //       # Otherwise, the recv_opt's opcode would be consumed at the wrong timing.
  //       if s.recv_all_val & (s.recv_in[s.in0_idx].msg.predicate == 0):
  //         s.send_out[0].val @= s.recv_all_val
  //         s.send_out[0].msg.predicate @= 0
  //         s.recv_opt.rdy @= s.send_out[0].rdy
  //       else:
  //         s.send_out[0].val @= s.from_mem_rdata.val
  //         s.send_out[0].msg @= s.from_mem_rdata.msg
  //         # Predicate of 0 is already handled and returned with fake data. So just
  //         # use the from_mem_rdata's predicate here.
  //         s.send_out[0].msg.predicate @= s.from_mem_rdata.msg.predicate & \
  //                                        s.reached_vector_factor
  //         s.recv_opt.rdy @= s.send_out[0].rdy & s.from_mem_rdata.val
  // 
  //     # LD_CONST indicates the address is a const.
  //     elif s.recv_opt.msg.operation == OPT_LD_CONST:
  //       s.recv_all_val @= s.recv_const.val
  //       # It is okay to always set recv_const.rdy=1 here, because the const queue
  //       # would only proceed once the operation is done executing.
  //       s.recv_const.rdy @= 1
  //       s.to_mem_raddr.msg @= AddrType(s.recv_const.msg.payload[0:AddrType.nbits])
  //       s.to_mem_raddr.val @= s.recv_all_val & ~s.already_sent_raddr
  //       s.from_mem_rdata.rdy @= s.send_out[0].rdy
  //       s.send_out[0].val @= s.from_mem_rdata.val
  //       s.send_out[0].msg @= s.from_mem_rdata.msg
  //       s.send_out[0].msg.predicate @= s.recv_const.msg.predicate & \
  //                                      s.from_mem_rdata.msg.predicate & \
  //                                      s.reached_vector_factor
  //       s.recv_opt.rdy @= s.send_out[0].rdy & s.from_mem_rdata.val
  // 
  //     elif s.recv_opt.msg.operation == OPT_STR:
  //       s.recv_all_val @= s.recv_in[s.in0_idx].val & \
  //                         s.recv_in[s.in1_idx].val
  //       s.recv_in[s.in0_idx].rdy @= s.recv_all_val & s.to_mem_waddr.rdy & s.to_mem_wdata.rdy
  //       s.recv_in[s.in1_idx].rdy @= s.recv_all_val & s.to_mem_waddr.rdy & s.to_mem_wdata.rdy
  //       s.to_mem_waddr.msg @= AddrType(s.recv_in[s.in0_idx].msg.payload[0:AddrType.nbits])
  //       s.to_mem_waddr.val @= s.recv_all_val
  //       s.to_mem_wdata.msg @= s.recv_in[s.in1_idx].msg
  //       s.to_mem_wdata.msg.predicate @= s.recv_in[s.in0_idx].msg.predicate & \
  //                                       s.recv_in[s.in1_idx].msg.predicate & \
  //                                       s.reached_vector_factor
  //       s.to_mem_wdata.val @= s.recv_all_val
  // 
  //       # `send_out` is meaningless for store operation.
  //       s.send_out[0].val @= b1(0)
  // 
  //       s.recv_opt.rdy @= s.recv_all_val & s.to_mem_waddr.rdy & s.to_mem_wdata.rdy
  // 
  //     # STR_CONST indicates the address is a const.
  //     elif s.recv_opt.msg.operation == OPT_STR_CONST:
  //       s.recv_all_val @= s.recv_in[s.in0_idx].val & s.recv_const.val
  //       s.recv_const.rdy @= s.recv_all_val & s.to_mem_waddr.rdy & s.to_mem_wdata.rdy
  //       # Only needs one input register to indicate the storing data.
  //       s.recv_in[s.in0_idx].rdy @= s.recv_all_val & s.to_mem_waddr.rdy & s.to_mem_wdata.rdy
  //       s.to_mem_waddr.msg @= AddrType(s.recv_const.msg.payload[0:AddrType.nbits])
  //       s.to_mem_waddr.val @= s.recv_all_val & \
  //                             s.recv_in[s.in0_idx].msg.predicate & \
  //                             s.recv_const.msg.predicate
  //       s.to_mem_wdata.msg @= s.recv_in[s.in0_idx].msg
  //       s.to_mem_wdata.msg.predicate @= s.recv_in[s.in0_idx].msg.predicate & \
  //                                       s.recv_const.msg.predicate & \
  //                                       s.reached_vector_factor
  //       s.to_mem_wdata.val @= s.recv_all_val & \
  //                             s.recv_in[s.in0_idx].msg.predicate & \
  //                             s.recv_const.msg.predicate
  // 
  //       # `send_out` is meaningless for store operation.
  //       s.send_out[0].val @= b1(0)
  // 
  //       s.recv_opt.rdy @= s.recv_all_val & s.to_mem_waddr.rdy & s.to_mem_wdata.rdy
  // 
  //     else:
  //       for j in range(num_outports):
  //         s.send_out[j].val @= b1(0)
  //       s.recv_opt.rdy @= 0
  //       s.recv_in[s.in0_idx].rdy @= 0
  //       s.recv_in[s.in1_idx].rdy @= 0
  
  always_comb begin : comb_logic
    recv_all_val = 1'd0;
    in0 = 3'd0;
    in1 = 3'd0;
    for ( int unsigned i = 1'd0; i < 3'( __const__num_inports_at_comb_logic ); i += 1'd1 )
      recv_in__rdy[2'(i)] = 1'd0;
    for ( int unsigned i = 1'd0; i < 2'( __const__num_outports_at_comb_logic ); i += 1'd1 ) begin
      send_out__val[1'(i)] = 1'd0;
      send_out__msg[1'(i)] = { 32'd0, 1'd0, 1'd0, 1'd0 };
    end
    recv_const__rdy = 1'd0;
    recv_opt__rdy = 1'd0;
    send_to_ctrl_mem__val = 1'd0;
    send_to_ctrl_mem__msg = { 5'd0, 35'd0, 9'd0, 139'd0, 3'd0 };
    recv_from_ctrl_mem__rdy = 1'd0;
    if ( recv_opt__val ) begin
      if ( recv_opt__msg.fu_in[2'd0] != 3'd0 ) begin
        in0 = recv_opt__msg.fu_in[2'd0] - 3'd1;
      end
      if ( recv_opt__msg.fu_in[2'd1] != 3'd0 ) begin
        in1 = recv_opt__msg.fu_in[2'd1] - 3'd1;
      end
    end
    to_mem_waddr__val = 1'd0;
    to_mem_waddr__msg = 9'd0;
    to_mem_wdata__val = 1'd0;
    to_mem_wdata__msg = { 32'd0, 1'd0, 1'd0, 1'd0 };
    to_mem_raddr__val = 1'd0;
    to_mem_raddr__msg = 9'd0;
    from_mem_rdata__rdy = 1'd0;
    if ( recv_opt__val ) begin
      if ( recv_opt__msg.operation == 7'( __const__OPT_LD ) ) begin
        recv_all_val = recv_in__val[in0_idx];
        recv_in__rdy[in0_idx] = recv_all_val & to_mem_raddr__rdy;
        to_mem_raddr__msg = 9'( recv_in__msg[in0_idx].payload[5'd8:5'd0] );
        if ( recv_all_val & ( recv_in__msg[in0_idx].predicate == 1'd0 ) ) begin
          to_mem_raddr__val = 1'd0;
        end
        else
          to_mem_raddr__val = recv_all_val & ( ~already_sent_raddr );
        from_mem_rdata__rdy = send_out__rdy[1'd0];
        if ( recv_all_val & ( recv_in__msg[in0_idx].predicate == 1'd0 ) ) begin
          send_out__val[1'd0] = recv_all_val;
          send_out__msg[1'd0].predicate = 1'd0;
          recv_opt__rdy = send_out__rdy[1'd0];
        end
        else begin
          send_out__val[1'd0] = from_mem_rdata__val;
          send_out__msg[1'd0] = from_mem_rdata__msg;
          send_out__msg[1'd0].predicate = from_mem_rdata__msg.predicate & reached_vector_factor;
          recv_opt__rdy = send_out__rdy[1'd0] & from_mem_rdata__val;
        end
      end
      else if ( recv_opt__msg.operation == 7'( __const__OPT_ADD_CONST_LD ) ) begin
        recv_all_val = recv_in__val[in0_idx] & recv_const__val;
        recv_in__rdy[in0_idx] = recv_all_val & to_mem_raddr__rdy;
        recv_const__rdy = 1'd1;
        to_mem_raddr__msg = 9'( recv_in__msg[in0_idx].payload[5'd8:5'd0] + recv_const__msg.payload[5'd8:5'd0] );
        if ( recv_all_val & ( recv_in__msg[in0_idx].predicate == 1'd0 ) ) begin
          to_mem_raddr__val = 1'd0;
        end
        else
          to_mem_raddr__val = recv_all_val & ( ~already_sent_raddr );
        from_mem_rdata__rdy = send_out__rdy[1'd0];
        if ( recv_all_val & ( recv_in__msg[in0_idx].predicate == 1'd0 ) ) begin
          send_out__val[1'd0] = recv_all_val;
          send_out__msg[1'd0].predicate = 1'd0;
          recv_opt__rdy = send_out__rdy[1'd0];
        end
        else begin
          send_out__val[1'd0] = from_mem_rdata__val;
          send_out__msg[1'd0] = from_mem_rdata__msg;
          send_out__msg[1'd0].predicate = from_mem_rdata__msg.predicate & reached_vector_factor;
          recv_opt__rdy = send_out__rdy[1'd0] & from_mem_rdata__val;
        end
      end
      else if ( recv_opt__msg.operation == 7'( __const__OPT_LD_CONST ) ) begin
        recv_all_val = recv_const__val;
        recv_const__rdy = 1'd1;
        to_mem_raddr__msg = 9'( recv_const__msg.payload[5'd8:5'd0] );
        to_mem_raddr__val = recv_all_val & ( ~already_sent_raddr );
        from_mem_rdata__rdy = send_out__rdy[1'd0];
        send_out__val[1'd0] = from_mem_rdata__val;
        send_out__msg[1'd0] = from_mem_rdata__msg;
        send_out__msg[1'd0].predicate = ( recv_const__msg.predicate & from_mem_rdata__msg.predicate ) & reached_vector_factor;
        recv_opt__rdy = send_out__rdy[1'd0] & from_mem_rdata__val;
      end
      else if ( recv_opt__msg.operation == 7'( __const__OPT_STR ) ) begin
        recv_all_val = recv_in__val[in0_idx] & recv_in__val[in1_idx];
        recv_in__rdy[in0_idx] = ( recv_all_val & to_mem_waddr__rdy ) & to_mem_wdata__rdy;
        recv_in__rdy[in1_idx] = ( recv_all_val & to_mem_waddr__rdy ) & to_mem_wdata__rdy;
        to_mem_waddr__msg = 9'( recv_in__msg[in0_idx].payload[5'd8:5'd0] );
        to_mem_waddr__val = recv_all_val;
        to_mem_wdata__msg = recv_in__msg[in1_idx];
        to_mem_wdata__msg.predicate = ( recv_in__msg[in0_idx].predicate & recv_in__msg[in1_idx].predicate ) & reached_vector_factor;
        to_mem_wdata__val = recv_all_val;
        send_out__val[1'd0] = 1'd0;
        recv_opt__rdy = ( recv_all_val & to_mem_waddr__rdy ) & to_mem_wdata__rdy;
      end
      else if ( recv_opt__msg.operation == 7'( __const__OPT_STR_CONST ) ) begin
        recv_all_val = recv_in__val[in0_idx] & recv_const__val;
        recv_const__rdy = ( recv_all_val & to_mem_waddr__rdy ) & to_mem_wdata__rdy;
        recv_in__rdy[in0_idx] = ( recv_all_val & to_mem_waddr__rdy ) & to_mem_wdata__rdy;
        to_mem_waddr__msg = 9'( recv_const__msg.payload[5'd8:5'd0] );
        to_mem_waddr__val = ( recv_all_val & recv_in__msg[in0_idx].predicate ) & recv_const__msg.predicate;
        to_mem_wdata__msg = recv_in__msg[in0_idx];
        to_mem_wdata__msg.predicate = ( recv_in__msg[in0_idx].predicate & recv_const__msg.predicate ) & reached_vector_factor;
        to_mem_wdata__val = ( recv_all_val & recv_in__msg[in0_idx].predicate ) & recv_const__msg.predicate;
        send_out__val[1'd0] = 1'd0;
        recv_opt__rdy = ( recv_all_val & to_mem_waddr__rdy ) & to_mem_wdata__rdy;
      end
      else begin
        for ( int unsigned j = 1'd0; j < 2'( __const__num_outports_at_comb_logic ); j += 1'd1 )
          send_out__val[1'(j)] = 1'd0;
        recv_opt__rdy = 1'd0;
        recv_in__rdy[in0_idx] = 1'd0;
        recv_in__rdy[in1_idx] = 1'd0;
      end
    end
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/fu/single/MemUnitRTL.py:244
  // @update
  // def update_reached_vector_factor():
  //   s.reached_vector_factor @= 0
  //   if s.recv_opt.val & (s.vector_factor_counter + \
  //                        (VectorFactorType(1) << zext(s.vector_factor_power, VectorFactorType)) >= \
  //                        (VectorFactorType(1) << zext(s.recv_opt.msg.vector_factor_power, VectorFactorType))):
  //     s.reached_vector_factor @= 1
  
  always_comb begin : update_reached_vector_factor
    reached_vector_factor = 1'd0;
    if ( recv_opt__val & ( ( vector_factor_counter + ( 8'd1 << { { 5 { 1'b0 } }, vector_factor_power } ) ) >= ( 8'd1 << { { 5 { 1'b0 } }, recv_opt__msg.vector_factor_power } ) ) ) begin
      reached_vector_factor = 1'd1;
    end
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/fu/single/MemUnitRTL.py:268
  // @update_ff
  // def update_already_sent_raddr():
  //   if s.reset:
  //     s.already_sent_raddr <<= 0
  //   else:
  //     if ~s.recv_opt.val:
  //       s.already_sent_raddr <<= 0
  //     elif s.from_mem_rdata.val & s.from_mem_rdata.rdy:
  //       # Clears the flag when the data has returned (s.from_mem_rdata.val)
  //       # and successfully delivered to the destination (s.from_mem_rdata.rdy).
  //       s.already_sent_raddr <<= 0
  //     elif s.to_mem_raddr.val & \
  //          s.to_mem_raddr.rdy & \
  //          ~s.already_sent_raddr:
  //       s.already_sent_raddr <<= 1
  //     else:
  //       s.already_sent_raddr <<= s.already_sent_raddr
  
  always_ff @(posedge clk) begin : update_already_sent_raddr
    if ( reset ) begin
      already_sent_raddr <= 1'd0;
    end
    else if ( ~recv_opt__val ) begin
      already_sent_raddr <= 1'd0;
    end
    else if ( from_mem_rdata__val & from_mem_rdata__rdy ) begin
      already_sent_raddr <= 1'd0;
    end
    else if ( ( to_mem_raddr__val & to_mem_raddr__rdy ) & ( ~already_sent_raddr ) ) begin
      already_sent_raddr <= 1'd1;
    end
    else
      already_sent_raddr <= already_sent_raddr;
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/fu/single/MemUnitRTL.py:252
  // @update_ff
  // def update_vector_factor_counter():
  //   if s.reset:
  //     s.vector_factor_counter <<= 0
  //   else:
  //     if s.recv_opt.val:
  //       if s.recv_opt.msg.is_last_ctrl & \
  //          (s.vector_factor_counter + \
  //           (VectorFactorType(1) << zext(s.vector_factor_power, VectorFactorType)) < \
  //          (VectorFactorType(1) << zext(s.recv_opt.msg.vector_factor_power, VectorFactorType))):
  //         s.vector_factor_counter <<= s.vector_factor_counter + \
  //                                     (VectorFactorType(1) << zext(s.vector_factor_power, \
  //                                                                  VectorFactorType))
  //       elif s.recv_opt.msg.is_last_ctrl & s.reached_vector_factor:
  //         s.vector_factor_counter <<= 0
  
  always_ff @(posedge clk) begin : update_vector_factor_counter
    if ( reset ) begin
      vector_factor_counter <= 8'd0;
    end
    else if ( recv_opt__val ) begin
      if ( recv_opt__msg.is_last_ctrl & ( ( vector_factor_counter + ( 8'd1 << { { 5 { 1'b0 } }, vector_factor_power } ) ) < ( 8'd1 << { { 5 { 1'b0 } }, recv_opt__msg.vector_factor_power } ) ) ) begin
        vector_factor_counter <= vector_factor_counter + ( 8'd1 << { { 5 { 1'b0 } }, vector_factor_power } );
      end
      else if ( recv_opt__msg.is_last_ctrl & reached_vector_factor ) begin
        vector_factor_counter <= 8'd0;
      end
    end
  end

  assign in0_idx = in0[1:0];
  assign in1_idx = in1[1:0];
  assign vector_factor_power = 3'd0;

endmodule


// PyMTL VerilogPlaceholder MulRecFN Definition
// At /cgra/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/MulRecFNRTL.py

//***********************************************************
// Pickled source file of placeholder MulRecFN__expWidth_9__sigWidth_23
//***********************************************************

//-----------------------------------------------------------
// Dependency of placeholder MulRecFN
//-----------------------------------------------------------

`ifndef MULRECFN
`define MULRECFN

// The source code below are included because they are specified
// as the v_libs Verilog placeholder option of component MulRecFN__expWidth_9__sigWidth_23.

// If you get a duplicated def error from files included below, please
// make sure they are included either through the v_libs option or the
// explicit `include statement in the Verilog source code -- if they
// appear in both then they will be included twice!

`line 1 "/cgra/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/HardFloat_primitives.v" 0
`ifndef __HARDFLOAT_PRIMITIVES_VI__
`define __HARDFLOAT_PRIMITIVES_VI__

/*============================================================================

This Verilog source file is part of the Berkeley HardFloat IEEE Floating-Point
Arithmetic Package, Release 1, by John R. Hauser.

Copyright 2019 The Regents of the University of California.  All rights
reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
    this list of conditions, and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions, and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

 3. Neither the name of the University nor the names of its contributors may
    be used to endorse or promote products derived from this software without
    specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=============================================================================*/

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    reverse#(parameter width = 1) (
        input [(width - 1):0] in, output [(width - 1):0] out
    );

    genvar ix;
    generate
        for (ix = 0; ix < width; ix = ix + 1) begin :Bit
            assign out[ix] = in[width - 1 - ix];
        end
    endgenerate

endmodule

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    lowMaskHiLo#(
        parameter inWidth = 1,
        parameter topBound = 1,
        parameter bottomBound = 0
    ) (
        input [(inWidth - 1):0] in,
        output [(topBound - bottomBound - 1):0] out
    );

    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    localparam numInVals = 1<<inWidth;
    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    wire signed [numInVals:0] c;
    assign c[numInVals] = 1;
    assign c[(numInVals - 1):0] = 0;
    wire [(topBound - bottomBound - 1):0] reverseOut =
        (c>>>in)>>(numInVals - topBound);
    reverse#(topBound - bottomBound) reverse(reverseOut, out);

endmodule

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    lowMaskLoHi#(
        parameter inWidth = 1,
        parameter topBound = 0,
        parameter bottomBound = 1
    ) (
        input [(inWidth - 1):0] in,
        output [(bottomBound - topBound - 1):0] out
    );

    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    localparam numInVals = 1<<inWidth;
    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    wire signed [numInVals:0] c;
    assign c[numInVals] = 1;
    assign c[(numInVals - 1):0] = 0;
    wire [(bottomBound - topBound - 1):0] reverseOut =
        (c>>>~in)>>(topBound + 1);
    reverse#(bottomBound - topBound) reverse(reverseOut, out);

endmodule

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    countLeadingZeros#(parameter inWidth = 1, parameter countWidth = 1) (
        input [(inWidth - 1):0] in, output [(countWidth - 1):0] count
    );

    wire [(inWidth - 1):0] reverseIn;
    reverse#(inWidth) reverse_in(in, reverseIn);
    wire [inWidth:0] oneLeastReverseIn =
        {1'b1, reverseIn} & ({1'b0, ~reverseIn} + 1);
    genvar ix;
    generate
        for (ix = 0; ix <= inWidth; ix = ix + 1) begin :Bit
            wire [(countWidth - 1):0] countSoFar;
            if (ix == 0) begin
                assign countSoFar = 0;
            end else begin
                assign countSoFar =
                    Bit[ix - 1].countSoFar | (oneLeastReverseIn[ix] ? ix : 0);
                if (ix == inWidth) assign count = countSoFar;
            end
        end
    endgenerate

endmodule

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    compressBy2#(parameter inWidth = 1) (
        input [(inWidth - 1):0] in, output [((inWidth - 1)/2):0] out
    );

    localparam maxBitNumReduced = (inWidth - 1)/2;
    genvar ix;
    generate
        for (ix = 0; ix < maxBitNumReduced; ix = ix + 1) begin :Bit
            assign out[ix] = |in[(ix*2 + 1):ix*2];
        end
    endgenerate
    assign out[maxBitNumReduced] = |in[(inWidth - 1):maxBitNumReduced*2];

endmodule

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    compressBy4#(parameter inWidth = 1) (
        input [(inWidth - 1):0] in, output [(inWidth - 1)/4:0] out
    );

    localparam maxBitNumReduced = (inWidth - 1)/4;
    genvar ix;
    generate
        for (ix = 0; ix < maxBitNumReduced; ix = ix + 1) begin :Bit
            assign out[ix] = |in[(ix*4 + 3):ix*4];
        end
    endgenerate
    assign out[maxBitNumReduced] = |in[(inWidth - 1):maxBitNumReduced*4];

endmodule

`endif /* __HARDFLOAT_PRIMITIVES_VI__ */
`line 1 "/cgra/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/isSigNaNRecFN.v" 0
`ifndef __HARDFLOAT_ISSIGNANRECFN_V__
`define __HARDFLOAT_ISSIGNANRECFN_V__

/*============================================================================

This Verilog source file is part of the Berkeley HardFloat IEEE Floating-Point
Arithmetic Package, Release 1, by John R. Hauser.

Copyright 2019 The Regents of the University of California.  All rights
reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
    this list of conditions, and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions, and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

 3. Neither the name of the University nor the names of its contributors may
    be used to endorse or promote products derived from this software without
    specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=============================================================================*/

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    isSigNaNRecFN#(parameter expWidth = 3, parameter sigWidth = 3) (
        input [(expWidth + sigWidth):0] in, output isSigNaN
    );

    wire isNaN =
        (in[(expWidth + sigWidth - 1):(expWidth + sigWidth - 3)] == 'b111);
    assign isSigNaN = isNaN && !in[sigWidth - 2];

endmodule

`endif /* __HARDFLOAT_ISSIGNANRECFN_V__ */
`line 1 "/cgra/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/HardFloat_rawFN.v" 0
`ifndef __HARDFLOAT_RAWFN_VI__
`define __HARDFLOAT_RAWFN_VI__

/*============================================================================

This Verilog source file is part of the Berkeley HardFloat IEEE Floating-Point
Arithmetic Package, Release 1, by John R. Hauser.

Copyright 2019 The Regents of the University of California.  All rights
reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
    this list of conditions, and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions, and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

 3. Neither the name of the University nor the names of its contributors may
    be used to endorse or promote products derived from this software without
    specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=============================================================================*/

`line 1 "/cgra/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/HardFloat_consts.vi" 0
`ifndef __HARDFLOAT_CONSTS_VI__
`define __HARDFLOAT_CONSTS_VI__

/*============================================================================

This Verilog include file is part of the Berkeley HardFloat IEEE Floating-
Point Arithmetic Package, Release 1, by John R. Hauser.

Copyright 2019 The Regents of the University of California.  All rights
reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
    this list of conditions, and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions, and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

 3. Neither the name of the University nor the names of its contributors may
    be used to endorse or promote products derived from this software without
    specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=============================================================================*/

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/
`define round_near_even   3'b000
`define round_minMag      3'b001
`define round_min         3'b010
`define round_max         3'b011
`define round_near_maxMag 3'b100
`define round_odd         3'b110

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/
`define floatControlWidth 1
`define flControl_tininessBeforeRounding 1'b0
`define flControl_tininessAfterRounding  1'b1

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/
`define flRoundOpt_sigMSBitAlwaysZero  1
`define flRoundOpt_subnormsAlwaysExact 2
`define flRoundOpt_neverUnderflows     4
`define flRoundOpt_neverOverflows      8

`endif /* __HARDFLOAT_CONSTS_VI__ */

`line 40 "/cgra/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/HardFloat_rawFN.v" 0
`line 1 "/cgra/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/HardFloat_specialize.vi" 0
`ifndef __HARDFLOAT_SPECIALIZE_VI__
`define __HARDFLOAT_SPECIALIZE_VI__

/*============================================================================

This Verilog source file is part of the Berkeley HardFloat IEEE Floating-Point
Arithmetic Package, Release 1, by John R. Hauser.

Copyright 2019 The Regents of the University of California.  All rights
reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
    this list of conditions, and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions, and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

 3. Neither the name of the University nor the names of its contributors may
    be used to endorse or promote products derived from this software without
    specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=============================================================================*/

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    iNFromException#(parameter width = 1) (
        input signedOut,
        input isNaN,
        input sign,
        output [(width - 1):0] out
    );

    wire maxInt = isNaN || !sign;
    assign out = {signedOut ^ maxInt, {(width - 1){maxInt}}};

endmodule

`endif /* __HARDFLOAT_SPECIALIZE_VI__ */

`line 41 "/cgra/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/HardFloat_rawFN.v" 0

/* ===================== Adding some extra include files ================ */
`line 1 "/cgra/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/RISCV/HardFloat_specialize.vi" 0
`ifndef __RISCV_HARDFLOAT_SPECIALIZE_VI__
`define __RISCV_HARDFLOAT_SPECIALIZE_VI__

/*============================================================================

This Verilog include file is part of the Berkeley HardFloat IEEE Floating-
Point Arithmetic Package, Release 1, by John R. Hauser.

Copyright 2019 The Regents of the University of California.  All rights
reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
    this list of conditions, and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions, and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

 3. Neither the name of the University nor the names of its contributors may
    be used to endorse or promote products derived from this software without
    specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=============================================================================*/

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/
`define flControl_default `flControl_tininessAfterRounding

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/
//`define HardFloat_propagateNaNPayloads

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/
`define HardFloat_signDefaultNaN 0
`define HardFloat_fractDefaultNaN(sigWidth) {1'b1, {((sigWidth) - 2){1'b0}}}

`endif /* __RISCV_HARDFLOAT_SPECIALIZE_VI__ */

`line 44 "/cgra/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/HardFloat_rawFN.v" 0
/* ====================================================================== */

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    recFNToRawFN#(parameter expWidth = 3, parameter sigWidth = 3) (
        input [(expWidth + sigWidth):0] in,
        output isNaN,
        output isInf,
        output isZero,
        output sign,
        output signed [(expWidth + 1):0] sExp,
        output [sigWidth:0] sig
    );

    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    wire [expWidth:0] exp;
    wire [(sigWidth - 2):0] fract;
    assign {sign, exp, fract} = in;
    wire isSpecial = (exp>>(expWidth - 1) == 'b11);
    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    assign isNaN = isSpecial &&  exp[expWidth - 2];
    assign isInf = isSpecial && !exp[expWidth - 2];
    assign isZero = (exp>>(expWidth - 2) == 'b000);
    assign sExp = exp;
    assign sig = {1'b0, !isZero, fract};

endmodule

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    roundAnyRawFNToRecFN#(
        parameter inExpWidth = 3,
        parameter inSigWidth = 3,
        parameter outExpWidth = 3,
        parameter outSigWidth = 3,
        parameter options = 0
    ) (
        input [(`floatControlWidth - 1):0] control,
        input invalidExc,     // overrides 'infiniteExc' and 'in_*' inputs
        input infiniteExc,    // overrides 'in_*' inputs except 'in_sign'
        input in_isNaN,
        input in_isInf,
        input in_isZero,
        input in_sign,
        input signed [(inExpWidth + 1):0] in_sExp,   // limited range allowed
        input [inSigWidth:0] in_sig,
        input [2:0] roundingMode,
        output [(outExpWidth + outSigWidth):0] out,
        output [4:0] exceptionFlags
    );

    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    localparam sigMSBitAlwaysZero =
        ((options & `flRoundOpt_sigMSBitAlwaysZero) != 0);
    localparam effectiveInSigWidth =
        sigMSBitAlwaysZero ? inSigWidth : inSigWidth + 1;
    localparam neverUnderflows =
        ((options
              & (`flRoundOpt_neverUnderflows
                     | `flRoundOpt_subnormsAlwaysExact))
             != 0)
            || (inExpWidth < outExpWidth);
    localparam neverOverflows =
        ((options & `flRoundOpt_neverOverflows) != 0)
            || (inExpWidth < outExpWidth);
    localparam adjustedExpWidth =
          (inExpWidth < outExpWidth) ? outExpWidth + 1
        : (inExpWidth == outExpWidth) ? inExpWidth + 2
        : inExpWidth + 3;
    localparam outNaNExp = 7<<(outExpWidth - 2);
    localparam outInfExp = 6<<(outExpWidth - 2);
    localparam outMaxFiniteExp = outInfExp - 1;
    localparam outMinNormExp = (1<<(outExpWidth - 1)) + 2;
    localparam outMinNonzeroExp = outMinNormExp - outSigWidth + 1;
    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    wire roundingMode_near_even   = (roundingMode == `round_near_even);
    wire roundingMode_minMag      = (roundingMode == `round_minMag);
    wire roundingMode_min         = (roundingMode == `round_min);
    wire roundingMode_max         = (roundingMode == `round_max);
    wire roundingMode_near_maxMag = (roundingMode == `round_near_maxMag);
    wire roundingMode_odd         = (roundingMode == `round_odd);
    wire roundMagUp =
        (roundingMode_min && in_sign) || (roundingMode_max && !in_sign);
    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    wire isNaNOut = invalidExc || (!infiniteExc && in_isNaN);
`ifdef HardFloat_propagateNaNPayloads
    wire propagateNaNPayload = isNaNOut;
`else
    wire propagateNaNPayload = 0;
`endif
    wire signed [(adjustedExpWidth - 1):0] sAdjustedExp =
        in_sExp + ((1<<outExpWidth) - (1<<inExpWidth));
    wire [(outSigWidth + 2):0] adjustedSig;
    generate
        if (inSigWidth <= outSigWidth + 2) begin
            assign adjustedSig = in_sig<<(outSigWidth - inSigWidth + 2);
        end else begin
            assign adjustedSig =
                {in_sig[inSigWidth:(inSigWidth - outSigWidth - 1)],
                 |in_sig[(inSigWidth - outSigWidth - 2):0]};
        end
    endgenerate
    wire doShiftSigDown1 =
        sigMSBitAlwaysZero ? 0 : adjustedSig[outSigWidth + 2];
    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    wire [outExpWidth:0] common_expOut;
    wire [(outSigWidth - 2):0] common_fractOut;
    wire common_overflow, common_totalUnderflow, common_underflow;
    wire common_inexact;
    generate
        if (
            neverOverflows && neverUnderflows
                && (effectiveInSigWidth <= outSigWidth)
        ) begin
            /*----------------------------------------------------------------
            *----------------------------------------------------------------*/
            assign common_expOut = sAdjustedExp + doShiftSigDown1;
            assign common_fractOut =
                doShiftSigDown1 ? adjustedSig>>3 : adjustedSig>>2;
            assign common_overflow       = 0;
            assign common_totalUnderflow = 0;
            assign common_underflow      = 0;
            assign common_inexact        = 0;
        end else begin
            /*----------------------------------------------------------------
            *----------------------------------------------------------------*/
            wire [(outSigWidth + 2):0] roundMask;
            if (neverUnderflows) begin
                assign roundMask = {doShiftSigDown1, 2'b11};
            end else begin
                wire [outSigWidth:0] roundMask_main;
                lowMaskLoHi#(
                    outExpWidth + 1,
                    outMinNormExp - outSigWidth - 1,
                    outMinNormExp
                ) lowMask_roundMask(
                        sAdjustedExp[outExpWidth:0]
                            | (propagateNaNPayload ? 1'b1<<outExpWidth : 1'b0),
                        roundMask_main
                    );
                assign roundMask = {roundMask_main | doShiftSigDown1, 2'b11};
            end
            wire [(outSigWidth + 2):0] shiftedRoundMask = roundMask>>1;
            wire [(outSigWidth + 2):0] roundPosMask =
                ~shiftedRoundMask & roundMask;
            wire roundPosBit =
                (|(adjustedSig[(outSigWidth + 2):3]
                       & roundPosMask[(outSigWidth + 2):3]))
                    || ((|(adjustedSig[2:0] & roundPosMask[2:0]))
                            && !propagateNaNPayload);
            wire anyRoundExtra =
                (|(adjustedSig[(outSigWidth + 2):3]
                       & shiftedRoundMask[(outSigWidth + 2):3]))
                    || ((|(adjustedSig[2:0] & shiftedRoundMask[2:0]))
                            && !propagateNaNPayload);
            wire anyRound = roundPosBit || anyRoundExtra;
            /*----------------------------------------------------------------
            *----------------------------------------------------------------*/
            wire roundIncr =
                ((roundingMode_near_even || roundingMode_near_maxMag)
                     && roundPosBit)
                    || (roundMagUp && anyRound);
            wire [(outSigWidth + 1):0] roundedSig =
                roundIncr
                    ? (((adjustedSig | roundMask)>>2) + 1)
                          & ~(roundingMode_near_even && roundPosBit
                                  && !anyRoundExtra
                                  ? roundMask>>1 : 0)
                    : (adjustedSig & ~roundMask)>>2
                          | (roundingMode_odd && anyRound
                                 ? roundPosMask>>1 : 0);
            wire signed [adjustedExpWidth:0] sExtAdjustedExp = sAdjustedExp;
            wire signed [adjustedExpWidth:0] sRoundedExp =
                sExtAdjustedExp + (roundedSig>>outSigWidth);
            /*----------------------------------------------------------------
            *----------------------------------------------------------------*/
            assign common_expOut = sRoundedExp;
            assign common_fractOut =
                doShiftSigDown1 ? roundedSig>>1 : roundedSig;
            assign common_overflow =
                neverOverflows ? 0 : (sRoundedExp>>>(outExpWidth - 1) >= 3);
            assign common_totalUnderflow =
                neverUnderflows ? 0 : (sRoundedExp < outMinNonzeroExp);
            /*----------------------------------------------------------------
            *----------------------------------------------------------------*/
            wire unboundedRange_roundPosBit =
                doShiftSigDown1 ? adjustedSig[2] : adjustedSig[1];
            wire unboundedRange_anyRound =
                (doShiftSigDown1 && adjustedSig[2]) || (|adjustedSig[1:0]);
            wire unboundedRange_roundIncr =
                ((roundingMode_near_even || roundingMode_near_maxMag)
                     && unboundedRange_roundPosBit)
                    || (roundMagUp && unboundedRange_anyRound);
            wire roundCarry =
                doShiftSigDown1
                    ? roundedSig[outSigWidth + 1] : roundedSig[outSigWidth];
            assign common_underflow =
                neverUnderflows ? 0
                    : common_totalUnderflow
                          || (anyRound && (sAdjustedExp>>>outExpWidth <= 0)
                                  && (doShiftSigDown1
                                          ? roundMask[3] : roundMask[2])
                                  && !(((control
                                           & `flControl_tininessAfterRounding)
                                            != 0)
                                           && !(doShiftSigDown1 ? roundMask[4]
                                                    : roundMask[3])
                                           && roundCarry && roundPosBit
                                           && unboundedRange_roundIncr));
            /*----------------------------------------------------------------
            *----------------------------------------------------------------*/
            assign common_inexact = common_totalUnderflow || anyRound;
        end
    endgenerate
    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    wire notNaN_isSpecialInfOut = infiniteExc || in_isInf;
    wire commonCase = !isNaNOut && !notNaN_isSpecialInfOut && !in_isZero;
    wire overflow  = commonCase && common_overflow;
    wire underflow = commonCase && common_underflow;
    wire inexact = overflow || (commonCase && common_inexact);
    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    wire overflow_roundMagUp =
        roundingMode_near_even || roundingMode_near_maxMag || roundMagUp;
    wire pegMinNonzeroMagOut =
        commonCase && common_totalUnderflow
            && (roundMagUp || roundingMode_odd);
    wire pegMaxFiniteMagOut = overflow && !overflow_roundMagUp;
    wire notNaN_isInfOut =
        notNaN_isSpecialInfOut || (overflow && overflow_roundMagUp);
    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
`ifdef HardFloat_propagateNaNPayloads
    wire signOut = in_sign;
`else
    wire signOut = isNaNOut ? `HardFloat_signDefaultNaN : in_sign;
`endif
    wire [outExpWidth:0] expOut =
        (common_expOut
             & ~(in_isZero || common_totalUnderflow ? 7<<(outExpWidth - 2) : 0)
             & ~(pegMinNonzeroMagOut               ? ~outMinNonzeroExp    : 0)
             & ~(pegMaxFiniteMagOut                ? 1<<(outExpWidth - 1) : 0)
             & ~(notNaN_isInfOut                   ? 1<<(outExpWidth - 2) : 0))
            | (pegMinNonzeroMagOut ? outMinNonzeroExp : 0)
            | (pegMaxFiniteMagOut  ? outMaxFiniteExp  : 0)
            | (notNaN_isInfOut     ? outInfExp        : 0)
            | (isNaNOut            ? outNaNExp        : 0);
`ifdef HardFloat_propagateNaNPayloads
    wire [(outSigWidth - 2):0] fractOut =
        {isNaNOut
             || (!in_isZero && !common_totalUnderflow
                     && common_fractOut[outSigWidth - 2]),
         isNaNOut || (!in_isZero && !common_totalUnderflow)
             ? common_fractOut[(outSigWidth - 3):0] : 1'b0}
            | {(outSigWidth - 1){pegMaxFiniteMagOut}};
`else
    wire [(outSigWidth - 2):0] fractOut =
          (isNaNOut ? `HardFloat_fractDefaultNaN(outSigWidth) : 0)
        | (!in_isZero && !common_totalUnderflow
               ? common_fractOut & `HardFloat_fractDefaultNaN(outSigWidth) : 0)
        | (!isNaNOut && !in_isZero && !common_totalUnderflow
               ? common_fractOut & ~`HardFloat_fractDefaultNaN(outSigWidth)
               : 0)
        | {(outSigWidth - 1){pegMaxFiniteMagOut}};
`endif
    assign out = {signOut, expOut, fractOut};
    assign exceptionFlags =
        {invalidExc, infiniteExc, overflow, underflow, inexact};

endmodule

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    roundRawFNToRecFN#(
        parameter expWidth = 3,
        parameter sigWidth = 3,
        parameter options = 0
    ) (
        input [(`floatControlWidth - 1):0] control,
        input invalidExc,     // overrides 'infiniteExc' and 'in_*' inputs
        input infiniteExc,    // overrides 'in_*' inputs except 'in_sign'
        input in_isNaN,
        input in_isInf,
        input in_isZero,
        input in_sign,
        input signed [(expWidth + 1):0] in_sExp,   // limited range allowed
        input [(sigWidth + 2):0] in_sig,
        input [2:0] roundingMode,
        output [(expWidth + sigWidth):0] out,
        output [4:0] exceptionFlags
    );

    roundAnyRawFNToRecFN#(expWidth, sigWidth + 2, expWidth, sigWidth, options)
        roundAnyRawFNToRecFN(
            control,
            invalidExc,
            infiniteExc,
            in_isNaN,
            in_isInf,
            in_isZero,
            in_sign,
            in_sExp,
            in_sig,
            roundingMode,
            out,
            exceptionFlags
        );

endmodule

`endif /* __HARDFLOAT_RAWFN_VI__ */

// End of all v_libs files for component MulRecFN__expWidth_9__sigWidth_23

`line 1 "/cgra/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/mulRecFN.v" 0
`ifndef __HARDFLOAT_MULRECFN_V__
`define __HARDFLOAT_MULRECFN_V__

/*============================================================================

This Verilog source file is part of the Berkeley HardFloat IEEE Floating-Point
Arithmetic Package, Release 1, by John R. Hauser.

Copyright 2019 The Regents of the University of California.  All rights
reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
    this list of conditions, and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions, and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

 3. Neither the name of the University nor the names of its contributors may
    be used to endorse or promote products derived from this software without
    specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=============================================================================*/

`line 1 "/cgra/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/HardFloat_consts.vi" 0
`ifndef __HARDFLOAT_CONSTS_VI__
`define __HARDFLOAT_CONSTS_VI__

/*============================================================================

This Verilog include file is part of the Berkeley HardFloat IEEE Floating-
Point Arithmetic Package, Release 1, by John R. Hauser.

Copyright 2019 The Regents of the University of California.  All rights
reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
    this list of conditions, and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions, and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

 3. Neither the name of the University nor the names of its contributors may
    be used to endorse or promote products derived from this software without
    specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=============================================================================*/

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/
`define round_near_even   3'b000
`define round_minMag      3'b001
`define round_min         3'b010
`define round_max         3'b011
`define round_near_maxMag 3'b100
`define round_odd         3'b110

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/
`define floatControlWidth 1
`define flControl_tininessBeforeRounding 1'b0
`define flControl_tininessAfterRounding  1'b1

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/
`define flRoundOpt_sigMSBitAlwaysZero  1
`define flRoundOpt_subnormsAlwaysExact 2
`define flRoundOpt_neverUnderflows     4
`define flRoundOpt_neverOverflows      8

`endif /* __HARDFLOAT_CONSTS_VI__ */

`line 40 "/cgra/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/mulRecFN.v" 0
`line 1 "/cgra/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/HardFloat_specialize.vi" 0
`ifndef __HARDFLOAT_SPECIALIZE_VI__
`define __HARDFLOAT_SPECIALIZE_VI__

/*============================================================================

This Verilog source file is part of the Berkeley HardFloat IEEE Floating-Point
Arithmetic Package, Release 1, by John R. Hauser.

Copyright 2019 The Regents of the University of California.  All rights
reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
    this list of conditions, and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions, and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

 3. Neither the name of the University nor the names of its contributors may
    be used to endorse or promote products derived from this software without
    specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=============================================================================*/

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    iNFromException#(parameter width = 1) (
        input signedOut,
        input isNaN,
        input sign,
        output [(width - 1):0] out
    );

    wire maxInt = isNaN || !sign;
    assign out = {signedOut ^ maxInt, {(width - 1){maxInt}}};

endmodule

`endif /* __HARDFLOAT_SPECIALIZE_VI__ */

`line 41 "/cgra/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/mulRecFN.v" 0

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    mulRecFNToFullRaw#(parameter expWidth = 3, parameter sigWidth = 3) (
        input [(`floatControlWidth - 1):0] control,
        input [(expWidth + sigWidth):0] a,
        input [(expWidth + sigWidth):0] b,
        output invalidExc,
        output out_isNaN,
        output out_isInf,
        output out_isZero,
        output out_sign,
        output signed [(expWidth + 1):0] out_sExp,
        output [(sigWidth*2 - 1):0] out_sig
    );

    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    wire isNaNA, isInfA, isZeroA, signA;
    wire signed [(expWidth + 1):0] sExpA;
    wire [sigWidth:0] sigA;
    recFNToRawFN#(expWidth, sigWidth)
        recFNToRawFN_a(a, isNaNA, isInfA, isZeroA, signA, sExpA, sigA);
    wire isSigNaNA;
    isSigNaNRecFN#(expWidth, sigWidth) isSigNaN_a(a, isSigNaNA);
    wire isNaNB, isInfB, isZeroB, signB;
    wire signed [(expWidth + 1):0] sExpB;
    wire [sigWidth:0] sigB;
    recFNToRawFN#(expWidth, sigWidth)
        recFNToRawFN_b(b, isNaNB, isInfB, isZeroB, signB, sExpB, sigB);
    wire isSigNaNB;
    isSigNaNRecFN#(expWidth, sigWidth) isSigNaN_b(b, isSigNaNB);
    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    wire notSigNaN_invalidExc = (isInfA && isZeroB) || (isZeroA && isInfB);
    wire notNaN_isInfOut = isInfA || isInfB;
    wire notNaN_isZeroOut = isZeroA || isZeroB;
    wire notNaN_signOut = signA ^ signB;
    wire signed [(expWidth + 1):0] common_sExpOut =
        sExpA + sExpB - (1<<expWidth);
    wire [(sigWidth*2 - 1):0] common_sigOut = sigA * sigB;
    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    assign invalidExc = isSigNaNA || isSigNaNB || notSigNaN_invalidExc;
    assign out_isInf = notNaN_isInfOut;
    assign out_isZero = notNaN_isZeroOut;
    assign out_sExp = common_sExpOut;
`ifdef HardFloat_propagateNaNPayloads
    assign out_isNaN = isNaNA || isNaNB || notSigNaN_invalidExc;
    wire signNaN;
    wire [(sigWidth - 2):0] fractNaN;
    propagateFloatNaN_mul#(sigWidth)
        propagateNaN(
            control,
            isNaNA,
            signA,
            sigA[(sigWidth - 2):0],
            isNaNB,
            signB,
            sigB[(sigWidth - 2):0],
            signNaN,
            fractNaN
        );
    assign out_sign = out_isNaN ? signNaN : notNaN_signOut;
    assign out_sig =
        out_isNaN ? {1'b1, fractNaN}<<(sigWidth - 1) : common_sigOut;
`else
    assign out_isNaN = isNaNA || isNaNB;
    assign out_sign = notNaN_signOut;
    assign out_sig = common_sigOut;
`endif

endmodule

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    mulRecFNToRaw#(parameter expWidth = 3, parameter sigWidth = 3) (
        input [(`floatControlWidth - 1):0] control,
        input [(expWidth + sigWidth):0] a,
        input [(expWidth + sigWidth):0] b,
        output invalidExc,
        output out_isNaN,
        output out_isInf,
        output out_isZero,
        output out_sign,
        output signed [(expWidth + 1):0] out_sExp,
        output [(sigWidth + 2):0] out_sig
    );

    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    wire isNaNA, isInfA, isZeroA, signA;
    wire signed [(expWidth + 1):0] sExpA;
    wire [sigWidth:0] sigA;
    recFNToRawFN#(expWidth, sigWidth)
        recFNToRawFN_a(a, isNaNA, isInfA, isZeroA, signA, sExpA, sigA);
    wire isSigNaNA;
    isSigNaNRecFN#(expWidth, sigWidth) isSigNaN_a(a, isSigNaNA);
    wire isNaNB, isInfB, isZeroB, signB;
    wire signed [(expWidth + 1):0] sExpB;
    wire [sigWidth:0] sigB;
    recFNToRawFN#(expWidth, sigWidth)
        recFNToRawFN_b(b, isNaNB, isInfB, isZeroB, signB, sExpB, sigB);
    wire isSigNaNB;
    isSigNaNRecFN#(expWidth, sigWidth) isSigNaN_b(b, isSigNaNB);
    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    wire notSigNaN_invalidExc = (isInfA && isZeroB) || (isZeroA && isInfB);
    wire notNaN_isInfOut = isInfA || isInfB;
    wire notNaN_isZeroOut = isZeroA || isZeroB;
    wire notNaN_signOut = signA ^ signB;
    wire signed [(expWidth + 1):0] common_sExpOut =
        sExpA + sExpB - (1<<expWidth);
    wire [(sigWidth*2 - 1):0] sigProd = sigA * sigB;
    wire [(sigWidth + 2):0] common_sigOut =
        {sigProd[(sigWidth*2 - 1):(sigWidth - 2)], |sigProd[(sigWidth - 3):0]};
    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    assign invalidExc = isSigNaNA || isSigNaNB || notSigNaN_invalidExc;
    assign out_isInf = notNaN_isInfOut;
    assign out_isZero = notNaN_isZeroOut;
    assign out_sExp = common_sExpOut;
`ifdef HardFloat_propagateNaNPayloads
    assign out_isNaN = isNaNA || isNaNB || notSigNaN_invalidExc;
    wire signNaN;
    wire [(sigWidth - 2):0] fractNaN;
    propagateFloatNaN_mul#(sigWidth)
        propagateNaN(
            control,
            isNaNA,
            signA,
            sigA[(sigWidth - 2):0],
            isNaNB,
            signB,
            sigB[(sigWidth - 2):0],
            signNaN,
            fractNaN
        );
    assign out_sign = out_isNaN ? signNaN : notNaN_signOut;
    assign out_sig = out_isNaN ? {1'b1, fractNaN, 2'b00} : common_sigOut;
`else
    assign out_isNaN = isNaNA || isNaNB;
    assign out_sign = notNaN_signOut;
    assign out_sig = common_sigOut;
`endif

endmodule

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    mulRecFN#(parameter expWidth = 3, parameter sigWidth = 3) (
        input [(`floatControlWidth - 1):0] control,
        input [(expWidth + sigWidth):0] a,
        input [(expWidth + sigWidth):0] b,
        input [2:0] roundingMode,
        output [(expWidth + sigWidth):0] out,
        output [4:0] exceptionFlags
    );

    wire invalidExc, out_isNaN, out_isInf, out_isZero, out_sign;
    wire signed [(expWidth + 1):0] out_sExp;
    wire [(sigWidth + 2):0] out_sig;
    mulRecFNToRaw#(expWidth, sigWidth)
        mulRecFNToRaw(
            control,
            a,
            b,
            invalidExc,
            out_isNaN,
            out_isInf,
            out_isZero,
            out_sign,
            out_sExp,
            out_sig
        );
    roundRawFNToRecFN#(expWidth, sigWidth, 0)
        roundRawOut(
            control,
            invalidExc,
            1'b0,
            out_isNaN,
            out_isInf,
            out_isZero,
            out_sign,
            out_sExp,
            out_sig,
            roundingMode,
            out,
            exceptionFlags
        );

endmodule

`endif /* __HARDFLOAT_MULRECFN_V__ */

`endif /* MULRECFN */

//-----------------------------------------------------------
// Wrapper of placeholder MulRecFN__expWidth_9__sigWidth_23
//-----------------------------------------------------------

`ifndef MULRECFN__EXPWIDTH_9__SIGWIDTH_23
`define MULRECFN__EXPWIDTH_9__SIGWIDTH_23

module MulRecFN__expWidth_9__sigWidth_23
(
  input logic reset,
  input logic clk,
  input logic [33-1:0] a ,
  input logic [33-1:0] b ,
  input logic [1-1:0] control ,
  output logic [5-1:0] exceptionFlags ,
  output logic [33-1:0] out ,
  input logic [3-1:0] roundingMode 
);
  mulRecFN
  #(
    .expWidth( 9 ),
    .sigWidth( 23 )
  ) v
  (
    .a( a ),
    .b( b ),
    .control( control ),
    .exceptionFlags( exceptionFlags ),
    .out( out ),
    .roundingMode( roundingMode )
  );
endmodule

`endif /* MULRECFN__EXPWIDTH_9__SIGWIDTH_23 */



// PyMTL Component MulFN Definition
// At /cgra/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/MulFNRTL.py

module MulFN__expWidth_9__sigWidth_23
(
  input  logic [31:0] a ,
  input  logic [31:0] b ,
  input  logic [0:0] clk ,
  output logic [31:0] out ,
  input  logic [0:0] reset ,
  input  logic [2:0] roundingMode 
);
  logic [32:0] conv_a;
  logic [32:0] conv_b;
  logic [4:0] exception_flags;
  //-------------------------------------------------------------
  // Component multiplier
  //-------------------------------------------------------------

  logic [32:0] multiplier_a;
  logic [32:0] multiplier_b;
  logic [0:0] multiplier_clk;
  logic [0:0] multiplier_control;
  logic [4:0] multiplier_exceptionFlags;
  logic [32:0] multiplier_out;
  logic [0:0] multiplier_reset;
  logic [2:0] multiplier_roundingMode;

  MulRecFN__expWidth_9__sigWidth_23 multiplier
  (
    .a( multiplier_a ),
    .b( multiplier_b ),
    .clk( multiplier_clk ),
    .control( multiplier_control ),
    .exceptionFlags( multiplier_exceptionFlags ),
    .out( multiplier_out ),
    .reset( multiplier_reset ),
    .roundingMode( multiplier_roundingMode )
  );

  //-------------------------------------------------------------
  // End of component multiplier
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component rec_to_std_conv
  //-------------------------------------------------------------

  logic [0:0] rec_to_std_conv_clk;
  logic [32:0] rec_to_std_conv_in_;
  logic [31:0] rec_to_std_conv_out;
  logic [0:0] rec_to_std_conv_reset;

  RecFNToFN__expWidth_9__sigWidth_23 rec_to_std_conv
  (
    .clk( rec_to_std_conv_clk ),
    .in_( rec_to_std_conv_in_ ),
    .out( rec_to_std_conv_out ),
    .reset( rec_to_std_conv_reset )
  );

  //-------------------------------------------------------------
  // End of component rec_to_std_conv
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component std_to_rec_conv_a
  //-------------------------------------------------------------

  logic [0:0] std_to_rec_conv_a_clk;
  logic [31:0] std_to_rec_conv_a_in_;
  logic [32:0] std_to_rec_conv_a_out;
  logic [0:0] std_to_rec_conv_a_reset;

  FNToRecFN__expWidth_9__sigWidth_23 std_to_rec_conv_a
  (
    .clk( std_to_rec_conv_a_clk ),
    .in_( std_to_rec_conv_a_in_ ),
    .out( std_to_rec_conv_a_out ),
    .reset( std_to_rec_conv_a_reset )
  );

  //-------------------------------------------------------------
  // End of component std_to_rec_conv_a
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component std_to_rec_conv_b
  //-------------------------------------------------------------

  logic [0:0] std_to_rec_conv_b_clk;
  logic [31:0] std_to_rec_conv_b_in_;
  logic [32:0] std_to_rec_conv_b_out;
  logic [0:0] std_to_rec_conv_b_reset;

  FNToRecFN__expWidth_9__sigWidth_23 std_to_rec_conv_b
  (
    .clk( std_to_rec_conv_b_clk ),
    .in_( std_to_rec_conv_b_in_ ),
    .out( std_to_rec_conv_b_out ),
    .reset( std_to_rec_conv_b_reset )
  );

  //-------------------------------------------------------------
  // End of component std_to_rec_conv_b
  //-------------------------------------------------------------

  assign std_to_rec_conv_a_clk = clk;
  assign std_to_rec_conv_a_reset = reset;
  assign std_to_rec_conv_b_clk = clk;
  assign std_to_rec_conv_b_reset = reset;
  assign rec_to_std_conv_clk = clk;
  assign rec_to_std_conv_reset = reset;
  assign multiplier_clk = clk;
  assign multiplier_reset = reset;
  assign std_to_rec_conv_a_in_ = a;
  assign conv_a = std_to_rec_conv_a_out;
  assign std_to_rec_conv_b_in_ = b;
  assign conv_b = std_to_rec_conv_b_out;
  assign multiplier_control = 1'd1;
  assign multiplier_a = conv_a;
  assign multiplier_b = conv_b;
  assign multiplier_roundingMode = roundingMode;
  assign exception_flags = multiplier_exceptionFlags;
  assign rec_to_std_conv_in_ = multiplier_out;
  assign out = rec_to_std_conv_out;

endmodule


// PyMTL Component FpMulRTL Definition
// Full name: FpMulRTL__CtrlPktType_IntraCgraPacket_4_4x1_4_8_2_CgraPayload__11cd3f8c0d91825c__num_inports_4__num_outports_2__exp_nbits_8__sig_nbits_23
// At /cgra/VectorCGRA/fu/float/FpMulRTL.py

module FpMulRTL__989701b477aa86f0
(
  input  logic [0:0] clear ,
  input  logic [0:0] clk ,
  input  logic [2:0] ctrl_addr_inport ,
  input  logic [0:0] reset ,
  input CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 from_mem_rdata__msg  ,
  output logic [0:0] from_mem_rdata__rdy  ,
  input logic [0:0] from_mem_rdata__val  ,
  input CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 recv_const__msg  ,
  output logic [0:0] recv_const__rdy  ,
  input logic [0:0] recv_const__val  ,
  input MultiCgraPayload_Cmd_Data_DataAddr_Ctrl_CtrlAddr__a0427cd98cfcae6f recv_from_ctrl_mem__msg  ,
  output logic [0:0] recv_from_ctrl_mem__rdy  ,
  input logic [0:0] recv_from_ctrl_mem__val  ,
  input CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 recv_in__msg [0:3] ,
  output logic [0:0] recv_in__rdy [0:3] ,
  input logic [0:0] recv_in__val [0:3] ,
  input CGRAConfig_7_4_2_8_8_3__603a41f5d0e2436f recv_opt__msg  ,
  output logic [0:0] recv_opt__rdy  ,
  input logic [0:0] recv_opt__val  ,
  output CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 send_out__msg [0:1] ,
  input logic [0:0] send_out__rdy [0:1] ,
  output logic [0:0] send_out__val [0:1] ,
  output MultiCgraPayload_Cmd_Data_DataAddr_Ctrl_CtrlAddr__a0427cd98cfcae6f send_to_ctrl_mem__msg  ,
  input logic [0:0] send_to_ctrl_mem__rdy  ,
  output logic [0:0] send_to_ctrl_mem__val  ,
  output logic [8:0] to_mem_raddr__msg  ,
  input logic [0:0] to_mem_raddr__rdy  ,
  output logic [0:0] to_mem_raddr__val  ,
  output logic [8:0] to_mem_waddr__msg  ,
  input logic [0:0] to_mem_waddr__rdy  ,
  output logic [0:0] to_mem_waddr__val  ,
  output CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 to_mem_wdata__msg  ,
  input logic [0:0] to_mem_wdata__rdy  ,
  output logic [0:0] to_mem_wdata__val  
);
  localparam CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 const_zero  = { 32'd0, 1'd0, 1'd0, 1'd0 };
  localparam logic [6:0] __const__OPT_START  = 7'd0;
  localparam logic [0:0] __const__latency_at_proceed_latency  = 1'd1;
  localparam logic [2:0] __const__num_inports_at_comb_logic  = 3'd4;
  localparam logic [1:0] __const__num_outports_at_comb_logic  = 2'd2;
  localparam logic [6:0] __const__OPT_FMUL  = 7'd41;
  localparam logic [6:0] __const__OPT_FMUL_CONST  = 7'd42;
  logic [2:0] in0;
  logic [1:0] in0_idx;
  logic [2:0] in1;
  logic [1:0] in1_idx;
  logic [0:0] latency;
  logic [0:0] reached_vector_factor;
  logic [0:0] recv_all_val;
  logic [7:0] vector_factor_counter;
  logic [2:0] vector_factor_power;
  //-------------------------------------------------------------
  // Component fmul
  //-------------------------------------------------------------

  logic [31:0] fmul__a;
  logic [31:0] fmul__b;
  logic [0:0] fmul__clk;
  logic [31:0] fmul__out;
  logic [0:0] fmul__reset;
  logic [2:0] fmul__roundingMode;

  MulFN__expWidth_9__sigWidth_23 fmul
  (
    .a( fmul__a ),
    .b( fmul__b ),
    .clk( fmul__clk ),
    .out( fmul__out ),
    .reset( fmul__reset ),
    .roundingMode( fmul__roundingMode )
  );

  //-------------------------------------------------------------
  // End of component fmul
  //-------------------------------------------------------------

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/fu/float/FpMulRTL.py:61
  // @update
  // def comb_logic():
  // 
  //   s.recv_all_val @= 0
  //   # For pick input register
  //   s.in0 @= 0
  //   s.in1 @= 0
  //   for i in range(num_inports):
  //     s.recv_in[i].rdy @= b1(0)
  // 
  //   for i in range(num_outports):
  //     s.send_out[i].val @= 0
  //     s.send_out[i].msg @= s.DataType()
  // 
  //   s.recv_const.rdy @= 0
  //   s.recv_opt.rdy @= 0
  // 
  //   s.send_to_ctrl_mem.val @= 0
  //   s.send_to_ctrl_mem.msg @= s.CgraPayloadType(0, 0, 0, 0, 0)
  // 
  //   s.recv_from_ctrl_mem.rdy @= 0
  // 
  //   s.fmul.a @= 0
  //   s.fmul.b @= 0
  // 
  //   if s.recv_opt.val:
  //     if s.recv_opt.msg.fu_in[0] != 0:
  //       s.in0 @= zext(s.recv_opt.msg.fu_in[0] - 1, FuInType)
  //     if s.recv_opt.msg.fu_in[1] != 0:
  //       s.in1 @= zext(s.recv_opt.msg.fu_in[1] - 1, FuInType)
  // 
  //   if s.recv_opt.val:
  //     if s.recv_opt.msg.operation == OPT_FMUL:
  //       s.fmul.a @= s.recv_in[s.in0_idx].msg.payload
  //       s.fmul.b @= s.recv_in[s.in1_idx].msg.payload
  //       s.send_out[0].msg.predicate @= s.recv_in[s.in0_idx].msg.predicate & \
  //                                      s.recv_in[s.in1_idx].msg.predicate
  //       s.recv_all_val @= s.recv_in[s.in0_idx].val & s.recv_in[s.in1_idx].val
  //       s.send_out[0].val @= s.recv_all_val
  //       s.recv_in[s.in0_idx].rdy @= s.recv_all_val & s.send_out[0].rdy
  //       s.recv_in[s.in1_idx].rdy @= s.recv_all_val & s.send_out[0].rdy
  //       s.recv_opt.rdy @= s.recv_all_val & s.send_out[0].rdy
  // 
  //     elif s.recv_opt.msg.operation == OPT_FMUL_CONST:
  //       s.fmul.a @= s.recv_in[s.in0_idx].msg.payload
  //       s.fmul.b @= s.recv_const.msg.payload
  //       s.send_out[0].msg.predicate @= s.recv_in[s.in0_idx].msg.predicate
  //       s.recv_all_val @= s.recv_in[s.in0_idx].val
  //       s.send_out[0].val @= s.recv_all_val
  //       s.recv_in[s.in0_idx].rdy @= s.recv_all_val & s.send_out[0].rdy
  //       s.recv_const.rdy @= s.recv_all_val & s.send_out[0].rdy
  //       s.recv_opt.rdy @= s.recv_all_val & s.send_out[0].rdy
  // 
  //     else:
  //       for j in range(num_outports):
  //         s.send_out[j].val @= b1(0)
  //       s.recv_opt.rdy @= 0
  //       s.recv_in[s.in0_idx].rdy @= 0
  //       s.recv_in[s.in1_idx].rdy @= 0
  // 
  //     s.send_out[0].msg.payload @= s.fmul.out
  
  always_comb begin : comb_logic
    recv_all_val = 1'd0;
    in0 = 3'd0;
    in1 = 3'd0;
    for ( int unsigned i = 1'd0; i < 3'( __const__num_inports_at_comb_logic ); i += 1'd1 )
      recv_in__rdy[2'(i)] = 1'd0;
    for ( int unsigned i = 1'd0; i < 2'( __const__num_outports_at_comb_logic ); i += 1'd1 ) begin
      send_out__val[1'(i)] = 1'd0;
      send_out__msg[1'(i)] = { 32'd0, 1'd0, 1'd0, 1'd0 };
    end
    recv_const__rdy = 1'd0;
    recv_opt__rdy = 1'd0;
    send_to_ctrl_mem__val = 1'd0;
    send_to_ctrl_mem__msg = { 5'd0, 35'd0, 9'd0, 139'd0, 3'd0 };
    recv_from_ctrl_mem__rdy = 1'd0;
    fmul__a = 32'd0;
    fmul__b = 32'd0;
    if ( recv_opt__val ) begin
      if ( recv_opt__msg.fu_in[2'd0] != 3'd0 ) begin
        in0 = recv_opt__msg.fu_in[2'd0] - 3'd1;
      end
      if ( recv_opt__msg.fu_in[2'd1] != 3'd0 ) begin
        in1 = recv_opt__msg.fu_in[2'd1] - 3'd1;
      end
    end
    if ( recv_opt__val ) begin
      if ( recv_opt__msg.operation == 7'( __const__OPT_FMUL ) ) begin
        fmul__a = recv_in__msg[in0_idx].payload;
        fmul__b = recv_in__msg[in1_idx].payload;
        send_out__msg[1'd0].predicate = recv_in__msg[in0_idx].predicate & recv_in__msg[in1_idx].predicate;
        recv_all_val = recv_in__val[in0_idx] & recv_in__val[in1_idx];
        send_out__val[1'd0] = recv_all_val;
        recv_in__rdy[in0_idx] = recv_all_val & send_out__rdy[1'd0];
        recv_in__rdy[in1_idx] = recv_all_val & send_out__rdy[1'd0];
        recv_opt__rdy = recv_all_val & send_out__rdy[1'd0];
      end
      else if ( recv_opt__msg.operation == 7'( __const__OPT_FMUL_CONST ) ) begin
        fmul__a = recv_in__msg[in0_idx].payload;
        fmul__b = recv_const__msg.payload;
        send_out__msg[1'd0].predicate = recv_in__msg[in0_idx].predicate;
        recv_all_val = recv_in__val[in0_idx];
        send_out__val[1'd0] = recv_all_val;
        recv_in__rdy[in0_idx] = recv_all_val & send_out__rdy[1'd0];
        recv_const__rdy = recv_all_val & send_out__rdy[1'd0];
        recv_opt__rdy = recv_all_val & send_out__rdy[1'd0];
      end
      else begin
        for ( int unsigned j = 1'd0; j < 2'( __const__num_outports_at_comb_logic ); j += 1'd1 )
          send_out__val[1'(j)] = 1'd0;
        recv_opt__rdy = 1'd0;
        recv_in__rdy[in0_idx] = 1'd0;
        recv_in__rdy[in1_idx] = 1'd0;
      end
      send_out__msg[1'd0].payload = fmul__out;
    end
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/fu/basic/Fu.py:68
  // @update
  // def update_mem():
  //   s.to_mem_waddr.val @= b1(0)
  //   s.to_mem_wdata.val @= b1(0)
  //   s.to_mem_wdata.msg @= s.const_zero
  //   s.to_mem_waddr.msg @= s.DataAddrType(0)
  //   s.to_mem_raddr.msg @= s.DataAddrType(0)
  //   s.to_mem_raddr.val @= b1(0)
  //   s.from_mem_rdata.rdy @= b1(0)
  
  always_comb begin : update_mem
    to_mem_waddr__val = 1'd0;
    to_mem_wdata__val = 1'd0;
    to_mem_wdata__msg = const_zero;
    to_mem_waddr__msg = 9'd0;
    to_mem_raddr__msg = 9'd0;
    to_mem_raddr__val = 1'd0;
    from_mem_rdata__rdy = 1'd0;
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/fu/basic/Fu.py:87
  // @update
  // def update_reached_vector_factor():
  //   s.reached_vector_factor @= 0
  //   if s.recv_opt.val & (s.vector_factor_counter + \
  //                        (VectorFactorType(1) << zext(s.vector_factor_power, VectorFactorType)) >= \
  //                        (VectorFactorType(1) << zext(s.recv_opt.msg.vector_factor_power, VectorFactorType))):
  //     s.reached_vector_factor @= 1
  
  always_comb begin : update_reached_vector_factor
    reached_vector_factor = 1'd0;
    if ( recv_opt__val & ( ( vector_factor_counter + ( 8'd1 << { { 5 { 1'b0 } }, vector_factor_power } ) ) >= ( 8'd1 << { { 5 { 1'b0 } }, recv_opt__msg.vector_factor_power } ) ) ) begin
      reached_vector_factor = 1'd1;
    end
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/fu/basic/Fu.py:78
  // @update_ff
  // def proceed_latency():
  //   if s.recv_opt.msg.operation == OPT_START:
  //     s.latency <<= LatencyType(0)
  //   elif s.latency == latency - 1:
  //     s.latency <<= LatencyType(0)
  //   else:
  //     s.latency <<= s.latency + LatencyType(1)
  
  always_ff @(posedge clk) begin : proceed_latency
    if ( recv_opt__msg.operation == 7'( __const__OPT_START ) ) begin
      latency <= 1'd0;
    end
    else if ( latency == ( 1'( __const__latency_at_proceed_latency ) - 1'd1 ) ) begin
      latency <= 1'd0;
    end
    else
      latency <= latency + 1'd1;
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/fu/basic/Fu.py:95
  // @update_ff
  // def update_vector_factor_counter():
  //   if s.reset:
  //     s.vector_factor_counter <<= 0
  //   else:
  //     if s.recv_opt.val:
  //       if s.recv_opt.msg.is_last_ctrl & \
  //          (s.vector_factor_counter + \
  //           (VectorFactorType(1) << zext(s.vector_factor_power, VectorFactorType)) < \
  //           (VectorFactorType(1) << zext(s.recv_opt.msg.vector_factor_power, VectorFactorType))):
  //         s.vector_factor_counter <<= s.vector_factor_counter + \
  //                                     (VectorFactorType(1) << zext(s.vector_factor_power, \
  //                                                                  VectorFactorType))
  //       elif s.recv_opt.msg.is_last_ctrl & s.reached_vector_factor:
  //         s.vector_factor_counter <<= 0
  
  always_ff @(posedge clk) begin : update_vector_factor_counter
    if ( reset ) begin
      vector_factor_counter <= 8'd0;
    end
    else if ( recv_opt__val ) begin
      if ( recv_opt__msg.is_last_ctrl & ( ( vector_factor_counter + ( 8'd1 << { { 5 { 1'b0 } }, vector_factor_power } ) ) < ( 8'd1 << { { 5 { 1'b0 } }, recv_opt__msg.vector_factor_power } ) ) ) begin
        vector_factor_counter <= vector_factor_counter + ( 8'd1 << { { 5 { 1'b0 } }, vector_factor_power } );
      end
      else if ( recv_opt__msg.is_last_ctrl & reached_vector_factor ) begin
        vector_factor_counter <= 8'd0;
      end
    end
  end

  assign vector_factor_power = 3'd0;
  assign fmul__clk = clk;
  assign fmul__reset = reset;
  assign fmul__roundingMode = 3'd0;
  assign in0_idx = in0[1:0];
  assign in1_idx = in1[1:0];

endmodule


// PyMTL Component GrantRTL Definition
// Full name: GrantRTL__CtrlPktType_IntraCgraPacket_4_4x1_4_8_2_CgraPayload__11cd3f8c0d91825c__num_inports_4__num_outports_2__vector_factor_power_0
// At /cgra/VectorCGRA/fu/single/GrantRTL.py

module GrantRTL__1a7eacb70e3ca1c4
(
  input  logic [0:0] clear ,
  input  logic [0:0] clk ,
  input  logic [2:0] ctrl_addr_inport ,
  input  logic [0:0] reset ,
  input CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 from_mem_rdata__msg  ,
  output logic [0:0] from_mem_rdata__rdy  ,
  input logic [0:0] from_mem_rdata__val  ,
  input CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 recv_const__msg  ,
  output logic [0:0] recv_const__rdy  ,
  input logic [0:0] recv_const__val  ,
  input MultiCgraPayload_Cmd_Data_DataAddr_Ctrl_CtrlAddr__a0427cd98cfcae6f recv_from_ctrl_mem__msg  ,
  output logic [0:0] recv_from_ctrl_mem__rdy  ,
  input logic [0:0] recv_from_ctrl_mem__val  ,
  input CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 recv_in__msg [0:3] ,
  output logic [0:0] recv_in__rdy [0:3] ,
  input logic [0:0] recv_in__val [0:3] ,
  input CGRAConfig_7_4_2_8_8_3__603a41f5d0e2436f recv_opt__msg  ,
  output logic [0:0] recv_opt__rdy  ,
  input logic [0:0] recv_opt__val  ,
  output CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 send_out__msg [0:1] ,
  input logic [0:0] send_out__rdy [0:1] ,
  output logic [0:0] send_out__val [0:1] ,
  output MultiCgraPayload_Cmd_Data_DataAddr_Ctrl_CtrlAddr__a0427cd98cfcae6f send_to_ctrl_mem__msg  ,
  input logic [0:0] send_to_ctrl_mem__rdy  ,
  output logic [0:0] send_to_ctrl_mem__val  ,
  output logic [8:0] to_mem_raddr__msg  ,
  input logic [0:0] to_mem_raddr__rdy  ,
  output logic [0:0] to_mem_raddr__val  ,
  output logic [8:0] to_mem_waddr__msg  ,
  input logic [0:0] to_mem_waddr__rdy  ,
  output logic [0:0] to_mem_waddr__val  ,
  output CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 to_mem_wdata__msg  ,
  input logic [0:0] to_mem_wdata__rdy  ,
  output logic [0:0] to_mem_wdata__val  
);
  localparam CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 const_zero  = { 32'd0, 1'd0, 1'd0, 1'd0 };
  localparam logic [6:0] __const__OPT_START  = 7'd0;
  localparam logic [0:0] __const__latency_at_proceed_latency  = 1'd1;
  localparam logic [2:0] __const__num_inports_at_comb_logic  = 3'd4;
  localparam logic [1:0] __const__num_outports_at_comb_logic  = 2'd2;
  localparam logic [6:0] __const__OPT_GRT_PRED  = 7'd16;
  localparam logic [6:0] __const__OPT_GRT_ALWAYS  = 7'd34;
  localparam logic [6:0] __const__OPT_GRT_ONCE  = 7'd47;
  logic [0:0] already_grt_once;
  logic [2:0] in0;
  logic [1:0] in0_idx;
  logic [2:0] in1;
  logic [1:0] in1_idx;
  logic [0:0] latency;
  logic [0:0] reached_vector_factor;
  logic [0:0] recv_all_val;
  logic [7:0] vector_factor_counter;
  logic [2:0] vector_factor_power;

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/fu/single/GrantRTL.py:39
  // @update
  // def comb_logic():
  // 
  //   s.recv_all_val @= 0
  //   # For pick input register
  //   s.in0 @= 0
  //   s.in1 @= 0
  //   for i in range(num_inports):
  //     s.recv_in[i].rdy @= b1(0)
  //   for i in range(num_outports):
  //     s.send_out[i].val @= b1(0)
  //     s.send_out[i].msg @= s.DataType()
  // 
  //   s.recv_const.rdy @= 0
  //   s.recv_opt.rdy @= 0
  // 
  //   s.send_to_ctrl_mem.val @= 0
  //   s.send_to_ctrl_mem.msg @= s.CgraPayloadType(0, 0, 0, 0, 0)
  //   s.recv_from_ctrl_mem.rdy @= 0
  // 
  //   if s.recv_opt.val:
  //     if s.recv_opt.msg.fu_in[0] != FuInType(0):
  //       s.in0 @= s.recv_opt.msg.fu_in[0] - FuInType(1)
  //     if s.recv_opt.msg.fu_in[1] != FuInType(0):
  //       s.in1 @= s.recv_opt.msg.fu_in[1] - FuInType(1)
  // 
  //   if s.recv_opt.val:
  //     if s.recv_opt.msg.operation == OPT_GRT_PRED:
  //       # GRANT_PREDICATE is used to apply (`and` operation) predicate onto a value.
  //       # The second operand would be used/treated as the predicate condition that
  //       # is usually coming from a `cmp` operation.
  //       s.send_out[0].msg.payload @= s.recv_in[s.in0_idx].msg.payload
  //       # Only updates predicate if the condition is true. Note that we respect
  //       # condition's (operand_1's) both value and predicate.
  //       if s.recv_in[s.in1_idx].msg.payload != s.const_zero.payload:
  //         s.send_out[0].msg.predicate @= s.recv_in[s.in0_idx].msg.predicate & \
  //                                        s.recv_in[s.in1_idx].msg.predicate & \
  //                                        s.reached_vector_factor
  //       else:
  //         s.send_out[0].msg.predicate @= 0
  //       s.recv_all_val @= s.recv_in[s.in0_idx].val & s.recv_in[s.in1_idx].val
  //       s.send_out[0].val @= s.recv_all_val
  //       s.recv_in[s.in0_idx].rdy @= s.recv_all_val & s.send_out[0].rdy
  //       s.recv_in[s.in1_idx].rdy @= s.recv_all_val & s.send_out[0].rdy
  //       s.recv_opt.rdy @= s.recv_all_val & s.send_out[0].rdy
  //     elif s.recv_opt.msg.operation == OPT_GRT_ALWAYS:
  //       # GRANT_ALWAYS is used to apply `true` predicate onto a value regardless
  //       # its original predicate value. This is usually used for the constant declared
  //       # in the entry block of a function, and then being used as a bound variable
  //       # in some streaming loop. Note that if we fuse the constant and the grant_always,
  //       # we may not need this operation, as the constant is usually preloaded into the
  //       # ConstQueue with `true` predicate.
  //       s.send_out[0].msg @= s.recv_in[s.in0_idx].msg
  //       # Always updates predicate as true.
  //       s.send_out[0].msg.predicate @= s.reached_vector_factor
  // 
  //       s.recv_all_val @= s.recv_in[s.in0_idx].val
  //       s.send_out[0].val @= s.recv_all_val
  //       s.recv_in[s.in0_idx].rdy @= s.recv_all_val & s.send_out[0].rdy
  //       s.recv_opt.rdy @= s.recv_all_val & s.send_out[0].rdy
  //     elif s.recv_opt.msg.operation == OPT_GRT_ONCE:
  //       # GRANT_ONCE is used to apply `true` predicate onto a value only once. This
  //       # is usually used for the constant declared in the entry block of a function.
  //       s.send_out[0].msg @= s.recv_in[s.in0_idx].msg
  //       # Only updates predicate as true for the first time.
  //       s.send_out[0].msg.predicate @= s.reached_vector_factor & ~s.already_grt_once
  // 
  //       s.recv_all_val @= s.recv_in[s.in0_idx].val
  //       s.send_out[0].val @= s.recv_all_val
  //       s.recv_in[s.in0_idx].rdy @= s.recv_all_val & s.send_out[0].rdy
  //       s.recv_opt.rdy @= s.recv_all_val & s.send_out[0].rdy
  // 
  //     else:
  //       for j in range( num_outports ):
  //         s.send_out[j].val @= b1( 0 )
  //       s.recv_opt.rdy @= 0
  //       s.recv_in[s.in0_idx].rdy @= 0
  //       s.recv_in[s.in1_idx].rdy @= 0
  
  always_comb begin : comb_logic
    recv_all_val = 1'd0;
    in0 = 3'd0;
    in1 = 3'd0;
    for ( int unsigned i = 1'd0; i < 3'( __const__num_inports_at_comb_logic ); i += 1'd1 )
      recv_in__rdy[2'(i)] = 1'd0;
    for ( int unsigned i = 1'd0; i < 2'( __const__num_outports_at_comb_logic ); i += 1'd1 ) begin
      send_out__val[1'(i)] = 1'd0;
      send_out__msg[1'(i)] = { 32'd0, 1'd0, 1'd0, 1'd0 };
    end
    recv_const__rdy = 1'd0;
    recv_opt__rdy = 1'd0;
    send_to_ctrl_mem__val = 1'd0;
    send_to_ctrl_mem__msg = { 5'd0, 35'd0, 9'd0, 139'd0, 3'd0 };
    recv_from_ctrl_mem__rdy = 1'd0;
    if ( recv_opt__val ) begin
      if ( recv_opt__msg.fu_in[2'd0] != 3'd0 ) begin
        in0 = recv_opt__msg.fu_in[2'd0] - 3'd1;
      end
      if ( recv_opt__msg.fu_in[2'd1] != 3'd0 ) begin
        in1 = recv_opt__msg.fu_in[2'd1] - 3'd1;
      end
    end
    if ( recv_opt__val ) begin
      if ( recv_opt__msg.operation == 7'( __const__OPT_GRT_PRED ) ) begin
        send_out__msg[1'd0].payload = recv_in__msg[in0_idx].payload;
        if ( recv_in__msg[in1_idx].payload != 32'd0 ) begin
          send_out__msg[1'd0].predicate = ( recv_in__msg[in0_idx].predicate & recv_in__msg[in1_idx].predicate ) & reached_vector_factor;
        end
        else
          send_out__msg[1'd0].predicate = 1'd0;
        recv_all_val = recv_in__val[in0_idx] & recv_in__val[in1_idx];
        send_out__val[1'd0] = recv_all_val;
        recv_in__rdy[in0_idx] = recv_all_val & send_out__rdy[1'd0];
        recv_in__rdy[in1_idx] = recv_all_val & send_out__rdy[1'd0];
        recv_opt__rdy = recv_all_val & send_out__rdy[1'd0];
      end
      else if ( recv_opt__msg.operation == 7'( __const__OPT_GRT_ALWAYS ) ) begin
        send_out__msg[1'd0] = recv_in__msg[in0_idx];
        send_out__msg[1'd0].predicate = reached_vector_factor;
        recv_all_val = recv_in__val[in0_idx];
        send_out__val[1'd0] = recv_all_val;
        recv_in__rdy[in0_idx] = recv_all_val & send_out__rdy[1'd0];
        recv_opt__rdy = recv_all_val & send_out__rdy[1'd0];
      end
      else if ( recv_opt__msg.operation == 7'( __const__OPT_GRT_ONCE ) ) begin
        send_out__msg[1'd0] = recv_in__msg[in0_idx];
        send_out__msg[1'd0].predicate = reached_vector_factor & ( ~already_grt_once );
        recv_all_val = recv_in__val[in0_idx];
        send_out__val[1'd0] = recv_all_val;
        recv_in__rdy[in0_idx] = recv_all_val & send_out__rdy[1'd0];
        recv_opt__rdy = recv_all_val & send_out__rdy[1'd0];
      end
      else begin
        for ( int unsigned j = 1'd0; j < 2'( __const__num_outports_at_comb_logic ); j += 1'd1 )
          send_out__val[1'(j)] = 1'd0;
        recv_opt__rdy = 1'd0;
        recv_in__rdy[in0_idx] = 1'd0;
        recv_in__rdy[in1_idx] = 1'd0;
      end
    end
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/fu/basic/Fu.py:68
  // @update
  // def update_mem():
  //   s.to_mem_waddr.val @= b1(0)
  //   s.to_mem_wdata.val @= b1(0)
  //   s.to_mem_wdata.msg @= s.const_zero
  //   s.to_mem_waddr.msg @= s.DataAddrType(0)
  //   s.to_mem_raddr.msg @= s.DataAddrType(0)
  //   s.to_mem_raddr.val @= b1(0)
  //   s.from_mem_rdata.rdy @= b1(0)
  
  always_comb begin : update_mem
    to_mem_waddr__val = 1'd0;
    to_mem_wdata__val = 1'd0;
    to_mem_wdata__msg = const_zero;
    to_mem_waddr__msg = 9'd0;
    to_mem_raddr__msg = 9'd0;
    to_mem_raddr__val = 1'd0;
    from_mem_rdata__rdy = 1'd0;
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/fu/basic/Fu.py:87
  // @update
  // def update_reached_vector_factor():
  //   s.reached_vector_factor @= 0
  //   if s.recv_opt.val & (s.vector_factor_counter + \
  //                        (VectorFactorType(1) << zext(s.vector_factor_power, VectorFactorType)) >= \
  //                        (VectorFactorType(1) << zext(s.recv_opt.msg.vector_factor_power, VectorFactorType))):
  //     s.reached_vector_factor @= 1
  
  always_comb begin : update_reached_vector_factor
    reached_vector_factor = 1'd0;
    if ( recv_opt__val & ( ( vector_factor_counter + ( 8'd1 << { { 5 { 1'b0 } }, vector_factor_power } ) ) >= ( 8'd1 << { { 5 { 1'b0 } }, recv_opt__msg.vector_factor_power } ) ) ) begin
      reached_vector_factor = 1'd1;
    end
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/fu/basic/Fu.py:78
  // @update_ff
  // def proceed_latency():
  //   if s.recv_opt.msg.operation == OPT_START:
  //     s.latency <<= LatencyType(0)
  //   elif s.latency == latency - 1:
  //     s.latency <<= LatencyType(0)
  //   else:
  //     s.latency <<= s.latency + LatencyType(1)
  
  always_ff @(posedge clk) begin : proceed_latency
    if ( recv_opt__msg.operation == 7'( __const__OPT_START ) ) begin
      latency <= 1'd0;
    end
    else if ( latency == ( 1'( __const__latency_at_proceed_latency ) - 1'd1 ) ) begin
      latency <= 1'd0;
    end
    else
      latency <= latency + 1'd1;
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/fu/single/GrantRTL.py:118
  // @update_ff
  // def record_grt_once():
  //   if s.reset | s.clear:
  //     s.already_grt_once <<= 0
  //   else:
  //     if ~s.already_grt_once & s.send_out[0].val & s.send_out[0].rdy & (s.recv_opt.msg.operation == OPT_GRT_ONCE):
  //       s.already_grt_once <<= 1
  //     else:
  //       s.already_grt_once <<= s.already_grt_once
  
  always_ff @(posedge clk) begin : record_grt_once
    if ( reset | clear ) begin
      already_grt_once <= 1'd0;
    end
    else if ( ( ( ( ~already_grt_once ) & send_out__val[1'd0] ) & send_out__rdy[1'd0] ) & ( recv_opt__msg.operation == 7'( __const__OPT_GRT_ONCE ) ) ) begin
      already_grt_once <= 1'd1;
    end
    else
      already_grt_once <= already_grt_once;
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/fu/basic/Fu.py:95
  // @update_ff
  // def update_vector_factor_counter():
  //   if s.reset:
  //     s.vector_factor_counter <<= 0
  //   else:
  //     if s.recv_opt.val:
  //       if s.recv_opt.msg.is_last_ctrl & \
  //          (s.vector_factor_counter + \
  //           (VectorFactorType(1) << zext(s.vector_factor_power, VectorFactorType)) < \
  //           (VectorFactorType(1) << zext(s.recv_opt.msg.vector_factor_power, VectorFactorType))):
  //         s.vector_factor_counter <<= s.vector_factor_counter + \
  //                                     (VectorFactorType(1) << zext(s.vector_factor_power, \
  //                                                                  VectorFactorType))
  //       elif s.recv_opt.msg.is_last_ctrl & s.reached_vector_factor:
  //         s.vector_factor_counter <<= 0
  
  always_ff @(posedge clk) begin : update_vector_factor_counter
    if ( reset ) begin
      vector_factor_counter <= 8'd0;
    end
    else if ( recv_opt__val ) begin
      if ( recv_opt__msg.is_last_ctrl & ( ( vector_factor_counter + ( 8'd1 << { { 5 { 1'b0 } }, vector_factor_power } ) ) < ( 8'd1 << { { 5 { 1'b0 } }, recv_opt__msg.vector_factor_power } ) ) ) begin
        vector_factor_counter <= vector_factor_counter + ( 8'd1 << { { 5 { 1'b0 } }, vector_factor_power } );
      end
      else if ( recv_opt__msg.is_last_ctrl & reached_vector_factor ) begin
        vector_factor_counter <= 8'd0;
      end
    end
  end

  assign vector_factor_power = 3'd0;
  assign in0_idx = in0[1:0];
  assign in1_idx = in1[1:0];

endmodule


// PyMTL Component FlexibleFuRTL Definition
// Full name: FlexibleFuRTL__CtrlPktType_IntraCgraPacket_4_4x1_4_8_2_CgraPayload__11cd3f8c0d91825c__num_inports_4__num_outports_2__num_tiles_4__FuList_[<class 'VectorCGRA.fu.single.SelRTL.SelRTL'>, <class 'VectorCGRA.fu.float.FpAddRTL.FpAddRTL'>, <class 'VectorCGRA.fu.single.MulRTL.MulRTL'>, <class 'VectorCGRA.fu.single.LoopControlRTL.LoopControlRTL'>, <class 'VectorCGRA.fu.single.RetRTL.RetRTL'>, <class 'VectorCGRA.fu.single.ExclusiveDivRTL.ExclusiveDivRTL'>, <class 'VectorCGRA.fu.single.AdderRTL.AdderRTL'>, <class 'VectorCGRA.fu.single.MemUnitRTL.MemUnitRTL'>, <class 'VectorCGRA.fu.float.FpMulRTL.FpMulRTL'>, <class 'VectorCGRA.fu.single.GrantRTL.GrantRTL'>, <class 'VectorCGRA.fu.single.CompRTL.CompRTL'>, <class 'VectorCGRA.fu.single.ShifterRTL.ShifterRTL'>, <class 'VectorCGRA.fu.single.PhiRTL.PhiRTL'>, <class 'VectorCGRA.fu.single.LogicRTL.LogicRTL'>, <class 'VectorCGRA.fu.single.ConstRTL.ConstRTL'>, <class 'VectorCGRA.fu.single.NahRTL.NahRTL'>]__exec_lantency_{}
// At /cgra/VectorCGRA/fu/flexible/FlexibleFuRTL.py

module FlexibleFuRTL__44794627483a491e
(
  input  logic [0:0] clear [0:15],
  input  logic [0:0] clk ,
  input  logic [2:0] ctrl_addr_inport ,
  input  logic [2:0] prologue_count_inport ,
  input  logic [0:0] reset ,
  input  logic [2:0] tile_id ,
  input CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 from_mem_rdata__msg [0:15] ,
  output logic [0:0] from_mem_rdata__rdy [0:15] ,
  input logic [0:0] from_mem_rdata__val [0:15] ,
  input CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 recv_const__msg  ,
  output logic [0:0] recv_const__rdy  ,
  input logic [0:0] recv_const__val  ,
  input MultiCgraPayload_Cmd_Data_DataAddr_Ctrl_CtrlAddr__a0427cd98cfcae6f recv_from_ctrl_mem__msg  ,
  output logic [0:0] recv_from_ctrl_mem__rdy  ,
  input logic [0:0] recv_from_ctrl_mem__val  ,
  input CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 recv_in__msg [0:3] ,
  output logic [0:0] recv_in__rdy [0:3] ,
  input logic [0:0] recv_in__val [0:3] ,
  input CGRAConfig_7_4_2_8_8_3__603a41f5d0e2436f recv_opt__msg  ,
  output logic [0:0] recv_opt__rdy  ,
  input logic [0:0] recv_opt__val  ,
  input IntraCgraPacket_4_4x1_4_8_2_CgraPayload__11cd3f8c0d91825c recv_pkt_from_controller__msg  ,
  output logic [0:0] recv_pkt_from_controller__rdy  ,
  input logic [0:0] recv_pkt_from_controller__val  ,
  output CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 send_out__msg [0:1] ,
  input logic [0:0] send_out__rdy [0:1] ,
  output logic [0:0] send_out__val [0:1] ,
  output MultiCgraPayload_Cmd_Data_DataAddr_Ctrl_CtrlAddr__a0427cd98cfcae6f send_to_ctrl_mem__msg  ,
  input logic [0:0] send_to_ctrl_mem__rdy  ,
  output logic [0:0] send_to_ctrl_mem__val  ,
  output logic [8:0] to_mem_raddr__msg [0:15] ,
  input logic [0:0] to_mem_raddr__rdy [0:15] ,
  output logic [0:0] to_mem_raddr__val [0:15] ,
  output logic [8:0] to_mem_waddr__msg [0:15] ,
  input logic [0:0] to_mem_waddr__rdy [0:15] ,
  output logic [0:0] to_mem_waddr__val [0:15] ,
  output CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 to_mem_wdata__msg [0:15] ,
  input logic [0:0] to_mem_wdata__rdy [0:15] ,
  output logic [0:0] to_mem_wdata__val [0:15] 
);
  localparam logic [1:0] __const__num_outports_at_comb_logic  = 2'd2;
  localparam logic [6:0] __const__OPT_NAH  = 7'd1;
  localparam logic [2:0] __const__num_inports_at_comb_logic  = 3'd4;
  logic [15:0] fu_recv_const_rdy_vector;
  logic [15:0] fu_recv_in_rdy_vector [0:3];
  logic [15:0] fu_recv_opt_rdy_vector;
  logic [15:0] recv_from_controller_rdy_vector;
  //-------------------------------------------------------------
  // Component fu[0:15]
  //-------------------------------------------------------------

  logic [0:0] fu__clear [0:15];
  logic [0:0] fu__clk [0:15];
  logic [2:0] fu__ctrl_addr_inport [0:15];
  logic [0:0] fu__reset [0:15];
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 fu__from_mem_rdata__msg [0:15];
  logic [0:0] fu__from_mem_rdata__rdy [0:15];
  logic [0:0] fu__from_mem_rdata__val [0:15];
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 fu__recv_const__msg [0:15];
  logic [0:0] fu__recv_const__rdy [0:15];
  logic [0:0] fu__recv_const__val [0:15];
  MultiCgraPayload_Cmd_Data_DataAddr_Ctrl_CtrlAddr__a0427cd98cfcae6f fu__recv_from_ctrl_mem__msg [0:15];
  logic [0:0] fu__recv_from_ctrl_mem__rdy [0:15];
  logic [0:0] fu__recv_from_ctrl_mem__val [0:15];
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 fu__recv_in__msg [0:15][0:3];
  logic [0:0] fu__recv_in__rdy [0:15][0:3];
  logic [0:0] fu__recv_in__val [0:15][0:3];
  CGRAConfig_7_4_2_8_8_3__603a41f5d0e2436f fu__recv_opt__msg [0:15];
  logic [0:0] fu__recv_opt__rdy [0:15];
  logic [0:0] fu__recv_opt__val [0:15];
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 fu__send_out__msg [0:15][0:1];
  logic [0:0] fu__send_out__rdy [0:15][0:1];
  logic [0:0] fu__send_out__val [0:15][0:1];
  MultiCgraPayload_Cmd_Data_DataAddr_Ctrl_CtrlAddr__a0427cd98cfcae6f fu__send_to_ctrl_mem__msg [0:15];
  logic [0:0] fu__send_to_ctrl_mem__rdy [0:15];
  logic [0:0] fu__send_to_ctrl_mem__val [0:15];
  logic [8:0] fu__to_mem_raddr__msg [0:15];
  logic [0:0] fu__to_mem_raddr__rdy [0:15];
  logic [0:0] fu__to_mem_raddr__val [0:15];
  logic [8:0] fu__to_mem_waddr__msg [0:15];
  logic [0:0] fu__to_mem_waddr__rdy [0:15];
  logic [0:0] fu__to_mem_waddr__val [0:15];
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 fu__to_mem_wdata__msg [0:15];
  logic [0:0] fu__to_mem_wdata__rdy [0:15];
  logic [0:0] fu__to_mem_wdata__val [0:15];

  SelRTL__1a7eacb70e3ca1c4 fu__0
  (
    .clear( fu__clear[0] ),
    .clk( fu__clk[0] ),
    .ctrl_addr_inport( fu__ctrl_addr_inport[0] ),
    .reset( fu__reset[0] ),
    .from_mem_rdata__msg( fu__from_mem_rdata__msg[0] ),
    .from_mem_rdata__rdy( fu__from_mem_rdata__rdy[0] ),
    .from_mem_rdata__val( fu__from_mem_rdata__val[0] ),
    .recv_const__msg( fu__recv_const__msg[0] ),
    .recv_const__rdy( fu__recv_const__rdy[0] ),
    .recv_const__val( fu__recv_const__val[0] ),
    .recv_from_ctrl_mem__msg( fu__recv_from_ctrl_mem__msg[0] ),
    .recv_from_ctrl_mem__rdy( fu__recv_from_ctrl_mem__rdy[0] ),
    .recv_from_ctrl_mem__val( fu__recv_from_ctrl_mem__val[0] ),
    .recv_in__msg( fu__recv_in__msg[0] ),
    .recv_in__rdy( fu__recv_in__rdy[0] ),
    .recv_in__val( fu__recv_in__val[0] ),
    .recv_opt__msg( fu__recv_opt__msg[0] ),
    .recv_opt__rdy( fu__recv_opt__rdy[0] ),
    .recv_opt__val( fu__recv_opt__val[0] ),
    .send_out__msg( fu__send_out__msg[0] ),
    .send_out__rdy( fu__send_out__rdy[0] ),
    .send_out__val( fu__send_out__val[0] ),
    .send_to_ctrl_mem__msg( fu__send_to_ctrl_mem__msg[0] ),
    .send_to_ctrl_mem__rdy( fu__send_to_ctrl_mem__rdy[0] ),
    .send_to_ctrl_mem__val( fu__send_to_ctrl_mem__val[0] ),
    .to_mem_raddr__msg( fu__to_mem_raddr__msg[0] ),
    .to_mem_raddr__rdy( fu__to_mem_raddr__rdy[0] ),
    .to_mem_raddr__val( fu__to_mem_raddr__val[0] ),
    .to_mem_waddr__msg( fu__to_mem_waddr__msg[0] ),
    .to_mem_waddr__rdy( fu__to_mem_waddr__rdy[0] ),
    .to_mem_waddr__val( fu__to_mem_waddr__val[0] ),
    .to_mem_wdata__msg( fu__to_mem_wdata__msg[0] ),
    .to_mem_wdata__rdy( fu__to_mem_wdata__rdy[0] ),
    .to_mem_wdata__val( fu__to_mem_wdata__val[0] )
  );

  FpAddRTL__989701b477aa86f0 fu__1
  (
    .clear( fu__clear[1] ),
    .clk( fu__clk[1] ),
    .ctrl_addr_inport( fu__ctrl_addr_inport[1] ),
    .reset( fu__reset[1] ),
    .from_mem_rdata__msg( fu__from_mem_rdata__msg[1] ),
    .from_mem_rdata__rdy( fu__from_mem_rdata__rdy[1] ),
    .from_mem_rdata__val( fu__from_mem_rdata__val[1] ),
    .recv_const__msg( fu__recv_const__msg[1] ),
    .recv_const__rdy( fu__recv_const__rdy[1] ),
    .recv_const__val( fu__recv_const__val[1] ),
    .recv_from_ctrl_mem__msg( fu__recv_from_ctrl_mem__msg[1] ),
    .recv_from_ctrl_mem__rdy( fu__recv_from_ctrl_mem__rdy[1] ),
    .recv_from_ctrl_mem__val( fu__recv_from_ctrl_mem__val[1] ),
    .recv_in__msg( fu__recv_in__msg[1] ),
    .recv_in__rdy( fu__recv_in__rdy[1] ),
    .recv_in__val( fu__recv_in__val[1] ),
    .recv_opt__msg( fu__recv_opt__msg[1] ),
    .recv_opt__rdy( fu__recv_opt__rdy[1] ),
    .recv_opt__val( fu__recv_opt__val[1] ),
    .send_out__msg( fu__send_out__msg[1] ),
    .send_out__rdy( fu__send_out__rdy[1] ),
    .send_out__val( fu__send_out__val[1] ),
    .send_to_ctrl_mem__msg( fu__send_to_ctrl_mem__msg[1] ),
    .send_to_ctrl_mem__rdy( fu__send_to_ctrl_mem__rdy[1] ),
    .send_to_ctrl_mem__val( fu__send_to_ctrl_mem__val[1] ),
    .to_mem_raddr__msg( fu__to_mem_raddr__msg[1] ),
    .to_mem_raddr__rdy( fu__to_mem_raddr__rdy[1] ),
    .to_mem_raddr__val( fu__to_mem_raddr__val[1] ),
    .to_mem_waddr__msg( fu__to_mem_waddr__msg[1] ),
    .to_mem_waddr__rdy( fu__to_mem_waddr__rdy[1] ),
    .to_mem_waddr__val( fu__to_mem_waddr__val[1] ),
    .to_mem_wdata__msg( fu__to_mem_wdata__msg[1] ),
    .to_mem_wdata__rdy( fu__to_mem_wdata__rdy[1] ),
    .to_mem_wdata__val( fu__to_mem_wdata__val[1] )
  );

  MulRTL__1a7eacb70e3ca1c4 fu__2
  (
    .clear( fu__clear[2] ),
    .clk( fu__clk[2] ),
    .ctrl_addr_inport( fu__ctrl_addr_inport[2] ),
    .reset( fu__reset[2] ),
    .from_mem_rdata__msg( fu__from_mem_rdata__msg[2] ),
    .from_mem_rdata__rdy( fu__from_mem_rdata__rdy[2] ),
    .from_mem_rdata__val( fu__from_mem_rdata__val[2] ),
    .recv_const__msg( fu__recv_const__msg[2] ),
    .recv_const__rdy( fu__recv_const__rdy[2] ),
    .recv_const__val( fu__recv_const__val[2] ),
    .recv_from_ctrl_mem__msg( fu__recv_from_ctrl_mem__msg[2] ),
    .recv_from_ctrl_mem__rdy( fu__recv_from_ctrl_mem__rdy[2] ),
    .recv_from_ctrl_mem__val( fu__recv_from_ctrl_mem__val[2] ),
    .recv_in__msg( fu__recv_in__msg[2] ),
    .recv_in__rdy( fu__recv_in__rdy[2] ),
    .recv_in__val( fu__recv_in__val[2] ),
    .recv_opt__msg( fu__recv_opt__msg[2] ),
    .recv_opt__rdy( fu__recv_opt__rdy[2] ),
    .recv_opt__val( fu__recv_opt__val[2] ),
    .send_out__msg( fu__send_out__msg[2] ),
    .send_out__rdy( fu__send_out__rdy[2] ),
    .send_out__val( fu__send_out__val[2] ),
    .send_to_ctrl_mem__msg( fu__send_to_ctrl_mem__msg[2] ),
    .send_to_ctrl_mem__rdy( fu__send_to_ctrl_mem__rdy[2] ),
    .send_to_ctrl_mem__val( fu__send_to_ctrl_mem__val[2] ),
    .to_mem_raddr__msg( fu__to_mem_raddr__msg[2] ),
    .to_mem_raddr__rdy( fu__to_mem_raddr__rdy[2] ),
    .to_mem_raddr__val( fu__to_mem_raddr__val[2] ),
    .to_mem_waddr__msg( fu__to_mem_waddr__msg[2] ),
    .to_mem_waddr__rdy( fu__to_mem_waddr__rdy[2] ),
    .to_mem_waddr__val( fu__to_mem_waddr__val[2] ),
    .to_mem_wdata__msg( fu__to_mem_wdata__msg[2] ),
    .to_mem_wdata__rdy( fu__to_mem_wdata__rdy[2] ),
    .to_mem_wdata__val( fu__to_mem_wdata__val[2] )
  );

  LoopControlRTL__1a7eacb70e3ca1c4 fu__3
  (
    .clear( fu__clear[3] ),
    .clk( fu__clk[3] ),
    .ctrl_addr_inport( fu__ctrl_addr_inport[3] ),
    .reset( fu__reset[3] ),
    .from_mem_rdata__msg( fu__from_mem_rdata__msg[3] ),
    .from_mem_rdata__rdy( fu__from_mem_rdata__rdy[3] ),
    .from_mem_rdata__val( fu__from_mem_rdata__val[3] ),
    .recv_const__msg( fu__recv_const__msg[3] ),
    .recv_const__rdy( fu__recv_const__rdy[3] ),
    .recv_const__val( fu__recv_const__val[3] ),
    .recv_from_ctrl_mem__msg( fu__recv_from_ctrl_mem__msg[3] ),
    .recv_from_ctrl_mem__rdy( fu__recv_from_ctrl_mem__rdy[3] ),
    .recv_from_ctrl_mem__val( fu__recv_from_ctrl_mem__val[3] ),
    .recv_in__msg( fu__recv_in__msg[3] ),
    .recv_in__rdy( fu__recv_in__rdy[3] ),
    .recv_in__val( fu__recv_in__val[3] ),
    .recv_opt__msg( fu__recv_opt__msg[3] ),
    .recv_opt__rdy( fu__recv_opt__rdy[3] ),
    .recv_opt__val( fu__recv_opt__val[3] ),
    .send_out__msg( fu__send_out__msg[3] ),
    .send_out__rdy( fu__send_out__rdy[3] ),
    .send_out__val( fu__send_out__val[3] ),
    .send_to_ctrl_mem__msg( fu__send_to_ctrl_mem__msg[3] ),
    .send_to_ctrl_mem__rdy( fu__send_to_ctrl_mem__rdy[3] ),
    .send_to_ctrl_mem__val( fu__send_to_ctrl_mem__val[3] ),
    .to_mem_raddr__msg( fu__to_mem_raddr__msg[3] ),
    .to_mem_raddr__rdy( fu__to_mem_raddr__rdy[3] ),
    .to_mem_raddr__val( fu__to_mem_raddr__val[3] ),
    .to_mem_waddr__msg( fu__to_mem_waddr__msg[3] ),
    .to_mem_waddr__rdy( fu__to_mem_waddr__rdy[3] ),
    .to_mem_waddr__val( fu__to_mem_waddr__val[3] ),
    .to_mem_wdata__msg( fu__to_mem_wdata__msg[3] ),
    .to_mem_wdata__rdy( fu__to_mem_wdata__rdy[3] ),
    .to_mem_wdata__val( fu__to_mem_wdata__val[3] )
  );

  RetRTL__1a7eacb70e3ca1c4 fu__4
  (
    .clear( fu__clear[4] ),
    .clk( fu__clk[4] ),
    .ctrl_addr_inport( fu__ctrl_addr_inport[4] ),
    .reset( fu__reset[4] ),
    .from_mem_rdata__msg( fu__from_mem_rdata__msg[4] ),
    .from_mem_rdata__rdy( fu__from_mem_rdata__rdy[4] ),
    .from_mem_rdata__val( fu__from_mem_rdata__val[4] ),
    .recv_const__msg( fu__recv_const__msg[4] ),
    .recv_const__rdy( fu__recv_const__rdy[4] ),
    .recv_const__val( fu__recv_const__val[4] ),
    .recv_from_ctrl_mem__msg( fu__recv_from_ctrl_mem__msg[4] ),
    .recv_from_ctrl_mem__rdy( fu__recv_from_ctrl_mem__rdy[4] ),
    .recv_from_ctrl_mem__val( fu__recv_from_ctrl_mem__val[4] ),
    .recv_in__msg( fu__recv_in__msg[4] ),
    .recv_in__rdy( fu__recv_in__rdy[4] ),
    .recv_in__val( fu__recv_in__val[4] ),
    .recv_opt__msg( fu__recv_opt__msg[4] ),
    .recv_opt__rdy( fu__recv_opt__rdy[4] ),
    .recv_opt__val( fu__recv_opt__val[4] ),
    .send_out__msg( fu__send_out__msg[4] ),
    .send_out__rdy( fu__send_out__rdy[4] ),
    .send_out__val( fu__send_out__val[4] ),
    .send_to_ctrl_mem__msg( fu__send_to_ctrl_mem__msg[4] ),
    .send_to_ctrl_mem__rdy( fu__send_to_ctrl_mem__rdy[4] ),
    .send_to_ctrl_mem__val( fu__send_to_ctrl_mem__val[4] ),
    .to_mem_raddr__msg( fu__to_mem_raddr__msg[4] ),
    .to_mem_raddr__rdy( fu__to_mem_raddr__rdy[4] ),
    .to_mem_raddr__val( fu__to_mem_raddr__val[4] ),
    .to_mem_waddr__msg( fu__to_mem_waddr__msg[4] ),
    .to_mem_waddr__rdy( fu__to_mem_waddr__rdy[4] ),
    .to_mem_waddr__val( fu__to_mem_waddr__val[4] ),
    .to_mem_wdata__msg( fu__to_mem_wdata__msg[4] ),
    .to_mem_wdata__rdy( fu__to_mem_wdata__rdy[4] ),
    .to_mem_wdata__val( fu__to_mem_wdata__val[4] )
  );

  ExclusiveDivRTL__0770bc9caceb7e60 fu__5
  (
    .clear( fu__clear[5] ),
    .clk( fu__clk[5] ),
    .ctrl_addr_inport( fu__ctrl_addr_inport[5] ),
    .reset( fu__reset[5] ),
    .from_mem_rdata__msg( fu__from_mem_rdata__msg[5] ),
    .from_mem_rdata__rdy( fu__from_mem_rdata__rdy[5] ),
    .from_mem_rdata__val( fu__from_mem_rdata__val[5] ),
    .recv_const__msg( fu__recv_const__msg[5] ),
    .recv_const__rdy( fu__recv_const__rdy[5] ),
    .recv_const__val( fu__recv_const__val[5] ),
    .recv_from_ctrl_mem__msg( fu__recv_from_ctrl_mem__msg[5] ),
    .recv_from_ctrl_mem__rdy( fu__recv_from_ctrl_mem__rdy[5] ),
    .recv_from_ctrl_mem__val( fu__recv_from_ctrl_mem__val[5] ),
    .recv_in__msg( fu__recv_in__msg[5] ),
    .recv_in__rdy( fu__recv_in__rdy[5] ),
    .recv_in__val( fu__recv_in__val[5] ),
    .recv_opt__msg( fu__recv_opt__msg[5] ),
    .recv_opt__rdy( fu__recv_opt__rdy[5] ),
    .recv_opt__val( fu__recv_opt__val[5] ),
    .send_out__msg( fu__send_out__msg[5] ),
    .send_out__rdy( fu__send_out__rdy[5] ),
    .send_out__val( fu__send_out__val[5] ),
    .send_to_ctrl_mem__msg( fu__send_to_ctrl_mem__msg[5] ),
    .send_to_ctrl_mem__rdy( fu__send_to_ctrl_mem__rdy[5] ),
    .send_to_ctrl_mem__val( fu__send_to_ctrl_mem__val[5] ),
    .to_mem_raddr__msg( fu__to_mem_raddr__msg[5] ),
    .to_mem_raddr__rdy( fu__to_mem_raddr__rdy[5] ),
    .to_mem_raddr__val( fu__to_mem_raddr__val[5] ),
    .to_mem_waddr__msg( fu__to_mem_waddr__msg[5] ),
    .to_mem_waddr__rdy( fu__to_mem_waddr__rdy[5] ),
    .to_mem_waddr__val( fu__to_mem_waddr__val[5] ),
    .to_mem_wdata__msg( fu__to_mem_wdata__msg[5] ),
    .to_mem_wdata__rdy( fu__to_mem_wdata__rdy[5] ),
    .to_mem_wdata__val( fu__to_mem_wdata__val[5] )
  );

  AdderRTL__1a7eacb70e3ca1c4 fu__6
  (
    .clear( fu__clear[6] ),
    .clk( fu__clk[6] ),
    .ctrl_addr_inport( fu__ctrl_addr_inport[6] ),
    .reset( fu__reset[6] ),
    .from_mem_rdata__msg( fu__from_mem_rdata__msg[6] ),
    .from_mem_rdata__rdy( fu__from_mem_rdata__rdy[6] ),
    .from_mem_rdata__val( fu__from_mem_rdata__val[6] ),
    .recv_const__msg( fu__recv_const__msg[6] ),
    .recv_const__rdy( fu__recv_const__rdy[6] ),
    .recv_const__val( fu__recv_const__val[6] ),
    .recv_from_ctrl_mem__msg( fu__recv_from_ctrl_mem__msg[6] ),
    .recv_from_ctrl_mem__rdy( fu__recv_from_ctrl_mem__rdy[6] ),
    .recv_from_ctrl_mem__val( fu__recv_from_ctrl_mem__val[6] ),
    .recv_in__msg( fu__recv_in__msg[6] ),
    .recv_in__rdy( fu__recv_in__rdy[6] ),
    .recv_in__val( fu__recv_in__val[6] ),
    .recv_opt__msg( fu__recv_opt__msg[6] ),
    .recv_opt__rdy( fu__recv_opt__rdy[6] ),
    .recv_opt__val( fu__recv_opt__val[6] ),
    .send_out__msg( fu__send_out__msg[6] ),
    .send_out__rdy( fu__send_out__rdy[6] ),
    .send_out__val( fu__send_out__val[6] ),
    .send_to_ctrl_mem__msg( fu__send_to_ctrl_mem__msg[6] ),
    .send_to_ctrl_mem__rdy( fu__send_to_ctrl_mem__rdy[6] ),
    .send_to_ctrl_mem__val( fu__send_to_ctrl_mem__val[6] ),
    .to_mem_raddr__msg( fu__to_mem_raddr__msg[6] ),
    .to_mem_raddr__rdy( fu__to_mem_raddr__rdy[6] ),
    .to_mem_raddr__val( fu__to_mem_raddr__val[6] ),
    .to_mem_waddr__msg( fu__to_mem_waddr__msg[6] ),
    .to_mem_waddr__rdy( fu__to_mem_waddr__rdy[6] ),
    .to_mem_waddr__val( fu__to_mem_waddr__val[6] ),
    .to_mem_wdata__msg( fu__to_mem_wdata__msg[6] ),
    .to_mem_wdata__rdy( fu__to_mem_wdata__rdy[6] ),
    .to_mem_wdata__val( fu__to_mem_wdata__val[6] )
  );

  MemUnitRTL__1a7eacb70e3ca1c4 fu__7
  (
    .clear( fu__clear[7] ),
    .clk( fu__clk[7] ),
    .ctrl_addr_inport( fu__ctrl_addr_inport[7] ),
    .reset( fu__reset[7] ),
    .from_mem_rdata__msg( fu__from_mem_rdata__msg[7] ),
    .from_mem_rdata__rdy( fu__from_mem_rdata__rdy[7] ),
    .from_mem_rdata__val( fu__from_mem_rdata__val[7] ),
    .recv_const__msg( fu__recv_const__msg[7] ),
    .recv_const__rdy( fu__recv_const__rdy[7] ),
    .recv_const__val( fu__recv_const__val[7] ),
    .recv_from_ctrl_mem__msg( fu__recv_from_ctrl_mem__msg[7] ),
    .recv_from_ctrl_mem__rdy( fu__recv_from_ctrl_mem__rdy[7] ),
    .recv_from_ctrl_mem__val( fu__recv_from_ctrl_mem__val[7] ),
    .recv_in__msg( fu__recv_in__msg[7] ),
    .recv_in__rdy( fu__recv_in__rdy[7] ),
    .recv_in__val( fu__recv_in__val[7] ),
    .recv_opt__msg( fu__recv_opt__msg[7] ),
    .recv_opt__rdy( fu__recv_opt__rdy[7] ),
    .recv_opt__val( fu__recv_opt__val[7] ),
    .send_out__msg( fu__send_out__msg[7] ),
    .send_out__rdy( fu__send_out__rdy[7] ),
    .send_out__val( fu__send_out__val[7] ),
    .send_to_ctrl_mem__msg( fu__send_to_ctrl_mem__msg[7] ),
    .send_to_ctrl_mem__rdy( fu__send_to_ctrl_mem__rdy[7] ),
    .send_to_ctrl_mem__val( fu__send_to_ctrl_mem__val[7] ),
    .to_mem_raddr__msg( fu__to_mem_raddr__msg[7] ),
    .to_mem_raddr__rdy( fu__to_mem_raddr__rdy[7] ),
    .to_mem_raddr__val( fu__to_mem_raddr__val[7] ),
    .to_mem_waddr__msg( fu__to_mem_waddr__msg[7] ),
    .to_mem_waddr__rdy( fu__to_mem_waddr__rdy[7] ),
    .to_mem_waddr__val( fu__to_mem_waddr__val[7] ),
    .to_mem_wdata__msg( fu__to_mem_wdata__msg[7] ),
    .to_mem_wdata__rdy( fu__to_mem_wdata__rdy[7] ),
    .to_mem_wdata__val( fu__to_mem_wdata__val[7] )
  );

  FpMulRTL__989701b477aa86f0 fu__8
  (
    .clear( fu__clear[8] ),
    .clk( fu__clk[8] ),
    .ctrl_addr_inport( fu__ctrl_addr_inport[8] ),
    .reset( fu__reset[8] ),
    .from_mem_rdata__msg( fu__from_mem_rdata__msg[8] ),
    .from_mem_rdata__rdy( fu__from_mem_rdata__rdy[8] ),
    .from_mem_rdata__val( fu__from_mem_rdata__val[8] ),
    .recv_const__msg( fu__recv_const__msg[8] ),
    .recv_const__rdy( fu__recv_const__rdy[8] ),
    .recv_const__val( fu__recv_const__val[8] ),
    .recv_from_ctrl_mem__msg( fu__recv_from_ctrl_mem__msg[8] ),
    .recv_from_ctrl_mem__rdy( fu__recv_from_ctrl_mem__rdy[8] ),
    .recv_from_ctrl_mem__val( fu__recv_from_ctrl_mem__val[8] ),
    .recv_in__msg( fu__recv_in__msg[8] ),
    .recv_in__rdy( fu__recv_in__rdy[8] ),
    .recv_in__val( fu__recv_in__val[8] ),
    .recv_opt__msg( fu__recv_opt__msg[8] ),
    .recv_opt__rdy( fu__recv_opt__rdy[8] ),
    .recv_opt__val( fu__recv_opt__val[8] ),
    .send_out__msg( fu__send_out__msg[8] ),
    .send_out__rdy( fu__send_out__rdy[8] ),
    .send_out__val( fu__send_out__val[8] ),
    .send_to_ctrl_mem__msg( fu__send_to_ctrl_mem__msg[8] ),
    .send_to_ctrl_mem__rdy( fu__send_to_ctrl_mem__rdy[8] ),
    .send_to_ctrl_mem__val( fu__send_to_ctrl_mem__val[8] ),
    .to_mem_raddr__msg( fu__to_mem_raddr__msg[8] ),
    .to_mem_raddr__rdy( fu__to_mem_raddr__rdy[8] ),
    .to_mem_raddr__val( fu__to_mem_raddr__val[8] ),
    .to_mem_waddr__msg( fu__to_mem_waddr__msg[8] ),
    .to_mem_waddr__rdy( fu__to_mem_waddr__rdy[8] ),
    .to_mem_waddr__val( fu__to_mem_waddr__val[8] ),
    .to_mem_wdata__msg( fu__to_mem_wdata__msg[8] ),
    .to_mem_wdata__rdy( fu__to_mem_wdata__rdy[8] ),
    .to_mem_wdata__val( fu__to_mem_wdata__val[8] )
  );

  GrantRTL__1a7eacb70e3ca1c4 fu__9
  (
    .clear( fu__clear[9] ),
    .clk( fu__clk[9] ),
    .ctrl_addr_inport( fu__ctrl_addr_inport[9] ),
    .reset( fu__reset[9] ),
    .from_mem_rdata__msg( fu__from_mem_rdata__msg[9] ),
    .from_mem_rdata__rdy( fu__from_mem_rdata__rdy[9] ),
    .from_mem_rdata__val( fu__from_mem_rdata__val[9] ),
    .recv_const__msg( fu__recv_const__msg[9] ),
    .recv_const__rdy( fu__recv_const__rdy[9] ),
    .recv_const__val( fu__recv_const__val[9] ),
    .recv_from_ctrl_mem__msg( fu__recv_from_ctrl_mem__msg[9] ),
    .recv_from_ctrl_mem__rdy( fu__recv_from_ctrl_mem__rdy[9] ),
    .recv_from_ctrl_mem__val( fu__recv_from_ctrl_mem__val[9] ),
    .recv_in__msg( fu__recv_in__msg[9] ),
    .recv_in__rdy( fu__recv_in__rdy[9] ),
    .recv_in__val( fu__recv_in__val[9] ),
    .recv_opt__msg( fu__recv_opt__msg[9] ),
    .recv_opt__rdy( fu__recv_opt__rdy[9] ),
    .recv_opt__val( fu__recv_opt__val[9] ),
    .send_out__msg( fu__send_out__msg[9] ),
    .send_out__rdy( fu__send_out__rdy[9] ),
    .send_out__val( fu__send_out__val[9] ),
    .send_to_ctrl_mem__msg( fu__send_to_ctrl_mem__msg[9] ),
    .send_to_ctrl_mem__rdy( fu__send_to_ctrl_mem__rdy[9] ),
    .send_to_ctrl_mem__val( fu__send_to_ctrl_mem__val[9] ),
    .to_mem_raddr__msg( fu__to_mem_raddr__msg[9] ),
    .to_mem_raddr__rdy( fu__to_mem_raddr__rdy[9] ),
    .to_mem_raddr__val( fu__to_mem_raddr__val[9] ),
    .to_mem_waddr__msg( fu__to_mem_waddr__msg[9] ),
    .to_mem_waddr__rdy( fu__to_mem_waddr__rdy[9] ),
    .to_mem_waddr__val( fu__to_mem_waddr__val[9] ),
    .to_mem_wdata__msg( fu__to_mem_wdata__msg[9] ),
    .to_mem_wdata__rdy( fu__to_mem_wdata__rdy[9] ),
    .to_mem_wdata__val( fu__to_mem_wdata__val[9] )
  );

  CompRTL__1a7eacb70e3ca1c4 fu__10
  (
    .clear( fu__clear[10] ),
    .clk( fu__clk[10] ),
    .ctrl_addr_inport( fu__ctrl_addr_inport[10] ),
    .reset( fu__reset[10] ),
    .from_mem_rdata__msg( fu__from_mem_rdata__msg[10] ),
    .from_mem_rdata__rdy( fu__from_mem_rdata__rdy[10] ),
    .from_mem_rdata__val( fu__from_mem_rdata__val[10] ),
    .recv_const__msg( fu__recv_const__msg[10] ),
    .recv_const__rdy( fu__recv_const__rdy[10] ),
    .recv_const__val( fu__recv_const__val[10] ),
    .recv_from_ctrl_mem__msg( fu__recv_from_ctrl_mem__msg[10] ),
    .recv_from_ctrl_mem__rdy( fu__recv_from_ctrl_mem__rdy[10] ),
    .recv_from_ctrl_mem__val( fu__recv_from_ctrl_mem__val[10] ),
    .recv_in__msg( fu__recv_in__msg[10] ),
    .recv_in__rdy( fu__recv_in__rdy[10] ),
    .recv_in__val( fu__recv_in__val[10] ),
    .recv_opt__msg( fu__recv_opt__msg[10] ),
    .recv_opt__rdy( fu__recv_opt__rdy[10] ),
    .recv_opt__val( fu__recv_opt__val[10] ),
    .send_out__msg( fu__send_out__msg[10] ),
    .send_out__rdy( fu__send_out__rdy[10] ),
    .send_out__val( fu__send_out__val[10] ),
    .send_to_ctrl_mem__msg( fu__send_to_ctrl_mem__msg[10] ),
    .send_to_ctrl_mem__rdy( fu__send_to_ctrl_mem__rdy[10] ),
    .send_to_ctrl_mem__val( fu__send_to_ctrl_mem__val[10] ),
    .to_mem_raddr__msg( fu__to_mem_raddr__msg[10] ),
    .to_mem_raddr__rdy( fu__to_mem_raddr__rdy[10] ),
    .to_mem_raddr__val( fu__to_mem_raddr__val[10] ),
    .to_mem_waddr__msg( fu__to_mem_waddr__msg[10] ),
    .to_mem_waddr__rdy( fu__to_mem_waddr__rdy[10] ),
    .to_mem_waddr__val( fu__to_mem_waddr__val[10] ),
    .to_mem_wdata__msg( fu__to_mem_wdata__msg[10] ),
    .to_mem_wdata__rdy( fu__to_mem_wdata__rdy[10] ),
    .to_mem_wdata__val( fu__to_mem_wdata__val[10] )
  );

  ShifterRTL__1a7eacb70e3ca1c4 fu__11
  (
    .clear( fu__clear[11] ),
    .clk( fu__clk[11] ),
    .ctrl_addr_inport( fu__ctrl_addr_inport[11] ),
    .reset( fu__reset[11] ),
    .from_mem_rdata__msg( fu__from_mem_rdata__msg[11] ),
    .from_mem_rdata__rdy( fu__from_mem_rdata__rdy[11] ),
    .from_mem_rdata__val( fu__from_mem_rdata__val[11] ),
    .recv_const__msg( fu__recv_const__msg[11] ),
    .recv_const__rdy( fu__recv_const__rdy[11] ),
    .recv_const__val( fu__recv_const__val[11] ),
    .recv_from_ctrl_mem__msg( fu__recv_from_ctrl_mem__msg[11] ),
    .recv_from_ctrl_mem__rdy( fu__recv_from_ctrl_mem__rdy[11] ),
    .recv_from_ctrl_mem__val( fu__recv_from_ctrl_mem__val[11] ),
    .recv_in__msg( fu__recv_in__msg[11] ),
    .recv_in__rdy( fu__recv_in__rdy[11] ),
    .recv_in__val( fu__recv_in__val[11] ),
    .recv_opt__msg( fu__recv_opt__msg[11] ),
    .recv_opt__rdy( fu__recv_opt__rdy[11] ),
    .recv_opt__val( fu__recv_opt__val[11] ),
    .send_out__msg( fu__send_out__msg[11] ),
    .send_out__rdy( fu__send_out__rdy[11] ),
    .send_out__val( fu__send_out__val[11] ),
    .send_to_ctrl_mem__msg( fu__send_to_ctrl_mem__msg[11] ),
    .send_to_ctrl_mem__rdy( fu__send_to_ctrl_mem__rdy[11] ),
    .send_to_ctrl_mem__val( fu__send_to_ctrl_mem__val[11] ),
    .to_mem_raddr__msg( fu__to_mem_raddr__msg[11] ),
    .to_mem_raddr__rdy( fu__to_mem_raddr__rdy[11] ),
    .to_mem_raddr__val( fu__to_mem_raddr__val[11] ),
    .to_mem_waddr__msg( fu__to_mem_waddr__msg[11] ),
    .to_mem_waddr__rdy( fu__to_mem_waddr__rdy[11] ),
    .to_mem_waddr__val( fu__to_mem_waddr__val[11] ),
    .to_mem_wdata__msg( fu__to_mem_wdata__msg[11] ),
    .to_mem_wdata__rdy( fu__to_mem_wdata__rdy[11] ),
    .to_mem_wdata__val( fu__to_mem_wdata__val[11] )
  );

  PhiRTL__1a7eacb70e3ca1c4 fu__12
  (
    .clear( fu__clear[12] ),
    .clk( fu__clk[12] ),
    .ctrl_addr_inport( fu__ctrl_addr_inport[12] ),
    .reset( fu__reset[12] ),
    .from_mem_rdata__msg( fu__from_mem_rdata__msg[12] ),
    .from_mem_rdata__rdy( fu__from_mem_rdata__rdy[12] ),
    .from_mem_rdata__val( fu__from_mem_rdata__val[12] ),
    .recv_const__msg( fu__recv_const__msg[12] ),
    .recv_const__rdy( fu__recv_const__rdy[12] ),
    .recv_const__val( fu__recv_const__val[12] ),
    .recv_from_ctrl_mem__msg( fu__recv_from_ctrl_mem__msg[12] ),
    .recv_from_ctrl_mem__rdy( fu__recv_from_ctrl_mem__rdy[12] ),
    .recv_from_ctrl_mem__val( fu__recv_from_ctrl_mem__val[12] ),
    .recv_in__msg( fu__recv_in__msg[12] ),
    .recv_in__rdy( fu__recv_in__rdy[12] ),
    .recv_in__val( fu__recv_in__val[12] ),
    .recv_opt__msg( fu__recv_opt__msg[12] ),
    .recv_opt__rdy( fu__recv_opt__rdy[12] ),
    .recv_opt__val( fu__recv_opt__val[12] ),
    .send_out__msg( fu__send_out__msg[12] ),
    .send_out__rdy( fu__send_out__rdy[12] ),
    .send_out__val( fu__send_out__val[12] ),
    .send_to_ctrl_mem__msg( fu__send_to_ctrl_mem__msg[12] ),
    .send_to_ctrl_mem__rdy( fu__send_to_ctrl_mem__rdy[12] ),
    .send_to_ctrl_mem__val( fu__send_to_ctrl_mem__val[12] ),
    .to_mem_raddr__msg( fu__to_mem_raddr__msg[12] ),
    .to_mem_raddr__rdy( fu__to_mem_raddr__rdy[12] ),
    .to_mem_raddr__val( fu__to_mem_raddr__val[12] ),
    .to_mem_waddr__msg( fu__to_mem_waddr__msg[12] ),
    .to_mem_waddr__rdy( fu__to_mem_waddr__rdy[12] ),
    .to_mem_waddr__val( fu__to_mem_waddr__val[12] ),
    .to_mem_wdata__msg( fu__to_mem_wdata__msg[12] ),
    .to_mem_wdata__rdy( fu__to_mem_wdata__rdy[12] ),
    .to_mem_wdata__val( fu__to_mem_wdata__val[12] )
  );

  LogicRTL__1a7eacb70e3ca1c4 fu__13
  (
    .clear( fu__clear[13] ),
    .clk( fu__clk[13] ),
    .ctrl_addr_inport( fu__ctrl_addr_inport[13] ),
    .reset( fu__reset[13] ),
    .from_mem_rdata__msg( fu__from_mem_rdata__msg[13] ),
    .from_mem_rdata__rdy( fu__from_mem_rdata__rdy[13] ),
    .from_mem_rdata__val( fu__from_mem_rdata__val[13] ),
    .recv_const__msg( fu__recv_const__msg[13] ),
    .recv_const__rdy( fu__recv_const__rdy[13] ),
    .recv_const__val( fu__recv_const__val[13] ),
    .recv_from_ctrl_mem__msg( fu__recv_from_ctrl_mem__msg[13] ),
    .recv_from_ctrl_mem__rdy( fu__recv_from_ctrl_mem__rdy[13] ),
    .recv_from_ctrl_mem__val( fu__recv_from_ctrl_mem__val[13] ),
    .recv_in__msg( fu__recv_in__msg[13] ),
    .recv_in__rdy( fu__recv_in__rdy[13] ),
    .recv_in__val( fu__recv_in__val[13] ),
    .recv_opt__msg( fu__recv_opt__msg[13] ),
    .recv_opt__rdy( fu__recv_opt__rdy[13] ),
    .recv_opt__val( fu__recv_opt__val[13] ),
    .send_out__msg( fu__send_out__msg[13] ),
    .send_out__rdy( fu__send_out__rdy[13] ),
    .send_out__val( fu__send_out__val[13] ),
    .send_to_ctrl_mem__msg( fu__send_to_ctrl_mem__msg[13] ),
    .send_to_ctrl_mem__rdy( fu__send_to_ctrl_mem__rdy[13] ),
    .send_to_ctrl_mem__val( fu__send_to_ctrl_mem__val[13] ),
    .to_mem_raddr__msg( fu__to_mem_raddr__msg[13] ),
    .to_mem_raddr__rdy( fu__to_mem_raddr__rdy[13] ),
    .to_mem_raddr__val( fu__to_mem_raddr__val[13] ),
    .to_mem_waddr__msg( fu__to_mem_waddr__msg[13] ),
    .to_mem_waddr__rdy( fu__to_mem_waddr__rdy[13] ),
    .to_mem_waddr__val( fu__to_mem_waddr__val[13] ),
    .to_mem_wdata__msg( fu__to_mem_wdata__msg[13] ),
    .to_mem_wdata__rdy( fu__to_mem_wdata__rdy[13] ),
    .to_mem_wdata__val( fu__to_mem_wdata__val[13] )
  );

  ConstRTL__1a7eacb70e3ca1c4 fu__14
  (
    .clear( fu__clear[14] ),
    .clk( fu__clk[14] ),
    .ctrl_addr_inport( fu__ctrl_addr_inport[14] ),
    .reset( fu__reset[14] ),
    .from_mem_rdata__msg( fu__from_mem_rdata__msg[14] ),
    .from_mem_rdata__rdy( fu__from_mem_rdata__rdy[14] ),
    .from_mem_rdata__val( fu__from_mem_rdata__val[14] ),
    .recv_const__msg( fu__recv_const__msg[14] ),
    .recv_const__rdy( fu__recv_const__rdy[14] ),
    .recv_const__val( fu__recv_const__val[14] ),
    .recv_from_ctrl_mem__msg( fu__recv_from_ctrl_mem__msg[14] ),
    .recv_from_ctrl_mem__rdy( fu__recv_from_ctrl_mem__rdy[14] ),
    .recv_from_ctrl_mem__val( fu__recv_from_ctrl_mem__val[14] ),
    .recv_in__msg( fu__recv_in__msg[14] ),
    .recv_in__rdy( fu__recv_in__rdy[14] ),
    .recv_in__val( fu__recv_in__val[14] ),
    .recv_opt__msg( fu__recv_opt__msg[14] ),
    .recv_opt__rdy( fu__recv_opt__rdy[14] ),
    .recv_opt__val( fu__recv_opt__val[14] ),
    .send_out__msg( fu__send_out__msg[14] ),
    .send_out__rdy( fu__send_out__rdy[14] ),
    .send_out__val( fu__send_out__val[14] ),
    .send_to_ctrl_mem__msg( fu__send_to_ctrl_mem__msg[14] ),
    .send_to_ctrl_mem__rdy( fu__send_to_ctrl_mem__rdy[14] ),
    .send_to_ctrl_mem__val( fu__send_to_ctrl_mem__val[14] ),
    .to_mem_raddr__msg( fu__to_mem_raddr__msg[14] ),
    .to_mem_raddr__rdy( fu__to_mem_raddr__rdy[14] ),
    .to_mem_raddr__val( fu__to_mem_raddr__val[14] ),
    .to_mem_waddr__msg( fu__to_mem_waddr__msg[14] ),
    .to_mem_waddr__rdy( fu__to_mem_waddr__rdy[14] ),
    .to_mem_waddr__val( fu__to_mem_waddr__val[14] ),
    .to_mem_wdata__msg( fu__to_mem_wdata__msg[14] ),
    .to_mem_wdata__rdy( fu__to_mem_wdata__rdy[14] ),
    .to_mem_wdata__val( fu__to_mem_wdata__val[14] )
  );

  NahRTL__1a7eacb70e3ca1c4 fu__15
  (
    .clear( fu__clear[15] ),
    .clk( fu__clk[15] ),
    .ctrl_addr_inport( fu__ctrl_addr_inport[15] ),
    .reset( fu__reset[15] ),
    .from_mem_rdata__msg( fu__from_mem_rdata__msg[15] ),
    .from_mem_rdata__rdy( fu__from_mem_rdata__rdy[15] ),
    .from_mem_rdata__val( fu__from_mem_rdata__val[15] ),
    .recv_const__msg( fu__recv_const__msg[15] ),
    .recv_const__rdy( fu__recv_const__rdy[15] ),
    .recv_const__val( fu__recv_const__val[15] ),
    .recv_from_ctrl_mem__msg( fu__recv_from_ctrl_mem__msg[15] ),
    .recv_from_ctrl_mem__rdy( fu__recv_from_ctrl_mem__rdy[15] ),
    .recv_from_ctrl_mem__val( fu__recv_from_ctrl_mem__val[15] ),
    .recv_in__msg( fu__recv_in__msg[15] ),
    .recv_in__rdy( fu__recv_in__rdy[15] ),
    .recv_in__val( fu__recv_in__val[15] ),
    .recv_opt__msg( fu__recv_opt__msg[15] ),
    .recv_opt__rdy( fu__recv_opt__rdy[15] ),
    .recv_opt__val( fu__recv_opt__val[15] ),
    .send_out__msg( fu__send_out__msg[15] ),
    .send_out__rdy( fu__send_out__rdy[15] ),
    .send_out__val( fu__send_out__val[15] ),
    .send_to_ctrl_mem__msg( fu__send_to_ctrl_mem__msg[15] ),
    .send_to_ctrl_mem__rdy( fu__send_to_ctrl_mem__rdy[15] ),
    .send_to_ctrl_mem__val( fu__send_to_ctrl_mem__val[15] ),
    .to_mem_raddr__msg( fu__to_mem_raddr__msg[15] ),
    .to_mem_raddr__rdy( fu__to_mem_raddr__rdy[15] ),
    .to_mem_raddr__val( fu__to_mem_raddr__val[15] ),
    .to_mem_waddr__msg( fu__to_mem_waddr__msg[15] ),
    .to_mem_waddr__rdy( fu__to_mem_waddr__rdy[15] ),
    .to_mem_waddr__val( fu__to_mem_waddr__val[15] ),
    .to_mem_wdata__msg( fu__to_mem_wdata__msg[15] ),
    .to_mem_wdata__rdy( fu__to_mem_wdata__rdy[15] ),
    .to_mem_wdata__val( fu__to_mem_wdata__val[15] )
  );

  //-------------------------------------------------------------
  // End of component fu[0:15]
  //-------------------------------------------------------------

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/fu/flexible/FlexibleFuRTL.py:105
  // @update
  // def comb_logic():
  //   for j in range(num_outports):
  //     s.send_out[j].val @= b1(0)
  //     s.send_out[j].msg @= s.DataType()
  // 
  //   for i in range(s.fu_list_size):
  //     # const connection.
  //     s.fu[i].recv_const.msg @= s.recv_const.msg
  //     s.fu[i].recv_const.val @= s.recv_const.val
  //     s.fu_recv_const_rdy_vector[i] @= s.fu[i].recv_const.rdy
  // 
  //     # opt connection.
  //     s.fu[i].recv_opt.msg @= s.recv_opt.msg
  //     # Sets each FU's op code as NAH when prologue execution is not completed.
  //     # As they are supposed to do nothing during that prologue cycles.
  //     if s.prologue_count_inport != 0:
  //       s.fu[i].recv_opt.msg.operation @= OPT_NAH
  //     s.fu[i].recv_opt.val @= s.recv_opt.val
  //     s.fu_recv_opt_rdy_vector[i] @= s.fu[i].recv_opt.rdy
  // 
  //     # send_out connection.
  //     for j in range(num_outports):
  //       # FIXME: need reduce_or here: https://github.com/tancheng/VectorCGRA/issues/51.
  //       if s.fu[i].send_out[j].val:
  //         s.send_out[j].msg @= s.fu[i].send_out[j].msg
  //         s.send_out[j].val @= s.fu[i].send_out[j].val
  //       s.fu[i].send_out[j].rdy @= s.send_out[j].rdy
  // 
  //   s.recv_const.rdy @= reduce_or(s.fu_recv_const_rdy_vector)
  //   # Operation (especially mem access) won't perform more than once, because once the
  //   # operation is performance (i.e., the recv_opt.rdy would be set), the `element_done`
  //   # register would be set and be respected.
  //   s.recv_opt.rdy @= reduce_or(s.fu_recv_opt_rdy_vector) | (s.prologue_count_inport != 0)
  // 
  //   for j in range(num_inports):
  //     s.recv_in[j].rdy @= b1(0)
  // 
  //   # recv_in connection.
  //   for port in range(num_inports):
  //     for i in range(s.fu_list_size):
  //       s.fu[i].recv_in[port].msg @= s.recv_in[port].msg
  //       s.fu[i].recv_in[port].val @= s.recv_in[port].val
  //       # s.recv_in[j].rdy       @= s.fu[i].recv_in[j].rdy | s.recv_in[j].rdy
  //       s.fu_recv_in_rdy_vector[port][i] @= s.fu[i].recv_in[port].rdy
  //     s.recv_in[port].rdy @= reduce_or(s.fu_recv_in_rdy_vector[port])
  
  always_comb begin : comb_logic
    for ( int unsigned j = 1'd0; j < 2'( __const__num_outports_at_comb_logic ); j += 1'd1 ) begin
      send_out__val[1'(j)] = 1'd0;
      send_out__msg[1'(j)] = { 32'd0, 1'd0, 1'd0, 1'd0 };
    end
    for ( int unsigned i = 1'd0; i < 5'd16; i += 1'd1 ) begin
      fu__recv_const__msg[4'(i)] = recv_const__msg;
      fu__recv_const__val[4'(i)] = recv_const__val;
      fu_recv_const_rdy_vector[4'(i)] = fu__recv_const__rdy[4'(i)];
      fu__recv_opt__msg[4'(i)] = recv_opt__msg;
      if ( prologue_count_inport != 3'd0 ) begin
        fu__recv_opt__msg[4'(i)].operation = 7'( __const__OPT_NAH );
      end
      fu__recv_opt__val[4'(i)] = recv_opt__val;
      fu_recv_opt_rdy_vector[4'(i)] = fu__recv_opt__rdy[4'(i)];
      for ( int unsigned j = 1'd0; j < 2'( __const__num_outports_at_comb_logic ); j += 1'd1 ) begin
        if ( fu__send_out__val[4'(i)][1'(j)] ) begin
          send_out__msg[1'(j)] = fu__send_out__msg[4'(i)][1'(j)];
          send_out__val[1'(j)] = fu__send_out__val[4'(i)][1'(j)];
        end
        fu__send_out__rdy[4'(i)][1'(j)] = send_out__rdy[1'(j)];
      end
    end
    recv_const__rdy = ( | fu_recv_const_rdy_vector );
    recv_opt__rdy = ( | fu_recv_opt_rdy_vector ) | ( prologue_count_inport != 3'd0 );
    for ( int unsigned j = 1'd0; j < 3'( __const__num_inports_at_comb_logic ); j += 1'd1 )
      recv_in__rdy[2'(j)] = 1'd0;
    for ( int unsigned port = 1'd0; port < 3'( __const__num_inports_at_comb_logic ); port += 1'd1 ) begin
      for ( int unsigned i = 1'd0; i < 5'd16; i += 1'd1 ) begin
        fu__recv_in__msg[4'(i)][2'(port)] = recv_in__msg[2'(port)];
        fu__recv_in__val[4'(i)][2'(port)] = recv_in__val[2'(port)];
        fu_recv_in_rdy_vector[2'(port)][4'(i)] = fu__recv_in__rdy[4'(i)][2'(port)];
      end
      recv_in__rdy[2'(port)] = ( | fu_recv_in_rdy_vector[2'(port)] );
    end
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/fu/flexible/FlexibleFuRTL.py:87
  // @update
  // def connect_to_controller():
  //   for i in range(s.fu_list_size):
  //     # const connection.
  //     s.fu[i].recv_from_ctrl_mem.msg @= s.recv_from_ctrl_mem.msg
  //     s.fu[i].recv_from_ctrl_mem.val @= s.recv_from_ctrl_mem.val
  //     s.recv_from_controller_rdy_vector[i] @= s.fu[i].recv_from_ctrl_mem.rdy
  //   s.recv_from_ctrl_mem.rdy @= reduce_or(s.recv_from_controller_rdy_vector)
  // 
  //   s.send_to_ctrl_mem.msg @= s.CgraPayloadType(0, 0, 0, 0, 0)
  //   s.send_to_ctrl_mem.val @= 0
  //   for i in range(s.fu_list_size):
  //     if s.fu[i].send_to_ctrl_mem.val:
  //       s.send_to_ctrl_mem.msg @= s.fu[i].send_to_ctrl_mem.msg
  //       s.send_to_ctrl_mem.val @= s.fu[i].send_to_ctrl_mem.val
  //     s.fu[i].send_to_ctrl_mem.rdy @= s.send_to_ctrl_mem.rdy
  //     s.fu[i].ctrl_addr_inport @= s.ctrl_addr_inport
  
  always_comb begin : connect_to_controller
    for ( int unsigned i = 1'd0; i < 5'd16; i += 1'd1 ) begin
      fu__recv_from_ctrl_mem__msg[4'(i)] = recv_from_ctrl_mem__msg;
      fu__recv_from_ctrl_mem__val[4'(i)] = recv_from_ctrl_mem__val;
      recv_from_controller_rdy_vector[4'(i)] = fu__recv_from_ctrl_mem__rdy[4'(i)];
    end
    recv_from_ctrl_mem__rdy = ( | recv_from_controller_rdy_vector );
    send_to_ctrl_mem__msg = { 5'd0, 35'd0, 9'd0, 139'd0, 3'd0 };
    send_to_ctrl_mem__val = 1'd0;
    for ( int unsigned i = 1'd0; i < 5'd16; i += 1'd1 ) begin
      if ( fu__send_to_ctrl_mem__val[4'(i)] ) begin
        send_to_ctrl_mem__msg = fu__send_to_ctrl_mem__msg[4'(i)];
        send_to_ctrl_mem__val = fu__send_to_ctrl_mem__val[4'(i)];
      end
      fu__send_to_ctrl_mem__rdy[4'(i)] = send_to_ctrl_mem__rdy;
      fu__ctrl_addr_inport[4'(i)] = ctrl_addr_inport;
    end
  end

  assign fu__clk[0] = clk;
  assign fu__reset[0] = reset;
  assign fu__clk[1] = clk;
  assign fu__reset[1] = reset;
  assign fu__clk[2] = clk;
  assign fu__reset[2] = reset;
  assign fu__clk[3] = clk;
  assign fu__reset[3] = reset;
  assign fu__clk[4] = clk;
  assign fu__reset[4] = reset;
  assign fu__clk[5] = clk;
  assign fu__reset[5] = reset;
  assign fu__clk[6] = clk;
  assign fu__reset[6] = reset;
  assign fu__clk[7] = clk;
  assign fu__reset[7] = reset;
  assign fu__clk[8] = clk;
  assign fu__reset[8] = reset;
  assign fu__clk[9] = clk;
  assign fu__reset[9] = reset;
  assign fu__clk[10] = clk;
  assign fu__reset[10] = reset;
  assign fu__clk[11] = clk;
  assign fu__reset[11] = reset;
  assign fu__clk[12] = clk;
  assign fu__reset[12] = reset;
  assign fu__clk[13] = clk;
  assign fu__reset[13] = reset;
  assign fu__clk[14] = clk;
  assign fu__reset[14] = reset;
  assign fu__clk[15] = clk;
  assign fu__reset[15] = reset;
  assign to_mem_raddr__msg[0] = fu__to_mem_raddr__msg[0];
  assign fu__to_mem_raddr__rdy[0] = to_mem_raddr__rdy[0];
  assign to_mem_raddr__val[0] = fu__to_mem_raddr__val[0];
  assign fu__from_mem_rdata__msg[0] = from_mem_rdata__msg[0];
  assign from_mem_rdata__rdy[0] = fu__from_mem_rdata__rdy[0];
  assign fu__from_mem_rdata__val[0] = from_mem_rdata__val[0];
  assign to_mem_waddr__msg[0] = fu__to_mem_waddr__msg[0];
  assign fu__to_mem_waddr__rdy[0] = to_mem_waddr__rdy[0];
  assign to_mem_waddr__val[0] = fu__to_mem_waddr__val[0];
  assign to_mem_wdata__msg[0] = fu__to_mem_wdata__msg[0];
  assign fu__to_mem_wdata__rdy[0] = to_mem_wdata__rdy[0];
  assign to_mem_wdata__val[0] = fu__to_mem_wdata__val[0];
  assign fu__clear[0] = clear[0];
  assign to_mem_raddr__msg[1] = fu__to_mem_raddr__msg[1];
  assign fu__to_mem_raddr__rdy[1] = to_mem_raddr__rdy[1];
  assign to_mem_raddr__val[1] = fu__to_mem_raddr__val[1];
  assign fu__from_mem_rdata__msg[1] = from_mem_rdata__msg[1];
  assign from_mem_rdata__rdy[1] = fu__from_mem_rdata__rdy[1];
  assign fu__from_mem_rdata__val[1] = from_mem_rdata__val[1];
  assign to_mem_waddr__msg[1] = fu__to_mem_waddr__msg[1];
  assign fu__to_mem_waddr__rdy[1] = to_mem_waddr__rdy[1];
  assign to_mem_waddr__val[1] = fu__to_mem_waddr__val[1];
  assign to_mem_wdata__msg[1] = fu__to_mem_wdata__msg[1];
  assign fu__to_mem_wdata__rdy[1] = to_mem_wdata__rdy[1];
  assign to_mem_wdata__val[1] = fu__to_mem_wdata__val[1];
  assign fu__clear[1] = clear[1];
  assign to_mem_raddr__msg[2] = fu__to_mem_raddr__msg[2];
  assign fu__to_mem_raddr__rdy[2] = to_mem_raddr__rdy[2];
  assign to_mem_raddr__val[2] = fu__to_mem_raddr__val[2];
  assign fu__from_mem_rdata__msg[2] = from_mem_rdata__msg[2];
  assign from_mem_rdata__rdy[2] = fu__from_mem_rdata__rdy[2];
  assign fu__from_mem_rdata__val[2] = from_mem_rdata__val[2];
  assign to_mem_waddr__msg[2] = fu__to_mem_waddr__msg[2];
  assign fu__to_mem_waddr__rdy[2] = to_mem_waddr__rdy[2];
  assign to_mem_waddr__val[2] = fu__to_mem_waddr__val[2];
  assign to_mem_wdata__msg[2] = fu__to_mem_wdata__msg[2];
  assign fu__to_mem_wdata__rdy[2] = to_mem_wdata__rdy[2];
  assign to_mem_wdata__val[2] = fu__to_mem_wdata__val[2];
  assign fu__clear[2] = clear[2];
  assign to_mem_raddr__msg[3] = fu__to_mem_raddr__msg[3];
  assign fu__to_mem_raddr__rdy[3] = to_mem_raddr__rdy[3];
  assign to_mem_raddr__val[3] = fu__to_mem_raddr__val[3];
  assign fu__from_mem_rdata__msg[3] = from_mem_rdata__msg[3];
  assign from_mem_rdata__rdy[3] = fu__from_mem_rdata__rdy[3];
  assign fu__from_mem_rdata__val[3] = from_mem_rdata__val[3];
  assign to_mem_waddr__msg[3] = fu__to_mem_waddr__msg[3];
  assign fu__to_mem_waddr__rdy[3] = to_mem_waddr__rdy[3];
  assign to_mem_waddr__val[3] = fu__to_mem_waddr__val[3];
  assign to_mem_wdata__msg[3] = fu__to_mem_wdata__msg[3];
  assign fu__to_mem_wdata__rdy[3] = to_mem_wdata__rdy[3];
  assign to_mem_wdata__val[3] = fu__to_mem_wdata__val[3];
  assign fu__clear[3] = clear[3];
  assign to_mem_raddr__msg[4] = fu__to_mem_raddr__msg[4];
  assign fu__to_mem_raddr__rdy[4] = to_mem_raddr__rdy[4];
  assign to_mem_raddr__val[4] = fu__to_mem_raddr__val[4];
  assign fu__from_mem_rdata__msg[4] = from_mem_rdata__msg[4];
  assign from_mem_rdata__rdy[4] = fu__from_mem_rdata__rdy[4];
  assign fu__from_mem_rdata__val[4] = from_mem_rdata__val[4];
  assign to_mem_waddr__msg[4] = fu__to_mem_waddr__msg[4];
  assign fu__to_mem_waddr__rdy[4] = to_mem_waddr__rdy[4];
  assign to_mem_waddr__val[4] = fu__to_mem_waddr__val[4];
  assign to_mem_wdata__msg[4] = fu__to_mem_wdata__msg[4];
  assign fu__to_mem_wdata__rdy[4] = to_mem_wdata__rdy[4];
  assign to_mem_wdata__val[4] = fu__to_mem_wdata__val[4];
  assign fu__clear[4] = clear[4];
  assign to_mem_raddr__msg[5] = fu__to_mem_raddr__msg[5];
  assign fu__to_mem_raddr__rdy[5] = to_mem_raddr__rdy[5];
  assign to_mem_raddr__val[5] = fu__to_mem_raddr__val[5];
  assign fu__from_mem_rdata__msg[5] = from_mem_rdata__msg[5];
  assign from_mem_rdata__rdy[5] = fu__from_mem_rdata__rdy[5];
  assign fu__from_mem_rdata__val[5] = from_mem_rdata__val[5];
  assign to_mem_waddr__msg[5] = fu__to_mem_waddr__msg[5];
  assign fu__to_mem_waddr__rdy[5] = to_mem_waddr__rdy[5];
  assign to_mem_waddr__val[5] = fu__to_mem_waddr__val[5];
  assign to_mem_wdata__msg[5] = fu__to_mem_wdata__msg[5];
  assign fu__to_mem_wdata__rdy[5] = to_mem_wdata__rdy[5];
  assign to_mem_wdata__val[5] = fu__to_mem_wdata__val[5];
  assign fu__clear[5] = clear[5];
  assign to_mem_raddr__msg[6] = fu__to_mem_raddr__msg[6];
  assign fu__to_mem_raddr__rdy[6] = to_mem_raddr__rdy[6];
  assign to_mem_raddr__val[6] = fu__to_mem_raddr__val[6];
  assign fu__from_mem_rdata__msg[6] = from_mem_rdata__msg[6];
  assign from_mem_rdata__rdy[6] = fu__from_mem_rdata__rdy[6];
  assign fu__from_mem_rdata__val[6] = from_mem_rdata__val[6];
  assign to_mem_waddr__msg[6] = fu__to_mem_waddr__msg[6];
  assign fu__to_mem_waddr__rdy[6] = to_mem_waddr__rdy[6];
  assign to_mem_waddr__val[6] = fu__to_mem_waddr__val[6];
  assign to_mem_wdata__msg[6] = fu__to_mem_wdata__msg[6];
  assign fu__to_mem_wdata__rdy[6] = to_mem_wdata__rdy[6];
  assign to_mem_wdata__val[6] = fu__to_mem_wdata__val[6];
  assign fu__clear[6] = clear[6];
  assign to_mem_raddr__msg[7] = fu__to_mem_raddr__msg[7];
  assign fu__to_mem_raddr__rdy[7] = to_mem_raddr__rdy[7];
  assign to_mem_raddr__val[7] = fu__to_mem_raddr__val[7];
  assign fu__from_mem_rdata__msg[7] = from_mem_rdata__msg[7];
  assign from_mem_rdata__rdy[7] = fu__from_mem_rdata__rdy[7];
  assign fu__from_mem_rdata__val[7] = from_mem_rdata__val[7];
  assign to_mem_waddr__msg[7] = fu__to_mem_waddr__msg[7];
  assign fu__to_mem_waddr__rdy[7] = to_mem_waddr__rdy[7];
  assign to_mem_waddr__val[7] = fu__to_mem_waddr__val[7];
  assign to_mem_wdata__msg[7] = fu__to_mem_wdata__msg[7];
  assign fu__to_mem_wdata__rdy[7] = to_mem_wdata__rdy[7];
  assign to_mem_wdata__val[7] = fu__to_mem_wdata__val[7];
  assign fu__clear[7] = clear[7];
  assign to_mem_raddr__msg[8] = fu__to_mem_raddr__msg[8];
  assign fu__to_mem_raddr__rdy[8] = to_mem_raddr__rdy[8];
  assign to_mem_raddr__val[8] = fu__to_mem_raddr__val[8];
  assign fu__from_mem_rdata__msg[8] = from_mem_rdata__msg[8];
  assign from_mem_rdata__rdy[8] = fu__from_mem_rdata__rdy[8];
  assign fu__from_mem_rdata__val[8] = from_mem_rdata__val[8];
  assign to_mem_waddr__msg[8] = fu__to_mem_waddr__msg[8];
  assign fu__to_mem_waddr__rdy[8] = to_mem_waddr__rdy[8];
  assign to_mem_waddr__val[8] = fu__to_mem_waddr__val[8];
  assign to_mem_wdata__msg[8] = fu__to_mem_wdata__msg[8];
  assign fu__to_mem_wdata__rdy[8] = to_mem_wdata__rdy[8];
  assign to_mem_wdata__val[8] = fu__to_mem_wdata__val[8];
  assign fu__clear[8] = clear[8];
  assign to_mem_raddr__msg[9] = fu__to_mem_raddr__msg[9];
  assign fu__to_mem_raddr__rdy[9] = to_mem_raddr__rdy[9];
  assign to_mem_raddr__val[9] = fu__to_mem_raddr__val[9];
  assign fu__from_mem_rdata__msg[9] = from_mem_rdata__msg[9];
  assign from_mem_rdata__rdy[9] = fu__from_mem_rdata__rdy[9];
  assign fu__from_mem_rdata__val[9] = from_mem_rdata__val[9];
  assign to_mem_waddr__msg[9] = fu__to_mem_waddr__msg[9];
  assign fu__to_mem_waddr__rdy[9] = to_mem_waddr__rdy[9];
  assign to_mem_waddr__val[9] = fu__to_mem_waddr__val[9];
  assign to_mem_wdata__msg[9] = fu__to_mem_wdata__msg[9];
  assign fu__to_mem_wdata__rdy[9] = to_mem_wdata__rdy[9];
  assign to_mem_wdata__val[9] = fu__to_mem_wdata__val[9];
  assign fu__clear[9] = clear[9];
  assign to_mem_raddr__msg[10] = fu__to_mem_raddr__msg[10];
  assign fu__to_mem_raddr__rdy[10] = to_mem_raddr__rdy[10];
  assign to_mem_raddr__val[10] = fu__to_mem_raddr__val[10];
  assign fu__from_mem_rdata__msg[10] = from_mem_rdata__msg[10];
  assign from_mem_rdata__rdy[10] = fu__from_mem_rdata__rdy[10];
  assign fu__from_mem_rdata__val[10] = from_mem_rdata__val[10];
  assign to_mem_waddr__msg[10] = fu__to_mem_waddr__msg[10];
  assign fu__to_mem_waddr__rdy[10] = to_mem_waddr__rdy[10];
  assign to_mem_waddr__val[10] = fu__to_mem_waddr__val[10];
  assign to_mem_wdata__msg[10] = fu__to_mem_wdata__msg[10];
  assign fu__to_mem_wdata__rdy[10] = to_mem_wdata__rdy[10];
  assign to_mem_wdata__val[10] = fu__to_mem_wdata__val[10];
  assign fu__clear[10] = clear[10];
  assign to_mem_raddr__msg[11] = fu__to_mem_raddr__msg[11];
  assign fu__to_mem_raddr__rdy[11] = to_mem_raddr__rdy[11];
  assign to_mem_raddr__val[11] = fu__to_mem_raddr__val[11];
  assign fu__from_mem_rdata__msg[11] = from_mem_rdata__msg[11];
  assign from_mem_rdata__rdy[11] = fu__from_mem_rdata__rdy[11];
  assign fu__from_mem_rdata__val[11] = from_mem_rdata__val[11];
  assign to_mem_waddr__msg[11] = fu__to_mem_waddr__msg[11];
  assign fu__to_mem_waddr__rdy[11] = to_mem_waddr__rdy[11];
  assign to_mem_waddr__val[11] = fu__to_mem_waddr__val[11];
  assign to_mem_wdata__msg[11] = fu__to_mem_wdata__msg[11];
  assign fu__to_mem_wdata__rdy[11] = to_mem_wdata__rdy[11];
  assign to_mem_wdata__val[11] = fu__to_mem_wdata__val[11];
  assign fu__clear[11] = clear[11];
  assign to_mem_raddr__msg[12] = fu__to_mem_raddr__msg[12];
  assign fu__to_mem_raddr__rdy[12] = to_mem_raddr__rdy[12];
  assign to_mem_raddr__val[12] = fu__to_mem_raddr__val[12];
  assign fu__from_mem_rdata__msg[12] = from_mem_rdata__msg[12];
  assign from_mem_rdata__rdy[12] = fu__from_mem_rdata__rdy[12];
  assign fu__from_mem_rdata__val[12] = from_mem_rdata__val[12];
  assign to_mem_waddr__msg[12] = fu__to_mem_waddr__msg[12];
  assign fu__to_mem_waddr__rdy[12] = to_mem_waddr__rdy[12];
  assign to_mem_waddr__val[12] = fu__to_mem_waddr__val[12];
  assign to_mem_wdata__msg[12] = fu__to_mem_wdata__msg[12];
  assign fu__to_mem_wdata__rdy[12] = to_mem_wdata__rdy[12];
  assign to_mem_wdata__val[12] = fu__to_mem_wdata__val[12];
  assign fu__clear[12] = clear[12];
  assign to_mem_raddr__msg[13] = fu__to_mem_raddr__msg[13];
  assign fu__to_mem_raddr__rdy[13] = to_mem_raddr__rdy[13];
  assign to_mem_raddr__val[13] = fu__to_mem_raddr__val[13];
  assign fu__from_mem_rdata__msg[13] = from_mem_rdata__msg[13];
  assign from_mem_rdata__rdy[13] = fu__from_mem_rdata__rdy[13];
  assign fu__from_mem_rdata__val[13] = from_mem_rdata__val[13];
  assign to_mem_waddr__msg[13] = fu__to_mem_waddr__msg[13];
  assign fu__to_mem_waddr__rdy[13] = to_mem_waddr__rdy[13];
  assign to_mem_waddr__val[13] = fu__to_mem_waddr__val[13];
  assign to_mem_wdata__msg[13] = fu__to_mem_wdata__msg[13];
  assign fu__to_mem_wdata__rdy[13] = to_mem_wdata__rdy[13];
  assign to_mem_wdata__val[13] = fu__to_mem_wdata__val[13];
  assign fu__clear[13] = clear[13];
  assign to_mem_raddr__msg[14] = fu__to_mem_raddr__msg[14];
  assign fu__to_mem_raddr__rdy[14] = to_mem_raddr__rdy[14];
  assign to_mem_raddr__val[14] = fu__to_mem_raddr__val[14];
  assign fu__from_mem_rdata__msg[14] = from_mem_rdata__msg[14];
  assign from_mem_rdata__rdy[14] = fu__from_mem_rdata__rdy[14];
  assign fu__from_mem_rdata__val[14] = from_mem_rdata__val[14];
  assign to_mem_waddr__msg[14] = fu__to_mem_waddr__msg[14];
  assign fu__to_mem_waddr__rdy[14] = to_mem_waddr__rdy[14];
  assign to_mem_waddr__val[14] = fu__to_mem_waddr__val[14];
  assign to_mem_wdata__msg[14] = fu__to_mem_wdata__msg[14];
  assign fu__to_mem_wdata__rdy[14] = to_mem_wdata__rdy[14];
  assign to_mem_wdata__val[14] = fu__to_mem_wdata__val[14];
  assign fu__clear[14] = clear[14];
  assign to_mem_raddr__msg[15] = fu__to_mem_raddr__msg[15];
  assign fu__to_mem_raddr__rdy[15] = to_mem_raddr__rdy[15];
  assign to_mem_raddr__val[15] = fu__to_mem_raddr__val[15];
  assign fu__from_mem_rdata__msg[15] = from_mem_rdata__msg[15];
  assign from_mem_rdata__rdy[15] = fu__from_mem_rdata__rdy[15];
  assign fu__from_mem_rdata__val[15] = from_mem_rdata__val[15];
  assign to_mem_waddr__msg[15] = fu__to_mem_waddr__msg[15];
  assign fu__to_mem_waddr__rdy[15] = to_mem_waddr__rdy[15];
  assign to_mem_waddr__val[15] = fu__to_mem_waddr__val[15];
  assign to_mem_wdata__msg[15] = fu__to_mem_wdata__msg[15];
  assign fu__to_mem_wdata__rdy[15] = to_mem_wdata__rdy[15];
  assign to_mem_wdata__val[15] = fu__to_mem_wdata__val[15];
  assign fu__clear[15] = clear[15];

endmodule


// PyMTL Component CrossbarRTL Definition
// Full name: CrossbarRTL__DataType_CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1__CtrlType_CGRAConfig_7_4_2_8_8_3__603a41f5d0e2436f__num_inports_2__num_outports_12__num_cgras_4__num_tiles_4__ctrl_mem_size_8__outport_towards_local_base_id_8
// At /cgra/VectorCGRA/noc/CrossbarRTL.py

module CrossbarRTL__06481a49e1920669
(
  input  logic [1:0] cgra_id ,
  input  logic [0:0] clear ,
  input  logic [0:0] clk ,
  input  logic [0:0] compute_done ,
  input  logic [0:0] crossbar_id ,
  input  logic [1:0] crossbar_outport [0:11],
  input  logic [2:0] ctrl_addr_inport ,
  input  logic [2:0] prologue_count_inport [0:7][0:1],
  input  logic [0:0] reset ,
  input  logic [2:0] tile_id ,
  input CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 recv_data__msg [0:1] ,
  output logic [0:0] recv_data__rdy [0:1] ,
  input logic [0:0] recv_data__val [0:1] ,
  input CGRAConfig_7_4_2_8_8_3__603a41f5d0e2436f recv_opt__msg  ,
  output logic [0:0] recv_opt__rdy  ,
  input logic [0:0] recv_opt__val  ,
  output CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 send_data__msg [0:11] ,
  input logic [0:0] send_data__rdy [0:11] ,
  output logic [0:0] send_data__val [0:11] 
);
  localparam logic [1:0] __const__num_inports_at_update_signal  = 2'd2;
  localparam logic [3:0] __const__num_outports_at_update_signal  = 4'd12;
  localparam logic [6:0] __const__OPT_START  = 7'd0;
  localparam logic [3:0] __const__ctrl_mem_size_at_update_prologue_counter  = 4'd8;
  localparam logic [1:0] __const__num_inports_at_update_prologue_counter  = 2'd2;
  localparam logic [3:0] __const__ctrl_mem_size_at_update_prologue_counter_next  = 4'd8;
  localparam logic [1:0] __const__num_inports_at_update_prologue_counter_next  = 2'd2;
  localparam logic [3:0] __const__num_outports_at_update_prologue_counter_next  = 4'd12;
  localparam logic [3:0] __const__num_outports_at_update_send_accepted_next  = 4'd12;
  localparam logic [3:0] __const__num_outports_at_update_prologue_allowing_vector  = 4'd12;
  localparam logic [3:0] __const__num_outports_at_update_prologue_or_valid_vector  = 4'd12;
  localparam logic [3:0] __const__num_outports_at_update_in_dir_vector  = 4'd12;
  localparam logic [3:0] __const__num_outports_at_update_rdy_vector  = 4'd12;
  localparam logic [3:0] __const__outport_towards_local_base_id_at_update_rdy_vector  = 4'd8;
  localparam logic [3:0] __const__num_outports_at_update_valid_vector  = 4'd12;
  localparam logic [1:0] __const__num_inports_at_update_recv_required_vector  = 2'd2;
  localparam logic [3:0] __const__num_outports_at_update_recv_required_vector  = 4'd12;
  localparam logic [3:0] __const__num_outports_at_update_send_required_vector  = 4'd12;
  logic [0:0] all_send_accepted;
  logic [1:0] in_dir [0:11];
  logic [0:0] in_dir_local [0:11];
  logic [11:0] prologue_allowing_vector;
  logic [2:0] prologue_count_wire [0:7][0:1];
  logic [2:0] prologue_counter [0:7][0:1];
  logic [2:0] prologue_counter_next [0:7][0:1];
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 recv_data_msg [0:1];
  logic [0:0] recv_data_val [0:1];
  logic [1:0] recv_required_vector;
  logic [11:0] recv_valid_or_prologue_allowing_vector;
  logic [11:0] recv_valid_vector;
  logic [11:0] send_accepted;
  logic [11:0] send_accepted_next;
  logic [11:0] send_rdy_vector;
  logic [11:0] send_required_vector;

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/noc/CrossbarRTL.py:219
  // @update
  // def update_in_dir_vector():
  // 
  //   for i in range(num_outports):
  //     s.in_dir[i] @= 0
  //     s.in_dir_local[i] @= 0
  // 
  //   for i in range(num_outports):
  //     s.in_dir[i] @= s.crossbar_outport[i]
  //     if s.in_dir[i] > 0:
  //       s.in_dir_local[i] @= trunc(s.in_dir[i] - 1, NumInportType)
  
  always_comb begin : update_in_dir_vector
    for ( int unsigned i = 1'd0; i < 4'( __const__num_outports_at_update_in_dir_vector ); i += 1'd1 ) begin
      in_dir[4'(i)] = 2'd0;
      in_dir_local[4'(i)] = 1'd0;
    end
    for ( int unsigned i = 1'd0; i < 4'( __const__num_outports_at_update_in_dir_vector ); i += 1'd1 ) begin
      in_dir[4'(i)] = crossbar_outport[4'(i)];
      if ( in_dir[4'(i)] > 2'd0 ) begin
        in_dir_local[4'(i)] = 1'(in_dir[4'(i)] - 2'd1);
      end
    end
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/noc/CrossbarRTL.py:200
  // @update
  // def update_prologue_allowing_vector():
  //   s.prologue_allowing_vector @= 0
  //   for i in range(num_outports):
  //     if s.in_dir[i] > 0:
  //       # Records whether the prologue steps have already been satisfied.
  //       s.prologue_allowing_vector[i] @= \
  //         (s.prologue_counter[s.ctrl_addr_inport][s.in_dir_local[i]] < \
  //          s.prologue_count_wire[s.ctrl_addr_inport][s.in_dir_local[i]])
  //     else:
  //       s.prologue_allowing_vector[i] @= 1
  
  always_comb begin : update_prologue_allowing_vector
    prologue_allowing_vector = 12'd0;
    for ( int unsigned i = 1'd0; i < 4'( __const__num_outports_at_update_prologue_allowing_vector ); i += 1'd1 )
      if ( in_dir[4'(i)] > 2'd0 ) begin
        prologue_allowing_vector[4'(i)] = prologue_counter[ctrl_addr_inport][in_dir_local[4'(i)]] < prologue_count_wire[ctrl_addr_inport][in_dir_local[4'(i)]];
      end
      else
        prologue_allowing_vector[4'(i)] = 1'd1;
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/noc/CrossbarRTL.py:162
  // @update
  // def update_prologue_counter_next():
  //   # Nested-loop to update the prologue counter, to avoid dynamic indexing to
  //   # work-around Yosys issue: https://github.com/tancheng/VectorCGRA/issues/148
  //   for addr in range(ctrl_mem_size):
  //     for i in range(num_inports):
  //       s.prologue_counter_next[addr][i] @= s.prologue_counter[addr][i]
  //       for j in range(num_outports):
  //         if s.recv_opt.rdy & \
  //           (s.in_dir[j] > 0) & \
  //           (s.in_dir_local[j] == i) & \
  //           (addr == s.ctrl_addr_inport) & \
  //           (s.prologue_counter[addr][i] < s.prologue_count_wire[addr][i]):
  //           s.prologue_counter_next[addr][i] @= s.prologue_counter[addr][i] + 1
  
  always_comb begin : update_prologue_counter_next
    for ( int unsigned addr = 1'd0; addr < 4'( __const__ctrl_mem_size_at_update_prologue_counter_next ); addr += 1'd1 )
      for ( int unsigned i = 1'd0; i < 2'( __const__num_inports_at_update_prologue_counter_next ); i += 1'd1 ) begin
        prologue_counter_next[3'(addr)][1'(i)] = prologue_counter[3'(addr)][1'(i)];
        for ( int unsigned j = 1'd0; j < 4'( __const__num_outports_at_update_prologue_counter_next ); j += 1'd1 )
          if ( ( ( ( recv_opt__rdy & ( in_dir[4'(j)] > 2'd0 ) ) & ( in_dir_local[4'(j)] == 1'(i) ) ) & ( 3'(addr) == ctrl_addr_inport ) ) & ( prologue_counter[3'(addr)][1'(i)] < prologue_count_wire[3'(addr)][1'(i)] ) ) begin
            prologue_counter_next[3'(addr)][1'(i)] = prologue_counter[3'(addr)][1'(i)] + 3'd1;
          end
      end
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/noc/CrossbarRTL.py:212
  // @update
  // def update_prologue_or_valid_vector():
  //   s.recv_valid_or_prologue_allowing_vector @= 0
  //   for i in range(num_outports):
  //     s.recv_valid_or_prologue_allowing_vector[i] @= \
  //         s.recv_valid_vector[i] | s.prologue_allowing_vector[i]
  
  always_comb begin : update_prologue_or_valid_vector
    recv_valid_or_prologue_allowing_vector = 12'd0;
    for ( int unsigned i = 1'd0; i < 4'( __const__num_outports_at_update_prologue_or_valid_vector ); i += 1'd1 )
      recv_valid_or_prologue_allowing_vector[4'(i)] = recv_valid_vector[4'(i)] | prologue_allowing_vector[4'(i)];
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/noc/CrossbarRTL.py:231
  // @update
  // def update_rdy_vector():
  //   s.send_rdy_vector @= 0
  //   for i in range(num_outports):
  //     # The `num_inports` indicates the number of outports that go to other tiles.
  //     # Specifically, if the compute already done, we shouldn't care the ones
  //     # (i.e., i >= num_inports) go to the FU's inports. In other words, we skip
  //     # the rdy checking on the FU's inports (connecting from crossbar_outport) if
  //     # the compute is already completed.
  //     if (s.in_dir[i] > 0) & \
  //        (~s.compute_done | (i < outport_towards_local_base_id)):
  //       s.send_rdy_vector[i] @= s.send_data[i].rdy
  //     else:
  //       s.send_rdy_vector[i] @= 1
  
  always_comb begin : update_rdy_vector
    send_rdy_vector = 12'd0;
    for ( int unsigned i = 1'd0; i < 4'( __const__num_outports_at_update_rdy_vector ); i += 1'd1 )
      if ( ( in_dir[4'(i)] > 2'd0 ) & ( ( ~compute_done ) | ( 4'(i) < 4'( __const__outport_towards_local_base_id_at_update_rdy_vector ) ) ) ) begin
        send_rdy_vector[4'(i)] = send_data__rdy[4'(i)];
      end
      else
        send_rdy_vector[4'(i)] = 1'd1;
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/noc/CrossbarRTL.py:255
  // @update
  // def update_recv_required_vector():
  //   for i in range(num_inports):
  //     s.recv_required_vector[i] @= 0
  // 
  //   for i in range(num_outports):
  //     if s.in_dir[i] > 0:
  //       s.recv_required_vector[s.in_dir_local[i]] @= 1
  
  always_comb begin : update_recv_required_vector
    for ( int unsigned i = 1'd0; i < 2'( __const__num_inports_at_update_recv_required_vector ); i += 1'd1 )
      recv_required_vector[1'(i)] = 1'd0;
    for ( int unsigned i = 1'd0; i < 4'( __const__num_outports_at_update_recv_required_vector ); i += 1'd1 )
      if ( in_dir[4'(i)] > 2'd0 ) begin
        recv_required_vector[in_dir_local[4'(i)]] = 1'd1;
      end
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/noc/CrossbarRTL.py:177
  // @update
  // def update_send_accepted_next():
  //   # By default, hold the current value.
  //   s.send_accepted_next @= s.send_accepted
  // 
  //   if s.recv_opt.val & (s.recv_opt.msg.operation != OPT_START):
  //     # For each output that is required and not yet accepted:
  //     # if it accepts this cycle (val=1 & rdy=1), mark it.
  //     # Note: val is only asserted for ~send_accepted outputs (see
  //     # update_signal), so send_data[i].val & send_data[i].rdy implies
  //     # the output just accepted.
  //     for i in range(num_outports):
  //       if s.send_required_vector[i] & ~s.send_accepted[i] & s.send_data[i].rdy & s.send_data[i].val:
  //         s.send_accepted_next[i] @= 1
  // 
  //     # When the input is dequeued (recv_opt.rdy=1), the multicast is
  //     # complete -- clear send_accepted for the next transaction.
  //     if s.recv_opt.rdy:
  //       s.send_accepted_next @= 0
  //   else:
  //     # Not active (OPT_START or opt not valid) -- clear.
  //     s.send_accepted_next @= 0
  
  always_comb begin : update_send_accepted_next
    send_accepted_next = send_accepted;
    if ( recv_opt__val & ( recv_opt__msg.operation != 7'( __const__OPT_START ) ) ) begin
      for ( int unsigned i = 1'd0; i < 4'( __const__num_outports_at_update_send_accepted_next ); i += 1'd1 )
        if ( ( ( send_required_vector[4'(i)] & ( ~send_accepted[4'(i)] ) ) & send_data__rdy[4'(i)] ) & send_data__val[4'(i)] ) begin
          send_accepted_next[4'(i)] = 1'd1;
        end
      if ( recv_opt__rdy ) begin
        send_accepted_next = 12'd0;
      end
    end
    else
      send_accepted_next = 12'd0;
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/noc/CrossbarRTL.py:264
  // @update
  // def update_send_required_vector():
  // 
  //   for i in range(num_outports):
  //     s.send_required_vector[i] @= 0
  // 
  //   for i in range(num_outports):
  //     if s.in_dir[i] > 0:
  //       s.send_required_vector[i] @= 1
  
  always_comb begin : update_send_required_vector
    for ( int unsigned i = 1'd0; i < 4'( __const__num_outports_at_update_send_required_vector ); i += 1'd1 )
      send_required_vector[4'(i)] = 1'd0;
    for ( int unsigned i = 1'd0; i < 4'( __const__num_outports_at_update_send_required_vector ); i += 1'd1 )
      if ( in_dir[4'(i)] > 2'd0 ) begin
        send_required_vector[4'(i)] = 1'd1;
      end
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/noc/CrossbarRTL.py:106
  // @update
  // def update_signal():
  //   for i in range(num_inports):
  //     s.recv_data[i].rdy @= 0
  //   for i in range(num_outports):
  //     s.send_data[i].val @= 0
  //     s.send_data[i].msg @= DataType()
  //   s.recv_opt.rdy @= 0
  //   s.all_send_accepted @= 0
  // 
  //   if s.recv_opt.val & (s.recv_opt.msg.operation != OPT_START):
  // 
  //     # Determine whether all required outputs have been satisfied,
  //     # either accepted in a previous cycle (send_accepted) or being
  //     # accepted right now (send_rdy_vector). This is used for input
  //     # dequeue and recv_opt.rdy.
  //     s.all_send_accepted @= 1
  //     for i in range(num_outports):
  //       if s.send_required_vector[i] & ~s.send_accepted[i] & ~s.send_rdy_vector[i]:
  //         s.all_send_accepted @= 0
  // 
  //     for i in range(num_inports):
  //       s.recv_data[i].rdy @= reduce_and(s.recv_valid_vector) & \
  //                             s.all_send_accepted & \
  //                             s.recv_required_vector[i]
  // 
  //     for i in range(num_outports):
  //       # Only assert val for outputs that are required AND have NOT
  //       # yet accepted in a previous cycle.  This prevents duplicate
  //       # delivery without making val depend on rdy (send_accepted is
  //       # a register, so this is purely val-depends-on-registered-state).
  //       s.send_data[i].val @= reduce_and(s.recv_valid_vector) & \
  //                             s.send_required_vector[i] & \
  //                             ~s.send_accepted[i]
  //       if reduce_and(s.recv_valid_vector) & \
  //          s.send_required_vector[i] & \
  //          ~s.send_accepted[i]:
  //         s.send_data[i].msg.payload @= s.recv_data_msg[s.in_dir_local[i]].payload
  //         s.send_data[i].msg.predicate @= s.recv_data_msg[s.in_dir_local[i]].predicate
  // 
  //     s.recv_opt.rdy @= s.all_send_accepted & \
  //                       reduce_and(s.recv_valid_or_prologue_allowing_vector)
  
  always_comb begin : update_signal
    for ( int unsigned i = 1'd0; i < 2'( __const__num_inports_at_update_signal ); i += 1'd1 )
      recv_data__rdy[1'(i)] = 1'd0;
    for ( int unsigned i = 1'd0; i < 4'( __const__num_outports_at_update_signal ); i += 1'd1 ) begin
      send_data__val[4'(i)] = 1'd0;
      send_data__msg[4'(i)] = { 32'd0, 1'd0, 1'd0, 1'd0 };
    end
    recv_opt__rdy = 1'd0;
    all_send_accepted = 1'd0;
    if ( recv_opt__val & ( recv_opt__msg.operation != 7'( __const__OPT_START ) ) ) begin
      all_send_accepted = 1'd1;
      for ( int unsigned i = 1'd0; i < 4'( __const__num_outports_at_update_signal ); i += 1'd1 )
        if ( ( send_required_vector[4'(i)] & ( ~send_accepted[4'(i)] ) ) & ( ~send_rdy_vector[4'(i)] ) ) begin
          all_send_accepted = 1'd0;
        end
      for ( int unsigned i = 1'd0; i < 2'( __const__num_inports_at_update_signal ); i += 1'd1 )
        recv_data__rdy[1'(i)] = ( ( & recv_valid_vector ) & all_send_accepted ) & recv_required_vector[1'(i)];
      for ( int unsigned i = 1'd0; i < 4'( __const__num_outports_at_update_signal ); i += 1'd1 ) begin
        send_data__val[4'(i)] = ( ( & recv_valid_vector ) & send_required_vector[4'(i)] ) & ( ~send_accepted[4'(i)] );
        if ( ( ( & recv_valid_vector ) & send_required_vector[4'(i)] ) & ( ~send_accepted[4'(i)] ) ) begin
          send_data__msg[4'(i)].payload = recv_data_msg[in_dir_local[4'(i)]].payload;
          send_data__msg[4'(i)].predicate = recv_data_msg[in_dir_local[4'(i)]].predicate;
        end
      end
      recv_opt__rdy = all_send_accepted & ( & recv_valid_or_prologue_allowing_vector );
    end
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/noc/CrossbarRTL.py:246
  // @update
  // def update_valid_vector():
  //   s.recv_valid_vector @= 0
  //   for i in range(num_outports):
  //     if s.in_dir[i] > 0:
  //       s.recv_valid_vector[i] @= s.recv_data_val[s.in_dir_local[i]]
  //     else:
  //       s.recv_valid_vector[i] @= 1
  
  always_comb begin : update_valid_vector
    recv_valid_vector = 12'd0;
    for ( int unsigned i = 1'd0; i < 4'( __const__num_outports_at_update_valid_vector ); i += 1'd1 )
      if ( in_dir[4'(i)] > 2'd0 ) begin
        recv_valid_vector[4'(i)] = recv_data_val[in_dir_local[4'(i)]];
      end
      else
        recv_valid_vector[4'(i)] = 1'd1;
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/noc/CrossbarRTL.py:149
  // @update_ff
  // def update_prologue_counter():
  //   if s.reset | s.clear:
  //     for addr in range(ctrl_mem_size):
  //       for i in range(num_inports):
  //         s.prologue_counter[addr][i] <<= 0
  //     s.send_accepted <<= 0
  //   else:
  //     for addr in range(ctrl_mem_size):
  //       for i in range(num_inports):
  //         s.prologue_counter[addr][i] <<= s.prologue_counter_next[addr][i]
  //     s.send_accepted <<= s.send_accepted_next
  
  always_ff @(posedge clk) begin : update_prologue_counter
    if ( reset | clear ) begin
      for ( int unsigned addr = 1'd0; addr < 4'( __const__ctrl_mem_size_at_update_prologue_counter ); addr += 1'd1 )
        for ( int unsigned i = 1'd0; i < 2'( __const__num_inports_at_update_prologue_counter ); i += 1'd1 )
          prologue_counter[3'(addr)][1'(i)] <= 3'd0;
      send_accepted <= 12'd0;
    end
    else begin
      for ( int unsigned addr = 1'd0; addr < 4'( __const__ctrl_mem_size_at_update_prologue_counter ); addr += 1'd1 )
        for ( int unsigned i = 1'd0; i < 2'( __const__num_inports_at_update_prologue_counter ); i += 1'd1 )
          prologue_counter[3'(addr)][1'(i)] <= prologue_counter_next[3'(addr)][1'(i)];
      send_accepted <= send_accepted_next;
    end
  end

  assign recv_data_msg[0] = recv_data__msg[0];
  assign recv_data_val[0] = recv_data__val[0];
  assign recv_data_msg[1] = recv_data__msg[1];
  assign recv_data_val[1] = recv_data__val[1];
  assign prologue_count_wire[0][0] = prologue_count_inport[0][0];
  assign prologue_count_wire[0][1] = prologue_count_inport[0][1];
  assign prologue_count_wire[1][0] = prologue_count_inport[1][0];
  assign prologue_count_wire[1][1] = prologue_count_inport[1][1];
  assign prologue_count_wire[2][0] = prologue_count_inport[2][0];
  assign prologue_count_wire[2][1] = prologue_count_inport[2][1];
  assign prologue_count_wire[3][0] = prologue_count_inport[3][0];
  assign prologue_count_wire[3][1] = prologue_count_inport[3][1];
  assign prologue_count_wire[4][0] = prologue_count_inport[4][0];
  assign prologue_count_wire[4][1] = prologue_count_inport[4][1];
  assign prologue_count_wire[5][0] = prologue_count_inport[5][0];
  assign prologue_count_wire[5][1] = prologue_count_inport[5][1];
  assign prologue_count_wire[6][0] = prologue_count_inport[6][0];
  assign prologue_count_wire[6][1] = prologue_count_inport[6][1];
  assign prologue_count_wire[7][0] = prologue_count_inport[7][0];
  assign prologue_count_wire[7][1] = prologue_count_inport[7][1];

endmodule


// PyMTL Component RegisterFile Definition
// Full name: RegisterFile__Type_CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1__nregs_16__rd_ports_1__wr_ports_1__const_zero_False
// At /cgra/venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/register_files.py

module RegisterFile__84f0703fd9bfd535
(
  input  logic [0:0] clk ,
  input  logic [3:0] raddr [0:0],
  output CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 rdata [0:0],
  input  logic [0:0] reset ,
  input  logic [3:0] waddr [0:0],
  input  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 wdata [0:0],
  input  logic [0:0] wen [0:0]
);
  localparam logic [0:0] __const__rd_ports_at_up_rf_read  = 1'd1;
  localparam logic [0:0] __const__wr_ports_at_up_rf_write  = 1'd1;
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 regs [0:15];

  // PyMTL Update Block Source
  // At /cgra/venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/register_files.py:20
  // @update
  // def up_rf_read():
  //   for i in range( rd_ports ):
  //     s.rdata[i] @= s.regs[ s.raddr[i] ]
  
  always_comb begin : up_rf_read
    for ( int unsigned i = 1'd0; i < 1'( __const__rd_ports_at_up_rf_read ); i += 1'd1 )
      rdata[1'(i)] = regs[raddr[1'(i)]];
  end

  // PyMTL Update Block Source
  // At /cgra/venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/register_files.py:32
  // @update_ff
  // def up_rf_write():
  //   for i in range( wr_ports ):
  //     if s.wen[i]:
  //       s.regs[ s.waddr[i] ] <<= s.wdata[i]
  
  always_ff @(posedge clk) begin : up_rf_write
    for ( int unsigned i = 1'd0; i < 1'( __const__wr_ports_at_up_rf_write ); i += 1'd1 )
      if ( wen[1'(i)] ) begin
        regs[waddr[1'(i)]] <= wdata[1'(i)];
      end
  end

endmodule


// PyMTL Component RegisterBankRTL Definition
// Full name: RegisterBankRTL__DataType_CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1__CtrlType_CGRAConfig_7_4_2_8_8_3__603a41f5d0e2436f__reg_bank_id_0__num_registers_16
// At /cgra/VectorCGRA/mem/register_cluster/RegisterBankRTL.py

module RegisterBankRTL__875c77c0f9073b7c
(
  input  logic [0:0] clk ,
  input  CGRAConfig_7_4_2_8_8_3__603a41f5d0e2436f inport_opt ,
  input  logic [0:0] inport_valid [0:2],
  input  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 inport_wdata [0:2],
  input  logic [0:0] reset ,
  output CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 send_data_to_fu__msg  ,
  input logic [0:0] send_data_to_fu__rdy  ,
  output logic [0:0] send_data_to_fu__val  
);
  localparam logic [0:0] __const__reg_bank_id_at_access_registers  = 1'd0;
  localparam logic [0:0] __const__reg_bank_id_at_update_send_val  = 1'd0;
  //-------------------------------------------------------------
  // Component reg_file
  //-------------------------------------------------------------

  logic [0:0] reg_file__clk;
  logic [3:0] reg_file__raddr [0:0];
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 reg_file__rdata [0:0];
  logic [0:0] reg_file__reset;
  logic [3:0] reg_file__waddr [0:0];
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 reg_file__wdata [0:0];
  logic [0:0] reg_file__wen [0:0];

  RegisterFile__84f0703fd9bfd535 reg_file
  (
    .clk( reg_file__clk ),
    .raddr( reg_file__raddr ),
    .rdata( reg_file__rdata ),
    .reset( reg_file__reset ),
    .waddr( reg_file__waddr ),
    .wdata( reg_file__wdata ),
    .wen( reg_file__wen )
  );

  //-------------------------------------------------------------
  // End of component reg_file
  //-------------------------------------------------------------
  logic [1:0] __tmpvar__access_registers_write_reg_from;

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/mem/register_cluster/RegisterBankRTL.py:41
  // @update
  // def access_registers():
  //   # Initializes signals.
  //   s.reg_file.raddr[0] @= AddrType()
  //   s.send_data_to_fu.msg @= DataType()
  //   s.reg_file.waddr[0] @= AddrType()
  //   s.reg_file.wdata[0] @= DataType()
  //   s.reg_file.wen[0] @= 0
  // 
  //   if s.inport_opt.read_reg_from[reg_bank_id]:
  //     s.reg_file.raddr[0] @= s.inport_opt.read_reg_idx[reg_bank_id]
  //     s.send_data_to_fu.msg @= s.reg_file.rdata[0]
  // 
  //   write_reg_from = s.inport_opt.write_reg_from[reg_bank_id]
  //   if ~s.reset & (write_reg_from > 0):
  //     if s.inport_valid[write_reg_from - 1]:
  //       s.reg_file.waddr[0] @= s.inport_opt.write_reg_idx[reg_bank_id]
  //       s.reg_file.wdata[0] @= s.inport_wdata[write_reg_from - 1]
  //       s.reg_file.wen[0] @= 1
  
  always_comb begin : access_registers
    reg_file__raddr[1'd0] = 4'd0;
    send_data_to_fu__msg = { 32'd0, 1'd0, 1'd0, 1'd0 };
    reg_file__waddr[1'd0] = 4'd0;
    reg_file__wdata[1'd0] = { 32'd0, 1'd0, 1'd0, 1'd0 };
    reg_file__wen[1'd0] = 1'd0;
    if ( inport_opt.read_reg_from[2'( __const__reg_bank_id_at_access_registers )] ) begin
      reg_file__raddr[1'd0] = inport_opt.read_reg_idx[2'( __const__reg_bank_id_at_access_registers )];
      send_data_to_fu__msg = reg_file__rdata[1'd0];
    end
    __tmpvar__access_registers_write_reg_from = inport_opt.write_reg_from[2'( __const__reg_bank_id_at_access_registers )];
    if ( ( ~reset ) & ( __tmpvar__access_registers_write_reg_from > 2'd0 ) ) begin
      if ( inport_valid[__tmpvar__access_registers_write_reg_from - 2'd1] ) begin
        reg_file__waddr[1'd0] = inport_opt.write_reg_idx[2'( __const__reg_bank_id_at_access_registers )];
        reg_file__wdata[1'd0] = inport_wdata[__tmpvar__access_registers_write_reg_from - 2'd1];
        reg_file__wen[1'd0] = 1'd1;
      end
    end
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/mem/register_cluster/RegisterBankRTL.py:61
  // @update
  // def update_send_val():
  //   s.send_data_to_fu.val @= 0
  //   if ~s.reset & s.inport_opt.read_reg_from[reg_bank_id]:
  //     s.send_data_to_fu.val @= 1
  
  always_comb begin : update_send_val
    send_data_to_fu__val = 1'd0;
    if ( ( ~reset ) & inport_opt.read_reg_from[2'( __const__reg_bank_id_at_update_send_val )] ) begin
      send_data_to_fu__val = 1'd1;
    end
  end

  assign reg_file__clk = clk;
  assign reg_file__reset = reset;

endmodule


// PyMTL Component RegisterBankRTL Definition
// Full name: RegisterBankRTL__DataType_CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1__CtrlType_CGRAConfig_7_4_2_8_8_3__603a41f5d0e2436f__reg_bank_id_1__num_registers_16
// At /cgra/VectorCGRA/mem/register_cluster/RegisterBankRTL.py

module RegisterBankRTL__e5fa866620bad084
(
  input  logic [0:0] clk ,
  input  CGRAConfig_7_4_2_8_8_3__603a41f5d0e2436f inport_opt ,
  input  logic [0:0] inport_valid [0:2],
  input  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 inport_wdata [0:2],
  input  logic [0:0] reset ,
  output CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 send_data_to_fu__msg  ,
  input logic [0:0] send_data_to_fu__rdy  ,
  output logic [0:0] send_data_to_fu__val  
);
  localparam logic [0:0] __const__reg_bank_id_at_access_registers  = 1'd1;
  localparam logic [0:0] __const__reg_bank_id_at_update_send_val  = 1'd1;
  //-------------------------------------------------------------
  // Component reg_file
  //-------------------------------------------------------------

  logic [0:0] reg_file__clk;
  logic [3:0] reg_file__raddr [0:0];
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 reg_file__rdata [0:0];
  logic [0:0] reg_file__reset;
  logic [3:0] reg_file__waddr [0:0];
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 reg_file__wdata [0:0];
  logic [0:0] reg_file__wen [0:0];

  RegisterFile__84f0703fd9bfd535 reg_file
  (
    .clk( reg_file__clk ),
    .raddr( reg_file__raddr ),
    .rdata( reg_file__rdata ),
    .reset( reg_file__reset ),
    .waddr( reg_file__waddr ),
    .wdata( reg_file__wdata ),
    .wen( reg_file__wen )
  );

  //-------------------------------------------------------------
  // End of component reg_file
  //-------------------------------------------------------------
  logic [1:0] __tmpvar__access_registers_write_reg_from;

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/mem/register_cluster/RegisterBankRTL.py:41
  // @update
  // def access_registers():
  //   # Initializes signals.
  //   s.reg_file.raddr[0] @= AddrType()
  //   s.send_data_to_fu.msg @= DataType()
  //   s.reg_file.waddr[0] @= AddrType()
  //   s.reg_file.wdata[0] @= DataType()
  //   s.reg_file.wen[0] @= 0
  // 
  //   if s.inport_opt.read_reg_from[reg_bank_id]:
  //     s.reg_file.raddr[0] @= s.inport_opt.read_reg_idx[reg_bank_id]
  //     s.send_data_to_fu.msg @= s.reg_file.rdata[0]
  // 
  //   write_reg_from = s.inport_opt.write_reg_from[reg_bank_id]
  //   if ~s.reset & (write_reg_from > 0):
  //     if s.inport_valid[write_reg_from - 1]:
  //       s.reg_file.waddr[0] @= s.inport_opt.write_reg_idx[reg_bank_id]
  //       s.reg_file.wdata[0] @= s.inport_wdata[write_reg_from - 1]
  //       s.reg_file.wen[0] @= 1
  
  always_comb begin : access_registers
    reg_file__raddr[1'd0] = 4'd0;
    send_data_to_fu__msg = { 32'd0, 1'd0, 1'd0, 1'd0 };
    reg_file__waddr[1'd0] = 4'd0;
    reg_file__wdata[1'd0] = { 32'd0, 1'd0, 1'd0, 1'd0 };
    reg_file__wen[1'd0] = 1'd0;
    if ( inport_opt.read_reg_from[2'( __const__reg_bank_id_at_access_registers )] ) begin
      reg_file__raddr[1'd0] = inport_opt.read_reg_idx[2'( __const__reg_bank_id_at_access_registers )];
      send_data_to_fu__msg = reg_file__rdata[1'd0];
    end
    __tmpvar__access_registers_write_reg_from = inport_opt.write_reg_from[2'( __const__reg_bank_id_at_access_registers )];
    if ( ( ~reset ) & ( __tmpvar__access_registers_write_reg_from > 2'd0 ) ) begin
      if ( inport_valid[__tmpvar__access_registers_write_reg_from - 2'd1] ) begin
        reg_file__waddr[1'd0] = inport_opt.write_reg_idx[2'( __const__reg_bank_id_at_access_registers )];
        reg_file__wdata[1'd0] = inport_wdata[__tmpvar__access_registers_write_reg_from - 2'd1];
        reg_file__wen[1'd0] = 1'd1;
      end
    end
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/mem/register_cluster/RegisterBankRTL.py:61
  // @update
  // def update_send_val():
  //   s.send_data_to_fu.val @= 0
  //   if ~s.reset & s.inport_opt.read_reg_from[reg_bank_id]:
  //     s.send_data_to_fu.val @= 1
  
  always_comb begin : update_send_val
    send_data_to_fu__val = 1'd0;
    if ( ( ~reset ) & inport_opt.read_reg_from[2'( __const__reg_bank_id_at_update_send_val )] ) begin
      send_data_to_fu__val = 1'd1;
    end
  end

  assign reg_file__clk = clk;
  assign reg_file__reset = reset;

endmodule


// PyMTL Component RegisterBankRTL Definition
// Full name: RegisterBankRTL__DataType_CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1__CtrlType_CGRAConfig_7_4_2_8_8_3__603a41f5d0e2436f__reg_bank_id_2__num_registers_16
// At /cgra/VectorCGRA/mem/register_cluster/RegisterBankRTL.py

module RegisterBankRTL__7af232d7d9d1d953
(
  input  logic [0:0] clk ,
  input  CGRAConfig_7_4_2_8_8_3__603a41f5d0e2436f inport_opt ,
  input  logic [0:0] inport_valid [0:2],
  input  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 inport_wdata [0:2],
  input  logic [0:0] reset ,
  output CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 send_data_to_fu__msg  ,
  input logic [0:0] send_data_to_fu__rdy  ,
  output logic [0:0] send_data_to_fu__val  
);
  localparam logic [1:0] __const__reg_bank_id_at_access_registers  = 2'd2;
  localparam logic [1:0] __const__reg_bank_id_at_update_send_val  = 2'd2;
  //-------------------------------------------------------------
  // Component reg_file
  //-------------------------------------------------------------

  logic [0:0] reg_file__clk;
  logic [3:0] reg_file__raddr [0:0];
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 reg_file__rdata [0:0];
  logic [0:0] reg_file__reset;
  logic [3:0] reg_file__waddr [0:0];
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 reg_file__wdata [0:0];
  logic [0:0] reg_file__wen [0:0];

  RegisterFile__84f0703fd9bfd535 reg_file
  (
    .clk( reg_file__clk ),
    .raddr( reg_file__raddr ),
    .rdata( reg_file__rdata ),
    .reset( reg_file__reset ),
    .waddr( reg_file__waddr ),
    .wdata( reg_file__wdata ),
    .wen( reg_file__wen )
  );

  //-------------------------------------------------------------
  // End of component reg_file
  //-------------------------------------------------------------
  logic [1:0] __tmpvar__access_registers_write_reg_from;

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/mem/register_cluster/RegisterBankRTL.py:41
  // @update
  // def access_registers():
  //   # Initializes signals.
  //   s.reg_file.raddr[0] @= AddrType()
  //   s.send_data_to_fu.msg @= DataType()
  //   s.reg_file.waddr[0] @= AddrType()
  //   s.reg_file.wdata[0] @= DataType()
  //   s.reg_file.wen[0] @= 0
  // 
  //   if s.inport_opt.read_reg_from[reg_bank_id]:
  //     s.reg_file.raddr[0] @= s.inport_opt.read_reg_idx[reg_bank_id]
  //     s.send_data_to_fu.msg @= s.reg_file.rdata[0]
  // 
  //   write_reg_from = s.inport_opt.write_reg_from[reg_bank_id]
  //   if ~s.reset & (write_reg_from > 0):
  //     if s.inport_valid[write_reg_from - 1]:
  //       s.reg_file.waddr[0] @= s.inport_opt.write_reg_idx[reg_bank_id]
  //       s.reg_file.wdata[0] @= s.inport_wdata[write_reg_from - 1]
  //       s.reg_file.wen[0] @= 1
  
  always_comb begin : access_registers
    reg_file__raddr[1'd0] = 4'd0;
    send_data_to_fu__msg = { 32'd0, 1'd0, 1'd0, 1'd0 };
    reg_file__waddr[1'd0] = 4'd0;
    reg_file__wdata[1'd0] = { 32'd0, 1'd0, 1'd0, 1'd0 };
    reg_file__wen[1'd0] = 1'd0;
    if ( inport_opt.read_reg_from[2'( __const__reg_bank_id_at_access_registers )] ) begin
      reg_file__raddr[1'd0] = inport_opt.read_reg_idx[2'( __const__reg_bank_id_at_access_registers )];
      send_data_to_fu__msg = reg_file__rdata[1'd0];
    end
    __tmpvar__access_registers_write_reg_from = inport_opt.write_reg_from[2'( __const__reg_bank_id_at_access_registers )];
    if ( ( ~reset ) & ( __tmpvar__access_registers_write_reg_from > 2'd0 ) ) begin
      if ( inport_valid[__tmpvar__access_registers_write_reg_from - 2'd1] ) begin
        reg_file__waddr[1'd0] = inport_opt.write_reg_idx[2'( __const__reg_bank_id_at_access_registers )];
        reg_file__wdata[1'd0] = inport_wdata[__tmpvar__access_registers_write_reg_from - 2'd1];
        reg_file__wen[1'd0] = 1'd1;
      end
    end
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/mem/register_cluster/RegisterBankRTL.py:61
  // @update
  // def update_send_val():
  //   s.send_data_to_fu.val @= 0
  //   if ~s.reset & s.inport_opt.read_reg_from[reg_bank_id]:
  //     s.send_data_to_fu.val @= 1
  
  always_comb begin : update_send_val
    send_data_to_fu__val = 1'd0;
    if ( ( ~reset ) & inport_opt.read_reg_from[2'( __const__reg_bank_id_at_update_send_val )] ) begin
      send_data_to_fu__val = 1'd1;
    end
  end

  assign reg_file__clk = clk;
  assign reg_file__reset = reset;

endmodule


// PyMTL Component RegisterBankRTL Definition
// Full name: RegisterBankRTL__DataType_CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1__CtrlType_CGRAConfig_7_4_2_8_8_3__603a41f5d0e2436f__reg_bank_id_3__num_registers_16
// At /cgra/VectorCGRA/mem/register_cluster/RegisterBankRTL.py

module RegisterBankRTL__01c957f3d2dd8862
(
  input  logic [0:0] clk ,
  input  CGRAConfig_7_4_2_8_8_3__603a41f5d0e2436f inport_opt ,
  input  logic [0:0] inport_valid [0:2],
  input  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 inport_wdata [0:2],
  input  logic [0:0] reset ,
  output CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 send_data_to_fu__msg  ,
  input logic [0:0] send_data_to_fu__rdy  ,
  output logic [0:0] send_data_to_fu__val  
);
  localparam logic [1:0] __const__reg_bank_id_at_access_registers  = 2'd3;
  localparam logic [1:0] __const__reg_bank_id_at_update_send_val  = 2'd3;
  //-------------------------------------------------------------
  // Component reg_file
  //-------------------------------------------------------------

  logic [0:0] reg_file__clk;
  logic [3:0] reg_file__raddr [0:0];
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 reg_file__rdata [0:0];
  logic [0:0] reg_file__reset;
  logic [3:0] reg_file__waddr [0:0];
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 reg_file__wdata [0:0];
  logic [0:0] reg_file__wen [0:0];

  RegisterFile__84f0703fd9bfd535 reg_file
  (
    .clk( reg_file__clk ),
    .raddr( reg_file__raddr ),
    .rdata( reg_file__rdata ),
    .reset( reg_file__reset ),
    .waddr( reg_file__waddr ),
    .wdata( reg_file__wdata ),
    .wen( reg_file__wen )
  );

  //-------------------------------------------------------------
  // End of component reg_file
  //-------------------------------------------------------------
  logic [1:0] __tmpvar__access_registers_write_reg_from;

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/mem/register_cluster/RegisterBankRTL.py:41
  // @update
  // def access_registers():
  //   # Initializes signals.
  //   s.reg_file.raddr[0] @= AddrType()
  //   s.send_data_to_fu.msg @= DataType()
  //   s.reg_file.waddr[0] @= AddrType()
  //   s.reg_file.wdata[0] @= DataType()
  //   s.reg_file.wen[0] @= 0
  // 
  //   if s.inport_opt.read_reg_from[reg_bank_id]:
  //     s.reg_file.raddr[0] @= s.inport_opt.read_reg_idx[reg_bank_id]
  //     s.send_data_to_fu.msg @= s.reg_file.rdata[0]
  // 
  //   write_reg_from = s.inport_opt.write_reg_from[reg_bank_id]
  //   if ~s.reset & (write_reg_from > 0):
  //     if s.inport_valid[write_reg_from - 1]:
  //       s.reg_file.waddr[0] @= s.inport_opt.write_reg_idx[reg_bank_id]
  //       s.reg_file.wdata[0] @= s.inport_wdata[write_reg_from - 1]
  //       s.reg_file.wen[0] @= 1
  
  always_comb begin : access_registers
    reg_file__raddr[1'd0] = 4'd0;
    send_data_to_fu__msg = { 32'd0, 1'd0, 1'd0, 1'd0 };
    reg_file__waddr[1'd0] = 4'd0;
    reg_file__wdata[1'd0] = { 32'd0, 1'd0, 1'd0, 1'd0 };
    reg_file__wen[1'd0] = 1'd0;
    if ( inport_opt.read_reg_from[2'( __const__reg_bank_id_at_access_registers )] ) begin
      reg_file__raddr[1'd0] = inport_opt.read_reg_idx[2'( __const__reg_bank_id_at_access_registers )];
      send_data_to_fu__msg = reg_file__rdata[1'd0];
    end
    __tmpvar__access_registers_write_reg_from = inport_opt.write_reg_from[2'( __const__reg_bank_id_at_access_registers )];
    if ( ( ~reset ) & ( __tmpvar__access_registers_write_reg_from > 2'd0 ) ) begin
      if ( inport_valid[__tmpvar__access_registers_write_reg_from - 2'd1] ) begin
        reg_file__waddr[1'd0] = inport_opt.write_reg_idx[2'( __const__reg_bank_id_at_access_registers )];
        reg_file__wdata[1'd0] = inport_wdata[__tmpvar__access_registers_write_reg_from - 2'd1];
        reg_file__wen[1'd0] = 1'd1;
      end
    end
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/mem/register_cluster/RegisterBankRTL.py:61
  // @update
  // def update_send_val():
  //   s.send_data_to_fu.val @= 0
  //   if ~s.reset & s.inport_opt.read_reg_from[reg_bank_id]:
  //     s.send_data_to_fu.val @= 1
  
  always_comb begin : update_send_val
    send_data_to_fu__val = 1'd0;
    if ( ( ~reset ) & inport_opt.read_reg_from[2'( __const__reg_bank_id_at_update_send_val )] ) begin
      send_data_to_fu__val = 1'd1;
    end
  end

  assign reg_file__clk = clk;
  assign reg_file__reset = reset;

endmodule


// PyMTL Component RegisterClusterRTL Definition
// Full name: RegisterClusterRTL__DataType_CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1__CtrlType_CGRAConfig_7_4_2_8_8_3__603a41f5d0e2436f__num_reg_banks_4__num_registers_per_reg_bank_16
// At /cgra/VectorCGRA/mem/register_cluster/RegisterClusterRTL.py

module RegisterClusterRTL__8a44c1a18964df48
(
  input  logic [0:0] clk ,
  input  CGRAConfig_7_4_2_8_8_3__603a41f5d0e2436f inport_opt ,
  input  logic [0:0] reset ,
  input CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 recv_data_from_const__msg [0:3] ,
  output logic [0:0] recv_data_from_const__rdy [0:3] ,
  input logic [0:0] recv_data_from_const__val [0:3] ,
  input CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 recv_data_from_fu_crossbar__msg [0:3] ,
  output logic [0:0] recv_data_from_fu_crossbar__rdy [0:3] ,
  input logic [0:0] recv_data_from_fu_crossbar__val [0:3] ,
  input CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 recv_data_from_routing_crossbar__msg [0:3] ,
  output logic [0:0] recv_data_from_routing_crossbar__rdy [0:3] ,
  input logic [0:0] recv_data_from_routing_crossbar__val [0:3] ,
  output CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 send_data_to_fu__msg [0:3] ,
  input logic [0:0] send_data_to_fu__rdy [0:3] ,
  output logic [0:0] send_data_to_fu__val [0:3] 
);
  localparam logic [2:0] __const__num_reg_banks_at_update_msgs_signals  = 3'd4;
  //-------------------------------------------------------------
  // Component reg_bank[0:3]
  //-------------------------------------------------------------

  logic [0:0] reg_bank__clk [0:3];
  CGRAConfig_7_4_2_8_8_3__603a41f5d0e2436f reg_bank__inport_opt [0:3];
  logic [0:0] reg_bank__inport_valid [0:3][0:2];
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 reg_bank__inport_wdata [0:3][0:2];
  logic [0:0] reg_bank__reset [0:3];
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 reg_bank__send_data_to_fu__msg [0:3];
  logic [0:0] reg_bank__send_data_to_fu__rdy [0:3];
  logic [0:0] reg_bank__send_data_to_fu__val [0:3];

  RegisterBankRTL__875c77c0f9073b7c reg_bank__0
  (
    .clk( reg_bank__clk[0] ),
    .inport_opt( reg_bank__inport_opt[0] ),
    .inport_valid( reg_bank__inport_valid[0] ),
    .inport_wdata( reg_bank__inport_wdata[0] ),
    .reset( reg_bank__reset[0] ),
    .send_data_to_fu__msg( reg_bank__send_data_to_fu__msg[0] ),
    .send_data_to_fu__rdy( reg_bank__send_data_to_fu__rdy[0] ),
    .send_data_to_fu__val( reg_bank__send_data_to_fu__val[0] )
  );

  RegisterBankRTL__e5fa866620bad084 reg_bank__1
  (
    .clk( reg_bank__clk[1] ),
    .inport_opt( reg_bank__inport_opt[1] ),
    .inport_valid( reg_bank__inport_valid[1] ),
    .inport_wdata( reg_bank__inport_wdata[1] ),
    .reset( reg_bank__reset[1] ),
    .send_data_to_fu__msg( reg_bank__send_data_to_fu__msg[1] ),
    .send_data_to_fu__rdy( reg_bank__send_data_to_fu__rdy[1] ),
    .send_data_to_fu__val( reg_bank__send_data_to_fu__val[1] )
  );

  RegisterBankRTL__7af232d7d9d1d953 reg_bank__2
  (
    .clk( reg_bank__clk[2] ),
    .inport_opt( reg_bank__inport_opt[2] ),
    .inport_valid( reg_bank__inport_valid[2] ),
    .inport_wdata( reg_bank__inport_wdata[2] ),
    .reset( reg_bank__reset[2] ),
    .send_data_to_fu__msg( reg_bank__send_data_to_fu__msg[2] ),
    .send_data_to_fu__rdy( reg_bank__send_data_to_fu__rdy[2] ),
    .send_data_to_fu__val( reg_bank__send_data_to_fu__val[2] )
  );

  RegisterBankRTL__01c957f3d2dd8862 reg_bank__3
  (
    .clk( reg_bank__clk[3] ),
    .inport_opt( reg_bank__inport_opt[3] ),
    .inport_valid( reg_bank__inport_valid[3] ),
    .inport_wdata( reg_bank__inport_wdata[3] ),
    .reset( reg_bank__reset[3] ),
    .send_data_to_fu__msg( reg_bank__send_data_to_fu__msg[3] ),
    .send_data_to_fu__rdy( reg_bank__send_data_to_fu__rdy[3] ),
    .send_data_to_fu__val( reg_bank__send_data_to_fu__val[3] )
  );

  //-------------------------------------------------------------
  // End of component reg_bank[0:3]
  //-------------------------------------------------------------

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/mem/register_cluster/RegisterClusterRTL.py:45
  // @update
  // def update_msgs_signals():
  //   # Initializes signals.
  //   for i in range(num_reg_banks):
  //     s.send_data_to_fu[i].msg @= DataType()
  //     s.recv_data_from_routing_crossbar[i].rdy @= 0
  //     s.recv_data_from_fu_crossbar[i].rdy @= 0
  //     s.recv_data_from_const[i].rdy @= 0
  //     s.send_data_to_fu[i].val @= 0
  // 
  //   for i in range(num_reg_banks):
  //     if s.recv_data_from_routing_crossbar[i].val:
  //       s.send_data_to_fu[i].msg @= \
  //         s.recv_data_from_routing_crossbar[i].msg
  //     else:
  //       s.send_data_to_fu[i].msg @= \
  //         s.reg_bank[i].send_data_to_fu.msg
  // 
  //     s.send_data_to_fu[i].val @= \
  //         s.recv_data_from_routing_crossbar[i].val | \
  //         s.reg_bank[i].send_data_to_fu.val
  //     s.reg_bank[i].send_data_to_fu.rdy @= s.send_data_to_fu[i].rdy
  // 
  //     s.recv_data_from_routing_crossbar[i].rdy @= s.send_data_to_fu[i].rdy
  //     s.recv_data_from_fu_crossbar[i].rdy @= 1
  //     s.recv_data_from_const[i].rdy @= 1
  
  always_comb begin : update_msgs_signals
    for ( int unsigned i = 1'd0; i < 3'( __const__num_reg_banks_at_update_msgs_signals ); i += 1'd1 ) begin
      send_data_to_fu__msg[2'(i)] = { 32'd0, 1'd0, 1'd0, 1'd0 };
      recv_data_from_routing_crossbar__rdy[2'(i)] = 1'd0;
      recv_data_from_fu_crossbar__rdy[2'(i)] = 1'd0;
      recv_data_from_const__rdy[2'(i)] = 1'd0;
      send_data_to_fu__val[2'(i)] = 1'd0;
    end
    for ( int unsigned i = 1'd0; i < 3'( __const__num_reg_banks_at_update_msgs_signals ); i += 1'd1 ) begin
      if ( recv_data_from_routing_crossbar__val[2'(i)] ) begin
        send_data_to_fu__msg[2'(i)] = recv_data_from_routing_crossbar__msg[2'(i)];
      end
      else
        send_data_to_fu__msg[2'(i)] = reg_bank__send_data_to_fu__msg[2'(i)];
      send_data_to_fu__val[2'(i)] = recv_data_from_routing_crossbar__val[2'(i)] | reg_bank__send_data_to_fu__val[2'(i)];
      reg_bank__send_data_to_fu__rdy[2'(i)] = send_data_to_fu__rdy[2'(i)];
      recv_data_from_routing_crossbar__rdy[2'(i)] = send_data_to_fu__rdy[2'(i)];
      recv_data_from_fu_crossbar__rdy[2'(i)] = 1'd1;
      recv_data_from_const__rdy[2'(i)] = 1'd1;
    end
  end

  assign reg_bank__clk[0] = clk;
  assign reg_bank__reset[0] = reset;
  assign reg_bank__clk[1] = clk;
  assign reg_bank__reset[1] = reset;
  assign reg_bank__clk[2] = clk;
  assign reg_bank__reset[2] = reset;
  assign reg_bank__clk[3] = clk;
  assign reg_bank__reset[3] = reset;
  assign reg_bank__inport_opt[0] = inport_opt;
  assign reg_bank__inport_wdata[0][0] = recv_data_from_routing_crossbar__msg[0];
  assign reg_bank__inport_wdata[0][1] = recv_data_from_fu_crossbar__msg[0];
  assign reg_bank__inport_wdata[0][2] = recv_data_from_const__msg[0];
  assign reg_bank__inport_valid[0][0] = recv_data_from_routing_crossbar__val[0];
  assign reg_bank__inport_valid[0][1] = recv_data_from_fu_crossbar__val[0];
  assign reg_bank__inport_valid[0][2] = recv_data_from_const__val[0];
  assign reg_bank__inport_opt[1] = inport_opt;
  assign reg_bank__inport_wdata[1][0] = recv_data_from_routing_crossbar__msg[1];
  assign reg_bank__inport_wdata[1][1] = recv_data_from_fu_crossbar__msg[1];
  assign reg_bank__inport_wdata[1][2] = recv_data_from_const__msg[1];
  assign reg_bank__inport_valid[1][0] = recv_data_from_routing_crossbar__val[1];
  assign reg_bank__inport_valid[1][1] = recv_data_from_fu_crossbar__val[1];
  assign reg_bank__inport_valid[1][2] = recv_data_from_const__val[1];
  assign reg_bank__inport_opt[2] = inport_opt;
  assign reg_bank__inport_wdata[2][0] = recv_data_from_routing_crossbar__msg[2];
  assign reg_bank__inport_wdata[2][1] = recv_data_from_fu_crossbar__msg[2];
  assign reg_bank__inport_wdata[2][2] = recv_data_from_const__msg[2];
  assign reg_bank__inport_valid[2][0] = recv_data_from_routing_crossbar__val[2];
  assign reg_bank__inport_valid[2][1] = recv_data_from_fu_crossbar__val[2];
  assign reg_bank__inport_valid[2][2] = recv_data_from_const__val[2];
  assign reg_bank__inport_opt[3] = inport_opt;
  assign reg_bank__inport_wdata[3][0] = recv_data_from_routing_crossbar__msg[3];
  assign reg_bank__inport_wdata[3][1] = recv_data_from_fu_crossbar__msg[3];
  assign reg_bank__inport_wdata[3][2] = recv_data_from_const__msg[3];
  assign reg_bank__inport_valid[3][0] = recv_data_from_routing_crossbar__val[3];
  assign reg_bank__inport_valid[3][1] = recv_data_from_fu_crossbar__val[3];
  assign reg_bank__inport_valid[3][2] = recv_data_from_const__val[3];

endmodule


// PyMTL Component CrossbarRTL Definition
// Full name: CrossbarRTL__DataType_CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1__CtrlType_CGRAConfig_7_4_2_8_8_3__603a41f5d0e2436f__num_inports_8__num_outports_12__num_cgras_4__num_tiles_4__ctrl_mem_size_8__outport_towards_local_base_id_8
// At /cgra/VectorCGRA/noc/CrossbarRTL.py

module CrossbarRTL__2e8e5b6a3eee594d
(
  input  logic [1:0] cgra_id ,
  input  logic [0:0] clear ,
  input  logic [0:0] clk ,
  input  logic [0:0] compute_done ,
  input  logic [0:0] crossbar_id ,
  input  logic [3:0] crossbar_outport [0:11],
  input  logic [2:0] ctrl_addr_inport ,
  input  logic [2:0] prologue_count_inport [0:7][0:7],
  input  logic [0:0] reset ,
  input  logic [2:0] tile_id ,
  input CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 recv_data__msg [0:7] ,
  output logic [0:0] recv_data__rdy [0:7] ,
  input logic [0:0] recv_data__val [0:7] ,
  input CGRAConfig_7_4_2_8_8_3__603a41f5d0e2436f recv_opt__msg  ,
  output logic [0:0] recv_opt__rdy  ,
  input logic [0:0] recv_opt__val  ,
  output CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 send_data__msg [0:11] ,
  input logic [0:0] send_data__rdy [0:11] ,
  output logic [0:0] send_data__val [0:11] 
);
  localparam logic [3:0] __const__num_inports_at_update_signal  = 4'd8;
  localparam logic [3:0] __const__num_outports_at_update_signal  = 4'd12;
  localparam logic [6:0] __const__OPT_START  = 7'd0;
  localparam logic [3:0] __const__ctrl_mem_size_at_update_prologue_counter  = 4'd8;
  localparam logic [3:0] __const__num_inports_at_update_prologue_counter  = 4'd8;
  localparam logic [3:0] __const__ctrl_mem_size_at_update_prologue_counter_next  = 4'd8;
  localparam logic [3:0] __const__num_inports_at_update_prologue_counter_next  = 4'd8;
  localparam logic [3:0] __const__num_outports_at_update_prologue_counter_next  = 4'd12;
  localparam logic [3:0] __const__num_outports_at_update_send_accepted_next  = 4'd12;
  localparam logic [3:0] __const__num_outports_at_update_prologue_allowing_vector  = 4'd12;
  localparam logic [3:0] __const__num_outports_at_update_prologue_or_valid_vector  = 4'd12;
  localparam logic [3:0] __const__num_outports_at_update_in_dir_vector  = 4'd12;
  localparam logic [3:0] __const__num_outports_at_update_rdy_vector  = 4'd12;
  localparam logic [3:0] __const__outport_towards_local_base_id_at_update_rdy_vector  = 4'd8;
  localparam logic [3:0] __const__num_outports_at_update_valid_vector  = 4'd12;
  localparam logic [3:0] __const__num_inports_at_update_recv_required_vector  = 4'd8;
  localparam logic [3:0] __const__num_outports_at_update_recv_required_vector  = 4'd12;
  localparam logic [3:0] __const__num_outports_at_update_send_required_vector  = 4'd12;
  logic [0:0] all_send_accepted;
  logic [3:0] in_dir [0:11];
  logic [2:0] in_dir_local [0:11];
  logic [11:0] prologue_allowing_vector;
  logic [2:0] prologue_count_wire [0:7][0:7];
  logic [2:0] prologue_counter [0:7][0:7];
  logic [2:0] prologue_counter_next [0:7][0:7];
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 recv_data_msg [0:7];
  logic [0:0] recv_data_val [0:7];
  logic [7:0] recv_required_vector;
  logic [11:0] recv_valid_or_prologue_allowing_vector;
  logic [11:0] recv_valid_vector;
  logic [11:0] send_accepted;
  logic [11:0] send_accepted_next;
  logic [11:0] send_rdy_vector;
  logic [11:0] send_required_vector;

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/noc/CrossbarRTL.py:219
  // @update
  // def update_in_dir_vector():
  // 
  //   for i in range(num_outports):
  //     s.in_dir[i] @= 0
  //     s.in_dir_local[i] @= 0
  // 
  //   for i in range(num_outports):
  //     s.in_dir[i] @= s.crossbar_outport[i]
  //     if s.in_dir[i] > 0:
  //       s.in_dir_local[i] @= trunc(s.in_dir[i] - 1, NumInportType)
  
  always_comb begin : update_in_dir_vector
    for ( int unsigned i = 1'd0; i < 4'( __const__num_outports_at_update_in_dir_vector ); i += 1'd1 ) begin
      in_dir[4'(i)] = 4'd0;
      in_dir_local[4'(i)] = 3'd0;
    end
    for ( int unsigned i = 1'd0; i < 4'( __const__num_outports_at_update_in_dir_vector ); i += 1'd1 ) begin
      in_dir[4'(i)] = crossbar_outport[4'(i)];
      if ( in_dir[4'(i)] > 4'd0 ) begin
        in_dir_local[4'(i)] = 3'(in_dir[4'(i)] - 4'd1);
      end
    end
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/noc/CrossbarRTL.py:200
  // @update
  // def update_prologue_allowing_vector():
  //   s.prologue_allowing_vector @= 0
  //   for i in range(num_outports):
  //     if s.in_dir[i] > 0:
  //       # Records whether the prologue steps have already been satisfied.
  //       s.prologue_allowing_vector[i] @= \
  //         (s.prologue_counter[s.ctrl_addr_inport][s.in_dir_local[i]] < \
  //          s.prologue_count_wire[s.ctrl_addr_inport][s.in_dir_local[i]])
  //     else:
  //       s.prologue_allowing_vector[i] @= 1
  
  always_comb begin : update_prologue_allowing_vector
    prologue_allowing_vector = 12'd0;
    for ( int unsigned i = 1'd0; i < 4'( __const__num_outports_at_update_prologue_allowing_vector ); i += 1'd1 )
      if ( in_dir[4'(i)] > 4'd0 ) begin
        prologue_allowing_vector[4'(i)] = prologue_counter[ctrl_addr_inport][in_dir_local[4'(i)]] < prologue_count_wire[ctrl_addr_inport][in_dir_local[4'(i)]];
      end
      else
        prologue_allowing_vector[4'(i)] = 1'd1;
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/noc/CrossbarRTL.py:162
  // @update
  // def update_prologue_counter_next():
  //   # Nested-loop to update the prologue counter, to avoid dynamic indexing to
  //   # work-around Yosys issue: https://github.com/tancheng/VectorCGRA/issues/148
  //   for addr in range(ctrl_mem_size):
  //     for i in range(num_inports):
  //       s.prologue_counter_next[addr][i] @= s.prologue_counter[addr][i]
  //       for j in range(num_outports):
  //         if s.recv_opt.rdy & \
  //           (s.in_dir[j] > 0) & \
  //           (s.in_dir_local[j] == i) & \
  //           (addr == s.ctrl_addr_inport) & \
  //           (s.prologue_counter[addr][i] < s.prologue_count_wire[addr][i]):
  //           s.prologue_counter_next[addr][i] @= s.prologue_counter[addr][i] + 1
  
  always_comb begin : update_prologue_counter_next
    for ( int unsigned addr = 1'd0; addr < 4'( __const__ctrl_mem_size_at_update_prologue_counter_next ); addr += 1'd1 )
      for ( int unsigned i = 1'd0; i < 4'( __const__num_inports_at_update_prologue_counter_next ); i += 1'd1 ) begin
        prologue_counter_next[3'(addr)][3'(i)] = prologue_counter[3'(addr)][3'(i)];
        for ( int unsigned j = 1'd0; j < 4'( __const__num_outports_at_update_prologue_counter_next ); j += 1'd1 )
          if ( ( ( ( recv_opt__rdy & ( in_dir[4'(j)] > 4'd0 ) ) & ( in_dir_local[4'(j)] == 3'(i) ) ) & ( 3'(addr) == ctrl_addr_inport ) ) & ( prologue_counter[3'(addr)][3'(i)] < prologue_count_wire[3'(addr)][3'(i)] ) ) begin
            prologue_counter_next[3'(addr)][3'(i)] = prologue_counter[3'(addr)][3'(i)] + 3'd1;
          end
      end
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/noc/CrossbarRTL.py:212
  // @update
  // def update_prologue_or_valid_vector():
  //   s.recv_valid_or_prologue_allowing_vector @= 0
  //   for i in range(num_outports):
  //     s.recv_valid_or_prologue_allowing_vector[i] @= \
  //         s.recv_valid_vector[i] | s.prologue_allowing_vector[i]
  
  always_comb begin : update_prologue_or_valid_vector
    recv_valid_or_prologue_allowing_vector = 12'd0;
    for ( int unsigned i = 1'd0; i < 4'( __const__num_outports_at_update_prologue_or_valid_vector ); i += 1'd1 )
      recv_valid_or_prologue_allowing_vector[4'(i)] = recv_valid_vector[4'(i)] | prologue_allowing_vector[4'(i)];
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/noc/CrossbarRTL.py:231
  // @update
  // def update_rdy_vector():
  //   s.send_rdy_vector @= 0
  //   for i in range(num_outports):
  //     # The `num_inports` indicates the number of outports that go to other tiles.
  //     # Specifically, if the compute already done, we shouldn't care the ones
  //     # (i.e., i >= num_inports) go to the FU's inports. In other words, we skip
  //     # the rdy checking on the FU's inports (connecting from crossbar_outport) if
  //     # the compute is already completed.
  //     if (s.in_dir[i] > 0) & \
  //        (~s.compute_done | (i < outport_towards_local_base_id)):
  //       s.send_rdy_vector[i] @= s.send_data[i].rdy
  //     else:
  //       s.send_rdy_vector[i] @= 1
  
  always_comb begin : update_rdy_vector
    send_rdy_vector = 12'd0;
    for ( int unsigned i = 1'd0; i < 4'( __const__num_outports_at_update_rdy_vector ); i += 1'd1 )
      if ( ( in_dir[4'(i)] > 4'd0 ) & ( ( ~compute_done ) | ( 4'(i) < 4'( __const__outport_towards_local_base_id_at_update_rdy_vector ) ) ) ) begin
        send_rdy_vector[4'(i)] = send_data__rdy[4'(i)];
      end
      else
        send_rdy_vector[4'(i)] = 1'd1;
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/noc/CrossbarRTL.py:255
  // @update
  // def update_recv_required_vector():
  //   for i in range(num_inports):
  //     s.recv_required_vector[i] @= 0
  // 
  //   for i in range(num_outports):
  //     if s.in_dir[i] > 0:
  //       s.recv_required_vector[s.in_dir_local[i]] @= 1
  
  always_comb begin : update_recv_required_vector
    for ( int unsigned i = 1'd0; i < 4'( __const__num_inports_at_update_recv_required_vector ); i += 1'd1 )
      recv_required_vector[3'(i)] = 1'd0;
    for ( int unsigned i = 1'd0; i < 4'( __const__num_outports_at_update_recv_required_vector ); i += 1'd1 )
      if ( in_dir[4'(i)] > 4'd0 ) begin
        recv_required_vector[in_dir_local[4'(i)]] = 1'd1;
      end
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/noc/CrossbarRTL.py:177
  // @update
  // def update_send_accepted_next():
  //   # By default, hold the current value.
  //   s.send_accepted_next @= s.send_accepted
  // 
  //   if s.recv_opt.val & (s.recv_opt.msg.operation != OPT_START):
  //     # For each output that is required and not yet accepted:
  //     # if it accepts this cycle (val=1 & rdy=1), mark it.
  //     # Note: val is only asserted for ~send_accepted outputs (see
  //     # update_signal), so send_data[i].val & send_data[i].rdy implies
  //     # the output just accepted.
  //     for i in range(num_outports):
  //       if s.send_required_vector[i] & ~s.send_accepted[i] & s.send_data[i].rdy & s.send_data[i].val:
  //         s.send_accepted_next[i] @= 1
  // 
  //     # When the input is dequeued (recv_opt.rdy=1), the multicast is
  //     # complete -- clear send_accepted for the next transaction.
  //     if s.recv_opt.rdy:
  //       s.send_accepted_next @= 0
  //   else:
  //     # Not active (OPT_START or opt not valid) -- clear.
  //     s.send_accepted_next @= 0
  
  always_comb begin : update_send_accepted_next
    send_accepted_next = send_accepted;
    if ( recv_opt__val & ( recv_opt__msg.operation != 7'( __const__OPT_START ) ) ) begin
      for ( int unsigned i = 1'd0; i < 4'( __const__num_outports_at_update_send_accepted_next ); i += 1'd1 )
        if ( ( ( send_required_vector[4'(i)] & ( ~send_accepted[4'(i)] ) ) & send_data__rdy[4'(i)] ) & send_data__val[4'(i)] ) begin
          send_accepted_next[4'(i)] = 1'd1;
        end
      if ( recv_opt__rdy ) begin
        send_accepted_next = 12'd0;
      end
    end
    else
      send_accepted_next = 12'd0;
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/noc/CrossbarRTL.py:264
  // @update
  // def update_send_required_vector():
  // 
  //   for i in range(num_outports):
  //     s.send_required_vector[i] @= 0
  // 
  //   for i in range(num_outports):
  //     if s.in_dir[i] > 0:
  //       s.send_required_vector[i] @= 1
  
  always_comb begin : update_send_required_vector
    for ( int unsigned i = 1'd0; i < 4'( __const__num_outports_at_update_send_required_vector ); i += 1'd1 )
      send_required_vector[4'(i)] = 1'd0;
    for ( int unsigned i = 1'd0; i < 4'( __const__num_outports_at_update_send_required_vector ); i += 1'd1 )
      if ( in_dir[4'(i)] > 4'd0 ) begin
        send_required_vector[4'(i)] = 1'd1;
      end
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/noc/CrossbarRTL.py:106
  // @update
  // def update_signal():
  //   for i in range(num_inports):
  //     s.recv_data[i].rdy @= 0
  //   for i in range(num_outports):
  //     s.send_data[i].val @= 0
  //     s.send_data[i].msg @= DataType()
  //   s.recv_opt.rdy @= 0
  //   s.all_send_accepted @= 0
  // 
  //   if s.recv_opt.val & (s.recv_opt.msg.operation != OPT_START):
  // 
  //     # Determine whether all required outputs have been satisfied,
  //     # either accepted in a previous cycle (send_accepted) or being
  //     # accepted right now (send_rdy_vector). This is used for input
  //     # dequeue and recv_opt.rdy.
  //     s.all_send_accepted @= 1
  //     for i in range(num_outports):
  //       if s.send_required_vector[i] & ~s.send_accepted[i] & ~s.send_rdy_vector[i]:
  //         s.all_send_accepted @= 0
  // 
  //     for i in range(num_inports):
  //       s.recv_data[i].rdy @= reduce_and(s.recv_valid_vector) & \
  //                             s.all_send_accepted & \
  //                             s.recv_required_vector[i]
  // 
  //     for i in range(num_outports):
  //       # Only assert val for outputs that are required AND have NOT
  //       # yet accepted in a previous cycle.  This prevents duplicate
  //       # delivery without making val depend on rdy (send_accepted is
  //       # a register, so this is purely val-depends-on-registered-state).
  //       s.send_data[i].val @= reduce_and(s.recv_valid_vector) & \
  //                             s.send_required_vector[i] & \
  //                             ~s.send_accepted[i]
  //       if reduce_and(s.recv_valid_vector) & \
  //          s.send_required_vector[i] & \
  //          ~s.send_accepted[i]:
  //         s.send_data[i].msg.payload @= s.recv_data_msg[s.in_dir_local[i]].payload
  //         s.send_data[i].msg.predicate @= s.recv_data_msg[s.in_dir_local[i]].predicate
  // 
  //     s.recv_opt.rdy @= s.all_send_accepted & \
  //                       reduce_and(s.recv_valid_or_prologue_allowing_vector)
  
  always_comb begin : update_signal
    for ( int unsigned i = 1'd0; i < 4'( __const__num_inports_at_update_signal ); i += 1'd1 )
      recv_data__rdy[3'(i)] = 1'd0;
    for ( int unsigned i = 1'd0; i < 4'( __const__num_outports_at_update_signal ); i += 1'd1 ) begin
      send_data__val[4'(i)] = 1'd0;
      send_data__msg[4'(i)] = { 32'd0, 1'd0, 1'd0, 1'd0 };
    end
    recv_opt__rdy = 1'd0;
    all_send_accepted = 1'd0;
    if ( recv_opt__val & ( recv_opt__msg.operation != 7'( __const__OPT_START ) ) ) begin
      all_send_accepted = 1'd1;
      for ( int unsigned i = 1'd0; i < 4'( __const__num_outports_at_update_signal ); i += 1'd1 )
        if ( ( send_required_vector[4'(i)] & ( ~send_accepted[4'(i)] ) ) & ( ~send_rdy_vector[4'(i)] ) ) begin
          all_send_accepted = 1'd0;
        end
      for ( int unsigned i = 1'd0; i < 4'( __const__num_inports_at_update_signal ); i += 1'd1 )
        recv_data__rdy[3'(i)] = ( ( & recv_valid_vector ) & all_send_accepted ) & recv_required_vector[3'(i)];
      for ( int unsigned i = 1'd0; i < 4'( __const__num_outports_at_update_signal ); i += 1'd1 ) begin
        send_data__val[4'(i)] = ( ( & recv_valid_vector ) & send_required_vector[4'(i)] ) & ( ~send_accepted[4'(i)] );
        if ( ( ( & recv_valid_vector ) & send_required_vector[4'(i)] ) & ( ~send_accepted[4'(i)] ) ) begin
          send_data__msg[4'(i)].payload = recv_data_msg[in_dir_local[4'(i)]].payload;
          send_data__msg[4'(i)].predicate = recv_data_msg[in_dir_local[4'(i)]].predicate;
        end
      end
      recv_opt__rdy = all_send_accepted & ( & recv_valid_or_prologue_allowing_vector );
    end
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/noc/CrossbarRTL.py:246
  // @update
  // def update_valid_vector():
  //   s.recv_valid_vector @= 0
  //   for i in range(num_outports):
  //     if s.in_dir[i] > 0:
  //       s.recv_valid_vector[i] @= s.recv_data_val[s.in_dir_local[i]]
  //     else:
  //       s.recv_valid_vector[i] @= 1
  
  always_comb begin : update_valid_vector
    recv_valid_vector = 12'd0;
    for ( int unsigned i = 1'd0; i < 4'( __const__num_outports_at_update_valid_vector ); i += 1'd1 )
      if ( in_dir[4'(i)] > 4'd0 ) begin
        recv_valid_vector[4'(i)] = recv_data_val[in_dir_local[4'(i)]];
      end
      else
        recv_valid_vector[4'(i)] = 1'd1;
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/noc/CrossbarRTL.py:149
  // @update_ff
  // def update_prologue_counter():
  //   if s.reset | s.clear:
  //     for addr in range(ctrl_mem_size):
  //       for i in range(num_inports):
  //         s.prologue_counter[addr][i] <<= 0
  //     s.send_accepted <<= 0
  //   else:
  //     for addr in range(ctrl_mem_size):
  //       for i in range(num_inports):
  //         s.prologue_counter[addr][i] <<= s.prologue_counter_next[addr][i]
  //     s.send_accepted <<= s.send_accepted_next
  
  always_ff @(posedge clk) begin : update_prologue_counter
    if ( reset | clear ) begin
      for ( int unsigned addr = 1'd0; addr < 4'( __const__ctrl_mem_size_at_update_prologue_counter ); addr += 1'd1 )
        for ( int unsigned i = 1'd0; i < 4'( __const__num_inports_at_update_prologue_counter ); i += 1'd1 )
          prologue_counter[3'(addr)][3'(i)] <= 3'd0;
      send_accepted <= 12'd0;
    end
    else begin
      for ( int unsigned addr = 1'd0; addr < 4'( __const__ctrl_mem_size_at_update_prologue_counter ); addr += 1'd1 )
        for ( int unsigned i = 1'd0; i < 4'( __const__num_inports_at_update_prologue_counter ); i += 1'd1 )
          prologue_counter[3'(addr)][3'(i)] <= prologue_counter_next[3'(addr)][3'(i)];
      send_accepted <= send_accepted_next;
    end
  end

  assign recv_data_msg[0] = recv_data__msg[0];
  assign recv_data_val[0] = recv_data__val[0];
  assign recv_data_msg[1] = recv_data__msg[1];
  assign recv_data_val[1] = recv_data__val[1];
  assign recv_data_msg[2] = recv_data__msg[2];
  assign recv_data_val[2] = recv_data__val[2];
  assign recv_data_msg[3] = recv_data__msg[3];
  assign recv_data_val[3] = recv_data__val[3];
  assign recv_data_msg[4] = recv_data__msg[4];
  assign recv_data_val[4] = recv_data__val[4];
  assign recv_data_msg[5] = recv_data__msg[5];
  assign recv_data_val[5] = recv_data__val[5];
  assign recv_data_msg[6] = recv_data__msg[6];
  assign recv_data_val[6] = recv_data__val[6];
  assign recv_data_msg[7] = recv_data__msg[7];
  assign recv_data_val[7] = recv_data__val[7];
  assign prologue_count_wire[0][0] = prologue_count_inport[0][0];
  assign prologue_count_wire[0][1] = prologue_count_inport[0][1];
  assign prologue_count_wire[0][2] = prologue_count_inport[0][2];
  assign prologue_count_wire[0][3] = prologue_count_inport[0][3];
  assign prologue_count_wire[0][4] = prologue_count_inport[0][4];
  assign prologue_count_wire[0][5] = prologue_count_inport[0][5];
  assign prologue_count_wire[0][6] = prologue_count_inport[0][6];
  assign prologue_count_wire[0][7] = prologue_count_inport[0][7];
  assign prologue_count_wire[1][0] = prologue_count_inport[1][0];
  assign prologue_count_wire[1][1] = prologue_count_inport[1][1];
  assign prologue_count_wire[1][2] = prologue_count_inport[1][2];
  assign prologue_count_wire[1][3] = prologue_count_inport[1][3];
  assign prologue_count_wire[1][4] = prologue_count_inport[1][4];
  assign prologue_count_wire[1][5] = prologue_count_inport[1][5];
  assign prologue_count_wire[1][6] = prologue_count_inport[1][6];
  assign prologue_count_wire[1][7] = prologue_count_inport[1][7];
  assign prologue_count_wire[2][0] = prologue_count_inport[2][0];
  assign prologue_count_wire[2][1] = prologue_count_inport[2][1];
  assign prologue_count_wire[2][2] = prologue_count_inport[2][2];
  assign prologue_count_wire[2][3] = prologue_count_inport[2][3];
  assign prologue_count_wire[2][4] = prologue_count_inport[2][4];
  assign prologue_count_wire[2][5] = prologue_count_inport[2][5];
  assign prologue_count_wire[2][6] = prologue_count_inport[2][6];
  assign prologue_count_wire[2][7] = prologue_count_inport[2][7];
  assign prologue_count_wire[3][0] = prologue_count_inport[3][0];
  assign prologue_count_wire[3][1] = prologue_count_inport[3][1];
  assign prologue_count_wire[3][2] = prologue_count_inport[3][2];
  assign prologue_count_wire[3][3] = prologue_count_inport[3][3];
  assign prologue_count_wire[3][4] = prologue_count_inport[3][4];
  assign prologue_count_wire[3][5] = prologue_count_inport[3][5];
  assign prologue_count_wire[3][6] = prologue_count_inport[3][6];
  assign prologue_count_wire[3][7] = prologue_count_inport[3][7];
  assign prologue_count_wire[4][0] = prologue_count_inport[4][0];
  assign prologue_count_wire[4][1] = prologue_count_inport[4][1];
  assign prologue_count_wire[4][2] = prologue_count_inport[4][2];
  assign prologue_count_wire[4][3] = prologue_count_inport[4][3];
  assign prologue_count_wire[4][4] = prologue_count_inport[4][4];
  assign prologue_count_wire[4][5] = prologue_count_inport[4][5];
  assign prologue_count_wire[4][6] = prologue_count_inport[4][6];
  assign prologue_count_wire[4][7] = prologue_count_inport[4][7];
  assign prologue_count_wire[5][0] = prologue_count_inport[5][0];
  assign prologue_count_wire[5][1] = prologue_count_inport[5][1];
  assign prologue_count_wire[5][2] = prologue_count_inport[5][2];
  assign prologue_count_wire[5][3] = prologue_count_inport[5][3];
  assign prologue_count_wire[5][4] = prologue_count_inport[5][4];
  assign prologue_count_wire[5][5] = prologue_count_inport[5][5];
  assign prologue_count_wire[5][6] = prologue_count_inport[5][6];
  assign prologue_count_wire[5][7] = prologue_count_inport[5][7];
  assign prologue_count_wire[6][0] = prologue_count_inport[6][0];
  assign prologue_count_wire[6][1] = prologue_count_inport[6][1];
  assign prologue_count_wire[6][2] = prologue_count_inport[6][2];
  assign prologue_count_wire[6][3] = prologue_count_inport[6][3];
  assign prologue_count_wire[6][4] = prologue_count_inport[6][4];
  assign prologue_count_wire[6][5] = prologue_count_inport[6][5];
  assign prologue_count_wire[6][6] = prologue_count_inport[6][6];
  assign prologue_count_wire[6][7] = prologue_count_inport[6][7];
  assign prologue_count_wire[7][0] = prologue_count_inport[7][0];
  assign prologue_count_wire[7][1] = prologue_count_inport[7][1];
  assign prologue_count_wire[7][2] = prologue_count_inport[7][2];
  assign prologue_count_wire[7][3] = prologue_count_inport[7][3];
  assign prologue_count_wire[7][4] = prologue_count_inport[7][4];
  assign prologue_count_wire[7][5] = prologue_count_inport[7][5];
  assign prologue_count_wire[7][6] = prologue_count_inport[7][6];
  assign prologue_count_wire[7][7] = prologue_count_inport[7][7];

endmodule


// PyMTL Component RegisterFile Definition
// Full name: RegisterFile__Type_CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1__nregs_2__rd_ports_1__wr_ports_1__const_zero_False
// At /cgra/venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/register_files.py

module RegisterFile__da749a1852bb59a5
(
  input  logic [0:0] clk ,
  input  logic [0:0] raddr [0:0],
  output CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 rdata [0:0],
  input  logic [0:0] reset ,
  input  logic [0:0] waddr [0:0],
  input  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 wdata [0:0],
  input  logic [0:0] wen [0:0]
);
  localparam logic [0:0] __const__rd_ports_at_up_rf_read  = 1'd1;
  localparam logic [0:0] __const__wr_ports_at_up_rf_write  = 1'd1;
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 regs [0:1];

  // PyMTL Update Block Source
  // At /cgra/venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/register_files.py:20
  // @update
  // def up_rf_read():
  //   for i in range( rd_ports ):
  //     s.rdata[i] @= s.regs[ s.raddr[i] ]
  
  always_comb begin : up_rf_read
    for ( int unsigned i = 1'd0; i < 1'( __const__rd_ports_at_up_rf_read ); i += 1'd1 )
      rdata[1'(i)] = regs[raddr[1'(i)]];
  end

  // PyMTL Update Block Source
  // At /cgra/venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/register_files.py:32
  // @update_ff
  // def up_rf_write():
  //   for i in range( wr_ports ):
  //     if s.wen[i]:
  //       s.regs[ s.waddr[i] ] <<= s.wdata[i]
  
  always_ff @(posedge clk) begin : up_rf_write
    for ( int unsigned i = 1'd0; i < 1'( __const__wr_ports_at_up_rf_write ); i += 1'd1 )
      if ( wen[1'(i)] ) begin
        regs[waddr[1'(i)]] <= wdata[1'(i)];
      end
  end

endmodule


// PyMTL Component NormalQueueDpathRTL Definition
// Full name: NormalQueueDpathRTL__EntryType_CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1__num_entries_2
// At /cgra/VectorCGRA/lib/basic/val_rdy/queues.py

module NormalQueueDpathRTL__e10c2d77bcb9538e
(
  input  logic [0:0] clk ,
  input  logic [0:0] raddr ,
  input  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 recv_msg ,
  input  logic [0:0] reset ,
  output CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 send_msg ,
  input  logic [0:0] waddr ,
  input  logic [0:0] wen 
);
  //-------------------------------------------------------------
  // Component rf
  //-------------------------------------------------------------

  logic [0:0] rf__clk;
  logic [0:0] rf__raddr [0:0];
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 rf__rdata [0:0];
  logic [0:0] rf__reset;
  logic [0:0] rf__waddr [0:0];
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 rf__wdata [0:0];
  logic [0:0] rf__wen [0:0];

  RegisterFile__da749a1852bb59a5 rf
  (
    .clk( rf__clk ),
    .raddr( rf__raddr ),
    .rdata( rf__rdata ),
    .reset( rf__reset ),
    .waddr( rf__waddr ),
    .wdata( rf__wdata ),
    .wen( rf__wen )
  );

  //-------------------------------------------------------------
  // End of component rf
  //-------------------------------------------------------------

  assign rf__clk = clk;
  assign rf__reset = reset;
  assign rf__raddr[0] = raddr;
  assign send_msg = rf__rdata[0];
  assign rf__wen[0] = wen;
  assign rf__waddr[0] = waddr;
  assign rf__wdata[0] = recv_msg;

endmodule


// PyMTL Component NormalQueueRTL Definition
// Full name: NormalQueueRTL__EntryType_CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1__num_entries_2
// At /cgra/VectorCGRA/lib/basic/val_rdy/queues.py

module NormalQueueRTL__e10c2d77bcb9538e
(
  input  logic [0:0] clk ,
  output logic [1:0] count ,
  input  logic [0:0] reset ,
  input CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 recv__msg  ,
  output logic [0:0] recv__rdy  ,
  input logic [0:0] recv__val  ,
  output CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 send__msg  ,
  input logic [0:0] send__rdy  ,
  output logic [0:0] send__val  
);
  //-------------------------------------------------------------
  // Component ctrl
  //-------------------------------------------------------------

  logic [0:0] ctrl__clk;
  logic [1:0] ctrl__count;
  logic [0:0] ctrl__raddr;
  logic [0:0] ctrl__recv_rdy;
  logic [0:0] ctrl__recv_val;
  logic [0:0] ctrl__reset;
  logic [0:0] ctrl__send_rdy;
  logic [0:0] ctrl__send_val;
  logic [0:0] ctrl__waddr;
  logic [0:0] ctrl__wen;

  NormalQueueCtrlRTL__num_entries_2 ctrl
  (
    .clk( ctrl__clk ),
    .count( ctrl__count ),
    .raddr( ctrl__raddr ),
    .recv_rdy( ctrl__recv_rdy ),
    .recv_val( ctrl__recv_val ),
    .reset( ctrl__reset ),
    .send_rdy( ctrl__send_rdy ),
    .send_val( ctrl__send_val ),
    .waddr( ctrl__waddr ),
    .wen( ctrl__wen )
  );

  //-------------------------------------------------------------
  // End of component ctrl
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component dpath
  //-------------------------------------------------------------

  logic [0:0] dpath__clk;
  logic [0:0] dpath__raddr;
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 dpath__recv_msg;
  logic [0:0] dpath__reset;
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 dpath__send_msg;
  logic [0:0] dpath__waddr;
  logic [0:0] dpath__wen;

  NormalQueueDpathRTL__e10c2d77bcb9538e dpath
  (
    .clk( dpath__clk ),
    .raddr( dpath__raddr ),
    .recv_msg( dpath__recv_msg ),
    .reset( dpath__reset ),
    .send_msg( dpath__send_msg ),
    .waddr( dpath__waddr ),
    .wen( dpath__wen )
  );

  //-------------------------------------------------------------
  // End of component dpath
  //-------------------------------------------------------------

  assign ctrl__clk = clk;
  assign ctrl__reset = reset;
  assign dpath__clk = clk;
  assign dpath__reset = reset;
  assign dpath__wen = ctrl__wen;
  assign dpath__waddr = ctrl__waddr;
  assign dpath__raddr = ctrl__raddr;
  assign ctrl__recv_val = recv__val;
  assign recv__rdy = ctrl__recv_rdy;
  assign dpath__recv_msg = recv__msg;
  assign send__val = ctrl__send_val;
  assign ctrl__send_rdy = send__rdy;
  assign send__msg = dpath__send_msg;
  assign count = ctrl__count;

endmodule


// PyMTL Component ChannelRTL Definition
// Full name: ChannelRTL__PacketType_CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1__QueueType_NormalQueueRTL__latency_1
// At /cgra/VectorCGRA/noc/PyOCN/pymtl3_net/channel/ChannelRTL.py

module ChannelRTL__d316842813c529a6
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 recv__msg  ,
  output logic [0:0] recv__rdy  ,
  input logic [0:0] recv__val  ,
  output CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 send__msg  ,
  input logic [0:0] send__rdy  ,
  output logic [0:0] send__val  
);
  //-------------------------------------------------------------
  // Component queues[0:0]
  //-------------------------------------------------------------

  logic [0:0] queues__clk [0:0];
  logic [1:0] queues__count [0:0];
  logic [0:0] queues__reset [0:0];
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 queues__recv__msg [0:0];
  logic [0:0] queues__recv__rdy [0:0];
  logic [0:0] queues__recv__val [0:0];
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 queues__send__msg [0:0];
  logic [0:0] queues__send__rdy [0:0];
  logic [0:0] queues__send__val [0:0];

  NormalQueueRTL__e10c2d77bcb9538e queues__0
  (
    .clk( queues__clk[0] ),
    .count( queues__count[0] ),
    .reset( queues__reset[0] ),
    .recv__msg( queues__recv__msg[0] ),
    .recv__rdy( queues__recv__rdy[0] ),
    .recv__val( queues__recv__val[0] ),
    .send__msg( queues__send__msg[0] ),
    .send__rdy( queues__send__rdy[0] ),
    .send__val( queues__send__val[0] )
  );

  //-------------------------------------------------------------
  // End of component queues[0:0]
  //-------------------------------------------------------------

  assign queues__clk[0] = clk;
  assign queues__reset[0] = reset;
  assign queues__recv__msg[0] = recv__msg;
  assign recv__rdy = queues__recv__rdy[0];
  assign queues__recv__val[0] = recv__val;
  assign send__msg = queues__send__msg[0];
  assign queues__send__rdy[0] = send__rdy;
  assign send__val = queues__send__val[0];

endmodule


// PyMTL Component LinkOrRTL Definition
// Full name: LinkOrRTL__DataType_CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1
// At /cgra/VectorCGRA/noc/LinkOrRTL.py

module LinkOrRTL__a54ca58e7852ace8
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 recv_fu__msg  ,
  output logic [0:0] recv_fu__rdy  ,
  input logic [0:0] recv_fu__val  ,
  input CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 recv_xbar__msg  ,
  output logic [0:0] recv_xbar__rdy  ,
  input logic [0:0] recv_xbar__val  ,
  output CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 send__msg  ,
  input logic [0:0] send__rdy  ,
  output logic [0:0] send__val  
);

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/noc/LinkOrRTL.py:28
  // @update
  // def process():
  //   # Initializes the delivered message.
  //   s.send.msg @= DataType()
  // 
  //   # The messages from two sources (i.e., xbar and FU) won't be valid
  //   # simultaneously (confliction would be caused if they both are valid),
  //   # which is guaranteed by the compiler/software.
  //   s.send.msg.predicate @= s.recv_fu.msg.predicate | s.recv_xbar.msg.predicate
  //   s.send.msg.payload @= s.recv_xbar.msg.payload | s.recv_fu.msg.payload
  // 
  //   # FIXME: bypass won't be necessary any more with separate xbar design.
  //   # s.send.msg.bypass @= 0
  //   # s.send.msg.delay @= s.recv_fu.msg.delay | s.recv_xbar.msg.delay
  // 
  //   s.send.val @= s.recv_fu.val | s.recv_xbar.val
  //   s.recv_fu.rdy @= s.send.rdy
  //   s.recv_xbar.rdy @= s.send.rdy
  
  always_comb begin : process
    send__msg = { 32'd0, 1'd0, 1'd0, 1'd0 };
    send__msg.predicate = recv_fu__msg.predicate | recv_xbar__msg.predicate;
    send__msg.payload = recv_xbar__msg.payload | recv_fu__msg.payload;
    send__val = recv_fu__val | recv_xbar__val;
    recv_fu__rdy = send__rdy;
    recv_xbar__rdy = send__rdy;
  end

endmodule


// PyMTL Component TileRTL Definition
// Full name: TileRTL__IntraCgraPktType_IntraCgraPacket_4_4x1_4_8_2_CgraPayload__11cd3f8c0d91825c__ctrl_mem_size_8__data_mem_size_512__num_ctrl_8__total_steps_8__num_fu_inports_4__num_fu_outports_2__num_tile_inports_8__num_tile_outports_8__num_cgras_4__num_tiles_4__num_registers_per_reg_bank_16__Fu_FlexibleFuRTL__FuList_[<class 'VectorCGRA.fu.single.SelRTL.SelRTL'>, <class 'VectorCGRA.fu.float.FpAddRTL.FpAddRTL'>, <class 'VectorCGRA.fu.single.MulRTL.MulRTL'>, <class 'VectorCGRA.fu.single.LoopControlRTL.LoopControlRTL'>, <class 'VectorCGRA.fu.single.RetRTL.RetRTL'>, <class 'VectorCGRA.fu.single.ExclusiveDivRTL.ExclusiveDivRTL'>, <class 'VectorCGRA.fu.single.AdderRTL.AdderRTL'>, <class 'VectorCGRA.fu.single.MemUnitRTL.MemUnitRTL'>, <class 'VectorCGRA.fu.float.FpMulRTL.FpMulRTL'>, <class 'VectorCGRA.fu.single.GrantRTL.GrantRTL'>, <class 'VectorCGRA.fu.single.CompRTL.CompRTL'>, <class 'VectorCGRA.fu.single.ShifterRTL.ShifterRTL'>, <class 'VectorCGRA.fu.single.PhiRTL.PhiRTL'>, <class 'VectorCGRA.fu.single.LogicRTL.LogicRTL'>, <class 'VectorCGRA.fu.single.ConstRTL.ConstRTL'>, <class 'VectorCGRA.fu.single.NahRTL.NahRTL'>]
// At /cgra/VectorCGRA/tile/TileRTL.py

module TileRTL__526e2eb7b6177797
(
  input  logic [1:0] cgra_id ,
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input  logic [2:0] tile_id ,
  input CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 from_mem_rdata__msg  ,
  output logic [0:0] from_mem_rdata__rdy  ,
  input logic [0:0] from_mem_rdata__val  ,
  input CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 recv_data__msg [0:7] ,
  output logic [0:0] recv_data__rdy [0:7] ,
  input logic [0:0] recv_data__val [0:7] ,
  input IntraCgraPacket_4_4x1_4_8_2_CgraPayload__11cd3f8c0d91825c recv_from_controller_pkt__msg  ,
  output logic [0:0] recv_from_controller_pkt__rdy  ,
  input logic [0:0] recv_from_controller_pkt__val  ,
  output CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 send_data__msg [0:7] ,
  input logic [0:0] send_data__rdy [0:7] ,
  output logic [0:0] send_data__val [0:7] ,
  output IntraCgraPacket_4_4x1_4_8_2_CgraPayload__11cd3f8c0d91825c send_to_controller_pkt__msg  ,
  input logic [0:0] send_to_controller_pkt__rdy  ,
  output logic [0:0] send_to_controller_pkt__val  ,
  output logic [8:0] to_mem_raddr__msg  ,
  input logic [0:0] to_mem_raddr__rdy  ,
  output logic [0:0] to_mem_raddr__val  ,
  output logic [8:0] to_mem_waddr__msg  ,
  input logic [0:0] to_mem_waddr__rdy  ,
  output logic [0:0] to_mem_waddr__val  ,
  output CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 to_mem_wdata__msg  ,
  input logic [0:0] to_mem_wdata__rdy  ,
  output logic [0:0] to_mem_wdata__val  
);
  localparam logic [1:0] __const__CMD_CONFIG  = 2'd3;
  localparam logic [2:0] __const__CMD_CONFIG_PROLOGUE_FU  = 3'd4;
  localparam logic [2:0] __const__CMD_CONFIG_PROLOGUE_FU_CROSSBAR  = 3'd5;
  localparam logic [2:0] __const__CMD_CONFIG_PROLOGUE_ROUTING_CROSSBAR  = 3'd6;
  localparam logic [2:0] __const__CMD_CONFIG_TOTAL_CTRL_COUNT  = 3'd7;
  localparam logic [3:0] __const__CMD_CONFIG_COUNT_PER_ITER  = 4'd8;
  localparam logic [4:0] __const__CMD_GLOBAL_REDUCE_ADD_RESPONSE  = 5'd20;
  localparam logic [4:0] __const__CMD_GLOBAL_REDUCE_MUL_RESPONSE  = 5'd21;
  localparam logic [0:0] __const__CMD_LAUNCH  = 1'd0;
  localparam logic [4:0] __const__CMD_CONFIG_LOOP_LOWER  = 5'd28;
  localparam logic [4:0] __const__CMD_CONFIG_LOOP_UPPER  = 5'd29;
  localparam logic [4:0] __const__CMD_CONFIG_LOOP_STEP  = 5'd30;
  localparam logic [3:0] __const__CMD_CONST  = 4'd13;
  logic [0:0] element_done;
  logic [0:0] fu_crossbar_done;
  logic [0:0] routing_crossbar_done;
  //-------------------------------------------------------------
  // Component const_mem
  //-------------------------------------------------------------

  logic [0:0] const_mem__clear;
  logic [0:0] const_mem__clk;
  logic [0:0] const_mem__ctrl_proceed;
  logic [0:0] const_mem__reset;
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 const_mem__recv_const__msg;
  logic [0:0] const_mem__recv_const__rdy;
  logic [0:0] const_mem__recv_const__val;
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 const_mem__send_const__msg;
  logic [0:0] const_mem__send_const__rdy;
  logic [0:0] const_mem__send_const__val;

  ConstQueueDynamicRTL__04942ff39dc493d7 const_mem
  (
    .clear( const_mem__clear ),
    .clk( const_mem__clk ),
    .ctrl_proceed( const_mem__ctrl_proceed ),
    .reset( const_mem__reset ),
    .recv_const__msg( const_mem__recv_const__msg ),
    .recv_const__rdy( const_mem__recv_const__rdy ),
    .recv_const__val( const_mem__recv_const__val ),
    .send_const__msg( const_mem__send_const__msg ),
    .send_const__rdy( const_mem__send_const__rdy ),
    .send_const__val( const_mem__send_const__val )
  );

  //-------------------------------------------------------------
  // End of component const_mem
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component ctrl_mem
  //-------------------------------------------------------------

  logic [1:0] ctrl_mem__cgra_id;
  logic [0:0] ctrl_mem__clk;
  logic [2:0] ctrl_mem__ctrl_addr_outport;
  logic [2:0] ctrl_mem__prologue_count_outport_fu;
  logic [2:0] ctrl_mem__prologue_count_outport_fu_crossbar [0:7][0:1];
  logic [2:0] ctrl_mem__prologue_count_outport_routing_crossbar [0:7][0:7];
  logic [0:0] ctrl_mem__reset;
  logic [2:0] ctrl_mem__tile_id;
  MultiCgraPayload_Cmd_Data_DataAddr_Ctrl_CtrlAddr__a0427cd98cfcae6f ctrl_mem__recv_from_element__msg;
  logic [0:0] ctrl_mem__recv_from_element__rdy;
  logic [0:0] ctrl_mem__recv_from_element__val;
  IntraCgraPacket_4_4x1_4_8_2_CgraPayload__11cd3f8c0d91825c ctrl_mem__recv_pkt_from_controller__msg;
  logic [0:0] ctrl_mem__recv_pkt_from_controller__rdy;
  logic [0:0] ctrl_mem__recv_pkt_from_controller__val;
  CGRAConfig_7_4_2_8_8_3__603a41f5d0e2436f ctrl_mem__send_ctrl__msg;
  logic [0:0] ctrl_mem__send_ctrl__rdy;
  logic [0:0] ctrl_mem__send_ctrl__val;
  IntraCgraPacket_4_4x1_4_8_2_CgraPayload__11cd3f8c0d91825c ctrl_mem__send_pkt_to_controller__msg;
  logic [0:0] ctrl_mem__send_pkt_to_controller__rdy;
  logic [0:0] ctrl_mem__send_pkt_to_controller__val;
  MultiCgraPayload_Cmd_Data_DataAddr_Ctrl_CtrlAddr__a0427cd98cfcae6f ctrl_mem__send_to_element__msg;
  logic [0:0] ctrl_mem__send_to_element__rdy;
  logic [0:0] ctrl_mem__send_to_element__val;

  CtrlMemDynamicRTL__06f86f060b697c96 ctrl_mem
  (
    .cgra_id( ctrl_mem__cgra_id ),
    .clk( ctrl_mem__clk ),
    .ctrl_addr_outport( ctrl_mem__ctrl_addr_outport ),
    .prologue_count_outport_fu( ctrl_mem__prologue_count_outport_fu ),
    .prologue_count_outport_fu_crossbar( ctrl_mem__prologue_count_outport_fu_crossbar ),
    .prologue_count_outport_routing_crossbar( ctrl_mem__prologue_count_outport_routing_crossbar ),
    .reset( ctrl_mem__reset ),
    .tile_id( ctrl_mem__tile_id ),
    .recv_from_element__msg( ctrl_mem__recv_from_element__msg ),
    .recv_from_element__rdy( ctrl_mem__recv_from_element__rdy ),
    .recv_from_element__val( ctrl_mem__recv_from_element__val ),
    .recv_pkt_from_controller__msg( ctrl_mem__recv_pkt_from_controller__msg ),
    .recv_pkt_from_controller__rdy( ctrl_mem__recv_pkt_from_controller__rdy ),
    .recv_pkt_from_controller__val( ctrl_mem__recv_pkt_from_controller__val ),
    .send_ctrl__msg( ctrl_mem__send_ctrl__msg ),
    .send_ctrl__rdy( ctrl_mem__send_ctrl__rdy ),
    .send_ctrl__val( ctrl_mem__send_ctrl__val ),
    .send_pkt_to_controller__msg( ctrl_mem__send_pkt_to_controller__msg ),
    .send_pkt_to_controller__rdy( ctrl_mem__send_pkt_to_controller__rdy ),
    .send_pkt_to_controller__val( ctrl_mem__send_pkt_to_controller__val ),
    .send_to_element__msg( ctrl_mem__send_to_element__msg ),
    .send_to_element__rdy( ctrl_mem__send_to_element__rdy ),
    .send_to_element__val( ctrl_mem__send_to_element__val )
  );

  //-------------------------------------------------------------
  // End of component ctrl_mem
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component element
  //-------------------------------------------------------------

  logic [0:0] element__clear [0:15];
  logic [0:0] element__clk;
  logic [2:0] element__ctrl_addr_inport;
  logic [2:0] element__prologue_count_inport;
  logic [0:0] element__reset;
  logic [2:0] element__tile_id;
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 element__from_mem_rdata__msg [0:15];
  logic [0:0] element__from_mem_rdata__rdy [0:15];
  logic [0:0] element__from_mem_rdata__val [0:15];
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 element__recv_const__msg;
  logic [0:0] element__recv_const__rdy;
  logic [0:0] element__recv_const__val;
  MultiCgraPayload_Cmd_Data_DataAddr_Ctrl_CtrlAddr__a0427cd98cfcae6f element__recv_from_ctrl_mem__msg;
  logic [0:0] element__recv_from_ctrl_mem__rdy;
  logic [0:0] element__recv_from_ctrl_mem__val;
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 element__recv_in__msg [0:3];
  logic [0:0] element__recv_in__rdy [0:3];
  logic [0:0] element__recv_in__val [0:3];
  CGRAConfig_7_4_2_8_8_3__603a41f5d0e2436f element__recv_opt__msg;
  logic [0:0] element__recv_opt__rdy;
  logic [0:0] element__recv_opt__val;
  IntraCgraPacket_4_4x1_4_8_2_CgraPayload__11cd3f8c0d91825c element__recv_pkt_from_controller__msg;
  logic [0:0] element__recv_pkt_from_controller__rdy;
  logic [0:0] element__recv_pkt_from_controller__val;
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 element__send_out__msg [0:1];
  logic [0:0] element__send_out__rdy [0:1];
  logic [0:0] element__send_out__val [0:1];
  MultiCgraPayload_Cmd_Data_DataAddr_Ctrl_CtrlAddr__a0427cd98cfcae6f element__send_to_ctrl_mem__msg;
  logic [0:0] element__send_to_ctrl_mem__rdy;
  logic [0:0] element__send_to_ctrl_mem__val;
  logic [8:0] element__to_mem_raddr__msg [0:15];
  logic [0:0] element__to_mem_raddr__rdy [0:15];
  logic [0:0] element__to_mem_raddr__val [0:15];
  logic [8:0] element__to_mem_waddr__msg [0:15];
  logic [0:0] element__to_mem_waddr__rdy [0:15];
  logic [0:0] element__to_mem_waddr__val [0:15];
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 element__to_mem_wdata__msg [0:15];
  logic [0:0] element__to_mem_wdata__rdy [0:15];
  logic [0:0] element__to_mem_wdata__val [0:15];

  FlexibleFuRTL__44794627483a491e element
  (
    .clear( element__clear ),
    .clk( element__clk ),
    .ctrl_addr_inport( element__ctrl_addr_inport ),
    .prologue_count_inport( element__prologue_count_inport ),
    .reset( element__reset ),
    .tile_id( element__tile_id ),
    .from_mem_rdata__msg( element__from_mem_rdata__msg ),
    .from_mem_rdata__rdy( element__from_mem_rdata__rdy ),
    .from_mem_rdata__val( element__from_mem_rdata__val ),
    .recv_const__msg( element__recv_const__msg ),
    .recv_const__rdy( element__recv_const__rdy ),
    .recv_const__val( element__recv_const__val ),
    .recv_from_ctrl_mem__msg( element__recv_from_ctrl_mem__msg ),
    .recv_from_ctrl_mem__rdy( element__recv_from_ctrl_mem__rdy ),
    .recv_from_ctrl_mem__val( element__recv_from_ctrl_mem__val ),
    .recv_in__msg( element__recv_in__msg ),
    .recv_in__rdy( element__recv_in__rdy ),
    .recv_in__val( element__recv_in__val ),
    .recv_opt__msg( element__recv_opt__msg ),
    .recv_opt__rdy( element__recv_opt__rdy ),
    .recv_opt__val( element__recv_opt__val ),
    .recv_pkt_from_controller__msg( element__recv_pkt_from_controller__msg ),
    .recv_pkt_from_controller__rdy( element__recv_pkt_from_controller__rdy ),
    .recv_pkt_from_controller__val( element__recv_pkt_from_controller__val ),
    .send_out__msg( element__send_out__msg ),
    .send_out__rdy( element__send_out__rdy ),
    .send_out__val( element__send_out__val ),
    .send_to_ctrl_mem__msg( element__send_to_ctrl_mem__msg ),
    .send_to_ctrl_mem__rdy( element__send_to_ctrl_mem__rdy ),
    .send_to_ctrl_mem__val( element__send_to_ctrl_mem__val ),
    .to_mem_raddr__msg( element__to_mem_raddr__msg ),
    .to_mem_raddr__rdy( element__to_mem_raddr__rdy ),
    .to_mem_raddr__val( element__to_mem_raddr__val ),
    .to_mem_waddr__msg( element__to_mem_waddr__msg ),
    .to_mem_waddr__rdy( element__to_mem_waddr__rdy ),
    .to_mem_waddr__val( element__to_mem_waddr__val ),
    .to_mem_wdata__msg( element__to_mem_wdata__msg ),
    .to_mem_wdata__rdy( element__to_mem_wdata__rdy ),
    .to_mem_wdata__val( element__to_mem_wdata__val )
  );

  //-------------------------------------------------------------
  // End of component element
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component fu_crossbar
  //-------------------------------------------------------------

  logic [1:0] fu_crossbar__cgra_id;
  logic [0:0] fu_crossbar__clear;
  logic [0:0] fu_crossbar__clk;
  logic [0:0] fu_crossbar__compute_done;
  logic [0:0] fu_crossbar__crossbar_id;
  logic [1:0] fu_crossbar__crossbar_outport [0:11];
  logic [2:0] fu_crossbar__ctrl_addr_inport;
  logic [2:0] fu_crossbar__prologue_count_inport [0:7][0:1];
  logic [0:0] fu_crossbar__reset;
  logic [2:0] fu_crossbar__tile_id;
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 fu_crossbar__recv_data__msg [0:1];
  logic [0:0] fu_crossbar__recv_data__rdy [0:1];
  logic [0:0] fu_crossbar__recv_data__val [0:1];
  CGRAConfig_7_4_2_8_8_3__603a41f5d0e2436f fu_crossbar__recv_opt__msg;
  logic [0:0] fu_crossbar__recv_opt__rdy;
  logic [0:0] fu_crossbar__recv_opt__val;
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 fu_crossbar__send_data__msg [0:11];
  logic [0:0] fu_crossbar__send_data__rdy [0:11];
  logic [0:0] fu_crossbar__send_data__val [0:11];

  CrossbarRTL__06481a49e1920669 fu_crossbar
  (
    .cgra_id( fu_crossbar__cgra_id ),
    .clear( fu_crossbar__clear ),
    .clk( fu_crossbar__clk ),
    .compute_done( fu_crossbar__compute_done ),
    .crossbar_id( fu_crossbar__crossbar_id ),
    .crossbar_outport( fu_crossbar__crossbar_outport ),
    .ctrl_addr_inport( fu_crossbar__ctrl_addr_inport ),
    .prologue_count_inport( fu_crossbar__prologue_count_inport ),
    .reset( fu_crossbar__reset ),
    .tile_id( fu_crossbar__tile_id ),
    .recv_data__msg( fu_crossbar__recv_data__msg ),
    .recv_data__rdy( fu_crossbar__recv_data__rdy ),
    .recv_data__val( fu_crossbar__recv_data__val ),
    .recv_opt__msg( fu_crossbar__recv_opt__msg ),
    .recv_opt__rdy( fu_crossbar__recv_opt__rdy ),
    .recv_opt__val( fu_crossbar__recv_opt__val ),
    .send_data__msg( fu_crossbar__send_data__msg ),
    .send_data__rdy( fu_crossbar__send_data__rdy ),
    .send_data__val( fu_crossbar__send_data__val )
  );

  //-------------------------------------------------------------
  // End of component fu_crossbar
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component register_cluster
  //-------------------------------------------------------------

  logic [0:0] register_cluster__clk;
  CGRAConfig_7_4_2_8_8_3__603a41f5d0e2436f register_cluster__inport_opt;
  logic [0:0] register_cluster__reset;
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 register_cluster__recv_data_from_const__msg [0:3];
  logic [0:0] register_cluster__recv_data_from_const__rdy [0:3];
  logic [0:0] register_cluster__recv_data_from_const__val [0:3];
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 register_cluster__recv_data_from_fu_crossbar__msg [0:3];
  logic [0:0] register_cluster__recv_data_from_fu_crossbar__rdy [0:3];
  logic [0:0] register_cluster__recv_data_from_fu_crossbar__val [0:3];
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 register_cluster__recv_data_from_routing_crossbar__msg [0:3];
  logic [0:0] register_cluster__recv_data_from_routing_crossbar__rdy [0:3];
  logic [0:0] register_cluster__recv_data_from_routing_crossbar__val [0:3];
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 register_cluster__send_data_to_fu__msg [0:3];
  logic [0:0] register_cluster__send_data_to_fu__rdy [0:3];
  logic [0:0] register_cluster__send_data_to_fu__val [0:3];

  RegisterClusterRTL__8a44c1a18964df48 register_cluster
  (
    .clk( register_cluster__clk ),
    .inport_opt( register_cluster__inport_opt ),
    .reset( register_cluster__reset ),
    .recv_data_from_const__msg( register_cluster__recv_data_from_const__msg ),
    .recv_data_from_const__rdy( register_cluster__recv_data_from_const__rdy ),
    .recv_data_from_const__val( register_cluster__recv_data_from_const__val ),
    .recv_data_from_fu_crossbar__msg( register_cluster__recv_data_from_fu_crossbar__msg ),
    .recv_data_from_fu_crossbar__rdy( register_cluster__recv_data_from_fu_crossbar__rdy ),
    .recv_data_from_fu_crossbar__val( register_cluster__recv_data_from_fu_crossbar__val ),
    .recv_data_from_routing_crossbar__msg( register_cluster__recv_data_from_routing_crossbar__msg ),
    .recv_data_from_routing_crossbar__rdy( register_cluster__recv_data_from_routing_crossbar__rdy ),
    .recv_data_from_routing_crossbar__val( register_cluster__recv_data_from_routing_crossbar__val ),
    .send_data_to_fu__msg( register_cluster__send_data_to_fu__msg ),
    .send_data_to_fu__rdy( register_cluster__send_data_to_fu__rdy ),
    .send_data_to_fu__val( register_cluster__send_data_to_fu__val )
  );

  //-------------------------------------------------------------
  // End of component register_cluster
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component routing_crossbar
  //-------------------------------------------------------------

  logic [1:0] routing_crossbar__cgra_id;
  logic [0:0] routing_crossbar__clear;
  logic [0:0] routing_crossbar__clk;
  logic [0:0] routing_crossbar__compute_done;
  logic [0:0] routing_crossbar__crossbar_id;
  logic [3:0] routing_crossbar__crossbar_outport [0:11];
  logic [2:0] routing_crossbar__ctrl_addr_inport;
  logic [2:0] routing_crossbar__prologue_count_inport [0:7][0:7];
  logic [0:0] routing_crossbar__reset;
  logic [2:0] routing_crossbar__tile_id;
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 routing_crossbar__recv_data__msg [0:7];
  logic [0:0] routing_crossbar__recv_data__rdy [0:7];
  logic [0:0] routing_crossbar__recv_data__val [0:7];
  CGRAConfig_7_4_2_8_8_3__603a41f5d0e2436f routing_crossbar__recv_opt__msg;
  logic [0:0] routing_crossbar__recv_opt__rdy;
  logic [0:0] routing_crossbar__recv_opt__val;
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 routing_crossbar__send_data__msg [0:11];
  logic [0:0] routing_crossbar__send_data__rdy [0:11];
  logic [0:0] routing_crossbar__send_data__val [0:11];

  CrossbarRTL__2e8e5b6a3eee594d routing_crossbar
  (
    .cgra_id( routing_crossbar__cgra_id ),
    .clear( routing_crossbar__clear ),
    .clk( routing_crossbar__clk ),
    .compute_done( routing_crossbar__compute_done ),
    .crossbar_id( routing_crossbar__crossbar_id ),
    .crossbar_outport( routing_crossbar__crossbar_outport ),
    .ctrl_addr_inport( routing_crossbar__ctrl_addr_inport ),
    .prologue_count_inport( routing_crossbar__prologue_count_inport ),
    .reset( routing_crossbar__reset ),
    .tile_id( routing_crossbar__tile_id ),
    .recv_data__msg( routing_crossbar__recv_data__msg ),
    .recv_data__rdy( routing_crossbar__recv_data__rdy ),
    .recv_data__val( routing_crossbar__recv_data__val ),
    .recv_opt__msg( routing_crossbar__recv_opt__msg ),
    .recv_opt__rdy( routing_crossbar__recv_opt__rdy ),
    .recv_opt__val( routing_crossbar__recv_opt__val ),
    .send_data__msg( routing_crossbar__send_data__msg ),
    .send_data__rdy( routing_crossbar__send_data__rdy ),
    .send_data__val( routing_crossbar__send_data__val )
  );

  //-------------------------------------------------------------
  // End of component routing_crossbar
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component tile_in_channel[0:7]
  //-------------------------------------------------------------

  logic [0:0] tile_in_channel__clk [0:7];
  logic [0:0] tile_in_channel__reset [0:7];
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 tile_in_channel__recv__msg [0:7];
  logic [0:0] tile_in_channel__recv__rdy [0:7];
  logic [0:0] tile_in_channel__recv__val [0:7];
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 tile_in_channel__send__msg [0:7];
  logic [0:0] tile_in_channel__send__rdy [0:7];
  logic [0:0] tile_in_channel__send__val [0:7];

  ChannelRTL__d316842813c529a6 tile_in_channel__0
  (
    .clk( tile_in_channel__clk[0] ),
    .reset( tile_in_channel__reset[0] ),
    .recv__msg( tile_in_channel__recv__msg[0] ),
    .recv__rdy( tile_in_channel__recv__rdy[0] ),
    .recv__val( tile_in_channel__recv__val[0] ),
    .send__msg( tile_in_channel__send__msg[0] ),
    .send__rdy( tile_in_channel__send__rdy[0] ),
    .send__val( tile_in_channel__send__val[0] )
  );

  ChannelRTL__d316842813c529a6 tile_in_channel__1
  (
    .clk( tile_in_channel__clk[1] ),
    .reset( tile_in_channel__reset[1] ),
    .recv__msg( tile_in_channel__recv__msg[1] ),
    .recv__rdy( tile_in_channel__recv__rdy[1] ),
    .recv__val( tile_in_channel__recv__val[1] ),
    .send__msg( tile_in_channel__send__msg[1] ),
    .send__rdy( tile_in_channel__send__rdy[1] ),
    .send__val( tile_in_channel__send__val[1] )
  );

  ChannelRTL__d316842813c529a6 tile_in_channel__2
  (
    .clk( tile_in_channel__clk[2] ),
    .reset( tile_in_channel__reset[2] ),
    .recv__msg( tile_in_channel__recv__msg[2] ),
    .recv__rdy( tile_in_channel__recv__rdy[2] ),
    .recv__val( tile_in_channel__recv__val[2] ),
    .send__msg( tile_in_channel__send__msg[2] ),
    .send__rdy( tile_in_channel__send__rdy[2] ),
    .send__val( tile_in_channel__send__val[2] )
  );

  ChannelRTL__d316842813c529a6 tile_in_channel__3
  (
    .clk( tile_in_channel__clk[3] ),
    .reset( tile_in_channel__reset[3] ),
    .recv__msg( tile_in_channel__recv__msg[3] ),
    .recv__rdy( tile_in_channel__recv__rdy[3] ),
    .recv__val( tile_in_channel__recv__val[3] ),
    .send__msg( tile_in_channel__send__msg[3] ),
    .send__rdy( tile_in_channel__send__rdy[3] ),
    .send__val( tile_in_channel__send__val[3] )
  );

  ChannelRTL__d316842813c529a6 tile_in_channel__4
  (
    .clk( tile_in_channel__clk[4] ),
    .reset( tile_in_channel__reset[4] ),
    .recv__msg( tile_in_channel__recv__msg[4] ),
    .recv__rdy( tile_in_channel__recv__rdy[4] ),
    .recv__val( tile_in_channel__recv__val[4] ),
    .send__msg( tile_in_channel__send__msg[4] ),
    .send__rdy( tile_in_channel__send__rdy[4] ),
    .send__val( tile_in_channel__send__val[4] )
  );

  ChannelRTL__d316842813c529a6 tile_in_channel__5
  (
    .clk( tile_in_channel__clk[5] ),
    .reset( tile_in_channel__reset[5] ),
    .recv__msg( tile_in_channel__recv__msg[5] ),
    .recv__rdy( tile_in_channel__recv__rdy[5] ),
    .recv__val( tile_in_channel__recv__val[5] ),
    .send__msg( tile_in_channel__send__msg[5] ),
    .send__rdy( tile_in_channel__send__rdy[5] ),
    .send__val( tile_in_channel__send__val[5] )
  );

  ChannelRTL__d316842813c529a6 tile_in_channel__6
  (
    .clk( tile_in_channel__clk[6] ),
    .reset( tile_in_channel__reset[6] ),
    .recv__msg( tile_in_channel__recv__msg[6] ),
    .recv__rdy( tile_in_channel__recv__rdy[6] ),
    .recv__val( tile_in_channel__recv__val[6] ),
    .send__msg( tile_in_channel__send__msg[6] ),
    .send__rdy( tile_in_channel__send__rdy[6] ),
    .send__val( tile_in_channel__send__val[6] )
  );

  ChannelRTL__d316842813c529a6 tile_in_channel__7
  (
    .clk( tile_in_channel__clk[7] ),
    .reset( tile_in_channel__reset[7] ),
    .recv__msg( tile_in_channel__recv__msg[7] ),
    .recv__rdy( tile_in_channel__recv__rdy[7] ),
    .recv__val( tile_in_channel__recv__val[7] ),
    .send__msg( tile_in_channel__send__msg[7] ),
    .send__rdy( tile_in_channel__send__rdy[7] ),
    .send__val( tile_in_channel__send__val[7] )
  );

  //-------------------------------------------------------------
  // End of component tile_in_channel[0:7]
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component tile_out_or_link[0:7]
  //-------------------------------------------------------------

  logic [0:0] tile_out_or_link__clk [0:7];
  logic [0:0] tile_out_or_link__reset [0:7];
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 tile_out_or_link__recv_fu__msg [0:7];
  logic [0:0] tile_out_or_link__recv_fu__rdy [0:7];
  logic [0:0] tile_out_or_link__recv_fu__val [0:7];
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 tile_out_or_link__recv_xbar__msg [0:7];
  logic [0:0] tile_out_or_link__recv_xbar__rdy [0:7];
  logic [0:0] tile_out_or_link__recv_xbar__val [0:7];
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 tile_out_or_link__send__msg [0:7];
  logic [0:0] tile_out_or_link__send__rdy [0:7];
  logic [0:0] tile_out_or_link__send__val [0:7];

  LinkOrRTL__a54ca58e7852ace8 tile_out_or_link__0
  (
    .clk( tile_out_or_link__clk[0] ),
    .reset( tile_out_or_link__reset[0] ),
    .recv_fu__msg( tile_out_or_link__recv_fu__msg[0] ),
    .recv_fu__rdy( tile_out_or_link__recv_fu__rdy[0] ),
    .recv_fu__val( tile_out_or_link__recv_fu__val[0] ),
    .recv_xbar__msg( tile_out_or_link__recv_xbar__msg[0] ),
    .recv_xbar__rdy( tile_out_or_link__recv_xbar__rdy[0] ),
    .recv_xbar__val( tile_out_or_link__recv_xbar__val[0] ),
    .send__msg( tile_out_or_link__send__msg[0] ),
    .send__rdy( tile_out_or_link__send__rdy[0] ),
    .send__val( tile_out_or_link__send__val[0] )
  );

  LinkOrRTL__a54ca58e7852ace8 tile_out_or_link__1
  (
    .clk( tile_out_or_link__clk[1] ),
    .reset( tile_out_or_link__reset[1] ),
    .recv_fu__msg( tile_out_or_link__recv_fu__msg[1] ),
    .recv_fu__rdy( tile_out_or_link__recv_fu__rdy[1] ),
    .recv_fu__val( tile_out_or_link__recv_fu__val[1] ),
    .recv_xbar__msg( tile_out_or_link__recv_xbar__msg[1] ),
    .recv_xbar__rdy( tile_out_or_link__recv_xbar__rdy[1] ),
    .recv_xbar__val( tile_out_or_link__recv_xbar__val[1] ),
    .send__msg( tile_out_or_link__send__msg[1] ),
    .send__rdy( tile_out_or_link__send__rdy[1] ),
    .send__val( tile_out_or_link__send__val[1] )
  );

  LinkOrRTL__a54ca58e7852ace8 tile_out_or_link__2
  (
    .clk( tile_out_or_link__clk[2] ),
    .reset( tile_out_or_link__reset[2] ),
    .recv_fu__msg( tile_out_or_link__recv_fu__msg[2] ),
    .recv_fu__rdy( tile_out_or_link__recv_fu__rdy[2] ),
    .recv_fu__val( tile_out_or_link__recv_fu__val[2] ),
    .recv_xbar__msg( tile_out_or_link__recv_xbar__msg[2] ),
    .recv_xbar__rdy( tile_out_or_link__recv_xbar__rdy[2] ),
    .recv_xbar__val( tile_out_or_link__recv_xbar__val[2] ),
    .send__msg( tile_out_or_link__send__msg[2] ),
    .send__rdy( tile_out_or_link__send__rdy[2] ),
    .send__val( tile_out_or_link__send__val[2] )
  );

  LinkOrRTL__a54ca58e7852ace8 tile_out_or_link__3
  (
    .clk( tile_out_or_link__clk[3] ),
    .reset( tile_out_or_link__reset[3] ),
    .recv_fu__msg( tile_out_or_link__recv_fu__msg[3] ),
    .recv_fu__rdy( tile_out_or_link__recv_fu__rdy[3] ),
    .recv_fu__val( tile_out_or_link__recv_fu__val[3] ),
    .recv_xbar__msg( tile_out_or_link__recv_xbar__msg[3] ),
    .recv_xbar__rdy( tile_out_or_link__recv_xbar__rdy[3] ),
    .recv_xbar__val( tile_out_or_link__recv_xbar__val[3] ),
    .send__msg( tile_out_or_link__send__msg[3] ),
    .send__rdy( tile_out_or_link__send__rdy[3] ),
    .send__val( tile_out_or_link__send__val[3] )
  );

  LinkOrRTL__a54ca58e7852ace8 tile_out_or_link__4
  (
    .clk( tile_out_or_link__clk[4] ),
    .reset( tile_out_or_link__reset[4] ),
    .recv_fu__msg( tile_out_or_link__recv_fu__msg[4] ),
    .recv_fu__rdy( tile_out_or_link__recv_fu__rdy[4] ),
    .recv_fu__val( tile_out_or_link__recv_fu__val[4] ),
    .recv_xbar__msg( tile_out_or_link__recv_xbar__msg[4] ),
    .recv_xbar__rdy( tile_out_or_link__recv_xbar__rdy[4] ),
    .recv_xbar__val( tile_out_or_link__recv_xbar__val[4] ),
    .send__msg( tile_out_or_link__send__msg[4] ),
    .send__rdy( tile_out_or_link__send__rdy[4] ),
    .send__val( tile_out_or_link__send__val[4] )
  );

  LinkOrRTL__a54ca58e7852ace8 tile_out_or_link__5
  (
    .clk( tile_out_or_link__clk[5] ),
    .reset( tile_out_or_link__reset[5] ),
    .recv_fu__msg( tile_out_or_link__recv_fu__msg[5] ),
    .recv_fu__rdy( tile_out_or_link__recv_fu__rdy[5] ),
    .recv_fu__val( tile_out_or_link__recv_fu__val[5] ),
    .recv_xbar__msg( tile_out_or_link__recv_xbar__msg[5] ),
    .recv_xbar__rdy( tile_out_or_link__recv_xbar__rdy[5] ),
    .recv_xbar__val( tile_out_or_link__recv_xbar__val[5] ),
    .send__msg( tile_out_or_link__send__msg[5] ),
    .send__rdy( tile_out_or_link__send__rdy[5] ),
    .send__val( tile_out_or_link__send__val[5] )
  );

  LinkOrRTL__a54ca58e7852ace8 tile_out_or_link__6
  (
    .clk( tile_out_or_link__clk[6] ),
    .reset( tile_out_or_link__reset[6] ),
    .recv_fu__msg( tile_out_or_link__recv_fu__msg[6] ),
    .recv_fu__rdy( tile_out_or_link__recv_fu__rdy[6] ),
    .recv_fu__val( tile_out_or_link__recv_fu__val[6] ),
    .recv_xbar__msg( tile_out_or_link__recv_xbar__msg[6] ),
    .recv_xbar__rdy( tile_out_or_link__recv_xbar__rdy[6] ),
    .recv_xbar__val( tile_out_or_link__recv_xbar__val[6] ),
    .send__msg( tile_out_or_link__send__msg[6] ),
    .send__rdy( tile_out_or_link__send__rdy[6] ),
    .send__val( tile_out_or_link__send__val[6] )
  );

  LinkOrRTL__a54ca58e7852ace8 tile_out_or_link__7
  (
    .clk( tile_out_or_link__clk[7] ),
    .reset( tile_out_or_link__reset[7] ),
    .recv_fu__msg( tile_out_or_link__recv_fu__msg[7] ),
    .recv_fu__rdy( tile_out_or_link__recv_fu__rdy[7] ),
    .recv_fu__val( tile_out_or_link__recv_fu__val[7] ),
    .recv_xbar__msg( tile_out_or_link__recv_xbar__msg[7] ),
    .recv_xbar__rdy( tile_out_or_link__recv_xbar__rdy[7] ),
    .recv_xbar__val( tile_out_or_link__recv_xbar__val[7] ),
    .send__msg( tile_out_or_link__send__msg[7] ),
    .send__rdy( tile_out_or_link__send__rdy[7] ),
    .send__val( tile_out_or_link__send__val[7] )
  );

  //-------------------------------------------------------------
  // End of component tile_out_or_link[0:7]
  //-------------------------------------------------------------

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/tile/TileRTL.py:235
  // @update
  // def feed_pkt():
  //     s.ctrl_mem.recv_pkt_from_controller.msg @= CtrlPktType(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0) # , 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
  //     s.const_mem.recv_const.msg @= DataType(0, 0, 0, 0)
  //     s.ctrl_mem.recv_pkt_from_controller.val @= 0
  //     s.const_mem.recv_const.val @= 0
  //     s.recv_from_controller_pkt.rdy @= 0
  // 
  //     if s.recv_from_controller_pkt.val & \
  //        ((s.recv_from_controller_pkt.msg.payload.cmd == CMD_CONFIG) | \
  //         (s.recv_from_controller_pkt.msg.payload.cmd == CMD_CONFIG_PROLOGUE_FU) | \
  //         (s.recv_from_controller_pkt.msg.payload.cmd == CMD_CONFIG_PROLOGUE_FU_CROSSBAR) | \
  //         (s.recv_from_controller_pkt.msg.payload.cmd == CMD_CONFIG_PROLOGUE_ROUTING_CROSSBAR) | \
  //         (s.recv_from_controller_pkt.msg.payload.cmd == CMD_CONFIG_TOTAL_CTRL_COUNT) | \
  //         (s.recv_from_controller_pkt.msg.payload.cmd == CMD_CONFIG_COUNT_PER_ITER) | \
  //         (s.recv_from_controller_pkt.msg.payload.cmd == CMD_GLOBAL_REDUCE_ADD_RESPONSE) | \
  //         (s.recv_from_controller_pkt.msg.payload.cmd == CMD_GLOBAL_REDUCE_MUL_RESPONSE) | \
  //         (s.recv_from_controller_pkt.msg.payload.cmd == CMD_LAUNCH) | \
  //         (s.recv_from_controller_pkt.msg.payload.cmd == CMD_CONFIG_LOOP_LOWER) | \
  //         (s.recv_from_controller_pkt.msg.payload.cmd == CMD_CONFIG_LOOP_UPPER) | \
  //         (s.recv_from_controller_pkt.msg.payload.cmd == CMD_CONFIG_LOOP_STEP)):
  //         s.ctrl_mem.recv_pkt_from_controller.val @= 1
  //         s.ctrl_mem.recv_pkt_from_controller.msg @= s.recv_from_controller_pkt.msg
  //         s.recv_from_controller_pkt.rdy @= s.ctrl_mem.recv_pkt_from_controller.rdy
  //     elif s.recv_from_controller_pkt.val & (s.recv_from_controller_pkt.msg.payload.cmd == CMD_CONST):
  //         s.const_mem.recv_const.val @= 1
  //         s.const_mem.recv_const.msg @= s.recv_from_controller_pkt.msg.payload.data
  //         s.recv_from_controller_pkt.rdy @= s.const_mem.recv_const.rdy
  
  always_comb begin : feed_pkt
    ctrl_mem__recv_pkt_from_controller__msg = { 3'd0, 3'd0, 2'd0, 2'd0, 2'd0, 1'd0, 2'd0, 1'd0, 8'd0, 1'd0, 191'd0 };
    const_mem__recv_const__msg = { 32'd0, 1'd0, 1'd0, 1'd0 };
    ctrl_mem__recv_pkt_from_controller__val = 1'd0;
    const_mem__recv_const__val = 1'd0;
    recv_from_controller_pkt__rdy = 1'd0;
    if ( recv_from_controller_pkt__val & ( ( ( ( ( ( ( ( ( ( ( ( recv_from_controller_pkt__msg.payload.cmd == 5'( __const__CMD_CONFIG ) ) | ( recv_from_controller_pkt__msg.payload.cmd == 5'( __const__CMD_CONFIG_PROLOGUE_FU ) ) ) | ( recv_from_controller_pkt__msg.payload.cmd == 5'( __const__CMD_CONFIG_PROLOGUE_FU_CROSSBAR ) ) ) | ( recv_from_controller_pkt__msg.payload.cmd == 5'( __const__CMD_CONFIG_PROLOGUE_ROUTING_CROSSBAR ) ) ) | ( recv_from_controller_pkt__msg.payload.cmd == 5'( __const__CMD_CONFIG_TOTAL_CTRL_COUNT ) ) ) | ( recv_from_controller_pkt__msg.payload.cmd == 5'( __const__CMD_CONFIG_COUNT_PER_ITER ) ) ) | ( recv_from_controller_pkt__msg.payload.cmd == 5'( __const__CMD_GLOBAL_REDUCE_ADD_RESPONSE ) ) ) | ( recv_from_controller_pkt__msg.payload.cmd == 5'( __const__CMD_GLOBAL_REDUCE_MUL_RESPONSE ) ) ) | ( recv_from_controller_pkt__msg.payload.cmd == 5'( __const__CMD_LAUNCH ) ) ) | ( recv_from_controller_pkt__msg.payload.cmd == 5'( __const__CMD_CONFIG_LOOP_LOWER ) ) ) | ( recv_from_controller_pkt__msg.payload.cmd == 5'( __const__CMD_CONFIG_LOOP_UPPER ) ) ) | ( recv_from_controller_pkt__msg.payload.cmd == 5'( __const__CMD_CONFIG_LOOP_STEP ) ) ) ) begin
      ctrl_mem__recv_pkt_from_controller__val = 1'd1;
      ctrl_mem__recv_pkt_from_controller__msg = recv_from_controller_pkt__msg;
      recv_from_controller_pkt__rdy = ctrl_mem__recv_pkt_from_controller__rdy;
    end
    else if ( recv_from_controller_pkt__val & ( recv_from_controller_pkt__msg.payload.cmd == 5'( __const__CMD_CONST ) ) ) begin
      const_mem__recv_const__val = 1'd1;
      const_mem__recv_const__msg = recv_from_controller_pkt__msg.payload.data;
      recv_from_controller_pkt__rdy = const_mem__recv_const__rdy;
    end
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/tile/TileRTL.py:294
  // @update
  // def notify_const_mem():
  //   s.const_mem.ctrl_proceed @= s.ctrl_mem.send_ctrl.rdy & s.ctrl_mem.send_ctrl.val
  
  always_comb begin : notify_const_mem
    const_mem__ctrl_proceed = ctrl_mem__send_ctrl__rdy & ctrl_mem__send_ctrl__val;
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/tile/TileRTL.py:313
  // @update
  // def notify_crossbars_compute_status():
  //   s.routing_crossbar.compute_done @= s.element_done
  //   s.fu_crossbar.compute_done @= s.element_done
  
  always_comb begin : notify_crossbars_compute_status
    routing_crossbar__compute_done = element_done;
    fu_crossbar__compute_done = element_done;
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/tile/TileRTL.py:274
  // @update
  // def update_opt():
  //   s.element.recv_opt.msg @= s.ctrl_mem.send_ctrl.msg
  //   s.routing_crossbar.recv_opt.msg @= s.ctrl_mem.send_ctrl.msg
  //   s.fu_crossbar.recv_opt.msg @= s.ctrl_mem.send_ctrl.msg
  // 
  //   # FIXME: Do we still need separate element and routing_xbar?
  //   # FIXME: Do we need to consider reg bank here?
  //   s.element.recv_opt.val @= s.ctrl_mem.send_ctrl.val & ~s.element_done
  //   s.routing_crossbar.recv_opt.val @= s.ctrl_mem.send_ctrl.val & ~s.routing_crossbar_done
  //   s.fu_crossbar.recv_opt.val @= s.ctrl_mem.send_ctrl.val & ~s.fu_crossbar_done
  // 
  //   # FIXME: yo96, rename ctrl.rdy to ctrl.proceed or sth similar.
  //   # Allows either the FU-related go out first or routing-xbar go out first. And only
  //   # allows the ctrl signal proceed till all the sub-modules done their own job (once).
  //   s.ctrl_mem.send_ctrl.rdy @= (s.element.recv_opt.rdy | s.element_done) & \
  //                               (s.routing_crossbar.recv_opt.rdy | s.routing_crossbar_done) & \
  //                               (s.fu_crossbar.recv_opt.rdy | s.fu_crossbar_done)
  
  always_comb begin : update_opt
    element__recv_opt__msg = ctrl_mem__send_ctrl__msg;
    routing_crossbar__recv_opt__msg = ctrl_mem__send_ctrl__msg;
    fu_crossbar__recv_opt__msg = ctrl_mem__send_ctrl__msg;
    element__recv_opt__val = ctrl_mem__send_ctrl__val & ( ~element_done );
    routing_crossbar__recv_opt__val = ctrl_mem__send_ctrl__val & ( ~routing_crossbar_done );
    fu_crossbar__recv_opt__val = ctrl_mem__send_ctrl__val & ( ~fu_crossbar_done );
    ctrl_mem__send_ctrl__rdy = ( ( element__recv_opt__rdy | element_done ) & ( routing_crossbar__recv_opt__rdy | routing_crossbar_done ) ) & ( fu_crossbar__recv_opt__rdy | fu_crossbar_done );
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/tile/TileRTL.py:264
  // @update
  // def update_send_out_signal():
  //     s.send_to_controller_pkt.val @= 0
  //     s.send_to_controller_pkt.msg @= CtrlPktType(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0) # , 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
  //     if s.ctrl_mem.send_pkt_to_controller.val:
  //         s.send_to_controller_pkt.val @= 1
  //         s.send_to_controller_pkt.msg @= s.ctrl_mem.send_pkt_to_controller.msg
  //     s.ctrl_mem.send_pkt_to_controller.rdy @= s.send_to_controller_pkt.rdy
  
  always_comb begin : update_send_out_signal
    send_to_controller_pkt__val = 1'd0;
    send_to_controller_pkt__msg = { 3'd0, 3'd0, 2'd0, 2'd0, 2'd0, 1'd0, 2'd0, 1'd0, 8'd0, 1'd0, 191'd0 };
    if ( ctrl_mem__send_pkt_to_controller__val ) begin
      send_to_controller_pkt__val = 1'd1;
      send_to_controller_pkt__msg = ctrl_mem__send_pkt_to_controller__msg;
    end
    ctrl_mem__send_pkt_to_controller__rdy = send_to_controller_pkt__rdy;
  end

  // PyMTL Update Block Source
  // At /cgra/VectorCGRA/tile/TileRTL.py:299
  // @update_ff
  // def already_done():
  //   if s.reset | s.ctrl_mem.send_ctrl.rdy:
  //     s.element_done <<= 0
  //     s.fu_crossbar_done <<= 0
  //     s.routing_crossbar_done <<= 0
  //   else:
  //     if s.element.recv_opt.rdy:
  //       s.element_done <<= 1
  //     if s.fu_crossbar.recv_opt.rdy:
  //       s.fu_crossbar_done <<= 1
  //     if s.routing_crossbar.recv_opt.rdy:
  //       s.routing_crossbar_done <<= 1
  
  always_ff @(posedge clk) begin : already_done
    if ( reset | ctrl_mem__send_ctrl__rdy ) begin
      element_done <= 1'd0;
      fu_crossbar_done <= 1'd0;
      routing_crossbar_done <= 1'd0;
    end
    else begin
      if ( element__recv_opt__rdy ) begin
        element_done <= 1'd1;
      end
      if ( fu_crossbar__recv_opt__rdy ) begin
        fu_crossbar_done <= 1'd1;
      end
      if ( routing_crossbar__recv_opt__rdy ) begin
        routing_crossbar_done <= 1'd1;
      end
    end
  end

  assign element__clk = clk;
  assign element__reset = reset;
  assign const_mem__clk = clk;
  assign const_mem__reset = reset;
  assign routing_crossbar__clk = clk;
  assign routing_crossbar__reset = reset;
  assign fu_crossbar__clk = clk;
  assign fu_crossbar__reset = reset;
  assign register_cluster__clk = clk;
  assign register_cluster__reset = reset;
  assign ctrl_mem__clk = clk;
  assign ctrl_mem__reset = reset;
  assign tile_in_channel__clk[0] = clk;
  assign tile_in_channel__reset[0] = reset;
  assign tile_in_channel__clk[1] = clk;
  assign tile_in_channel__reset[1] = reset;
  assign tile_in_channel__clk[2] = clk;
  assign tile_in_channel__reset[2] = reset;
  assign tile_in_channel__clk[3] = clk;
  assign tile_in_channel__reset[3] = reset;
  assign tile_in_channel__clk[4] = clk;
  assign tile_in_channel__reset[4] = reset;
  assign tile_in_channel__clk[5] = clk;
  assign tile_in_channel__reset[5] = reset;
  assign tile_in_channel__clk[6] = clk;
  assign tile_in_channel__reset[6] = reset;
  assign tile_in_channel__clk[7] = clk;
  assign tile_in_channel__reset[7] = reset;
  assign tile_out_or_link__clk[0] = clk;
  assign tile_out_or_link__reset[0] = reset;
  assign tile_out_or_link__clk[1] = clk;
  assign tile_out_or_link__reset[1] = reset;
  assign tile_out_or_link__clk[2] = clk;
  assign tile_out_or_link__reset[2] = reset;
  assign tile_out_or_link__clk[3] = clk;
  assign tile_out_or_link__reset[3] = reset;
  assign tile_out_or_link__clk[4] = clk;
  assign tile_out_or_link__reset[4] = reset;
  assign tile_out_or_link__clk[5] = clk;
  assign tile_out_or_link__reset[5] = reset;
  assign tile_out_or_link__clk[6] = clk;
  assign tile_out_or_link__reset[6] = reset;
  assign tile_out_or_link__clk[7] = clk;
  assign tile_out_or_link__reset[7] = reset;
  assign element__tile_id = tile_id;
  assign ctrl_mem__cgra_id = cgra_id;
  assign ctrl_mem__tile_id = tile_id;
  assign fu_crossbar__cgra_id = cgra_id;
  assign fu_crossbar__tile_id = tile_id;
  assign routing_crossbar__cgra_id = cgra_id;
  assign routing_crossbar__tile_id = tile_id;
  assign routing_crossbar__crossbar_id = 1'd0;
  assign fu_crossbar__crossbar_id = 1'd1;
  assign element__recv_const__msg = const_mem__send_const__msg;
  assign const_mem__send_const__rdy = element__recv_const__rdy;
  assign element__recv_const__val = const_mem__send_const__val;
  assign ctrl_mem__recv_from_element__msg = element__send_to_ctrl_mem__msg;
  assign element__send_to_ctrl_mem__rdy = ctrl_mem__recv_from_element__rdy;
  assign ctrl_mem__recv_from_element__val = element__send_to_ctrl_mem__val;
  assign element__recv_from_ctrl_mem__msg = ctrl_mem__send_to_element__msg;
  assign ctrl_mem__send_to_element__rdy = element__recv_from_ctrl_mem__rdy;
  assign element__recv_from_ctrl_mem__val = ctrl_mem__send_to_element__val;
  assign routing_crossbar__ctrl_addr_inport = ctrl_mem__ctrl_addr_outport;
  assign fu_crossbar__ctrl_addr_inport = ctrl_mem__ctrl_addr_outport;
  assign element__ctrl_addr_inport = ctrl_mem__ctrl_addr_outport;
  assign element__prologue_count_inport = ctrl_mem__prologue_count_outport_fu;
  assign routing_crossbar__prologue_count_inport[0][0] = ctrl_mem__prologue_count_outport_routing_crossbar[0][0];
  assign routing_crossbar__prologue_count_inport[0][1] = ctrl_mem__prologue_count_outport_routing_crossbar[0][1];
  assign routing_crossbar__prologue_count_inport[0][2] = ctrl_mem__prologue_count_outport_routing_crossbar[0][2];
  assign routing_crossbar__prologue_count_inport[0][3] = ctrl_mem__prologue_count_outport_routing_crossbar[0][3];
  assign routing_crossbar__prologue_count_inport[0][4] = ctrl_mem__prologue_count_outport_routing_crossbar[0][4];
  assign routing_crossbar__prologue_count_inport[0][5] = ctrl_mem__prologue_count_outport_routing_crossbar[0][5];
  assign routing_crossbar__prologue_count_inport[0][6] = ctrl_mem__prologue_count_outport_routing_crossbar[0][6];
  assign routing_crossbar__prologue_count_inport[0][7] = ctrl_mem__prologue_count_outport_routing_crossbar[0][7];
  assign fu_crossbar__prologue_count_inport[0][0] = ctrl_mem__prologue_count_outport_fu_crossbar[0][0];
  assign fu_crossbar__prologue_count_inport[0][1] = ctrl_mem__prologue_count_outport_fu_crossbar[0][1];
  assign routing_crossbar__prologue_count_inport[1][0] = ctrl_mem__prologue_count_outport_routing_crossbar[1][0];
  assign routing_crossbar__prologue_count_inport[1][1] = ctrl_mem__prologue_count_outport_routing_crossbar[1][1];
  assign routing_crossbar__prologue_count_inport[1][2] = ctrl_mem__prologue_count_outport_routing_crossbar[1][2];
  assign routing_crossbar__prologue_count_inport[1][3] = ctrl_mem__prologue_count_outport_routing_crossbar[1][3];
  assign routing_crossbar__prologue_count_inport[1][4] = ctrl_mem__prologue_count_outport_routing_crossbar[1][4];
  assign routing_crossbar__prologue_count_inport[1][5] = ctrl_mem__prologue_count_outport_routing_crossbar[1][5];
  assign routing_crossbar__prologue_count_inport[1][6] = ctrl_mem__prologue_count_outport_routing_crossbar[1][6];
  assign routing_crossbar__prologue_count_inport[1][7] = ctrl_mem__prologue_count_outport_routing_crossbar[1][7];
  assign fu_crossbar__prologue_count_inport[1][0] = ctrl_mem__prologue_count_outport_fu_crossbar[1][0];
  assign fu_crossbar__prologue_count_inport[1][1] = ctrl_mem__prologue_count_outport_fu_crossbar[1][1];
  assign routing_crossbar__prologue_count_inport[2][0] = ctrl_mem__prologue_count_outport_routing_crossbar[2][0];
  assign routing_crossbar__prologue_count_inport[2][1] = ctrl_mem__prologue_count_outport_routing_crossbar[2][1];
  assign routing_crossbar__prologue_count_inport[2][2] = ctrl_mem__prologue_count_outport_routing_crossbar[2][2];
  assign routing_crossbar__prologue_count_inport[2][3] = ctrl_mem__prologue_count_outport_routing_crossbar[2][3];
  assign routing_crossbar__prologue_count_inport[2][4] = ctrl_mem__prologue_count_outport_routing_crossbar[2][4];
  assign routing_crossbar__prologue_count_inport[2][5] = ctrl_mem__prologue_count_outport_routing_crossbar[2][5];
  assign routing_crossbar__prologue_count_inport[2][6] = ctrl_mem__prologue_count_outport_routing_crossbar[2][6];
  assign routing_crossbar__prologue_count_inport[2][7] = ctrl_mem__prologue_count_outport_routing_crossbar[2][7];
  assign fu_crossbar__prologue_count_inport[2][0] = ctrl_mem__prologue_count_outport_fu_crossbar[2][0];
  assign fu_crossbar__prologue_count_inport[2][1] = ctrl_mem__prologue_count_outport_fu_crossbar[2][1];
  assign routing_crossbar__prologue_count_inport[3][0] = ctrl_mem__prologue_count_outport_routing_crossbar[3][0];
  assign routing_crossbar__prologue_count_inport[3][1] = ctrl_mem__prologue_count_outport_routing_crossbar[3][1];
  assign routing_crossbar__prologue_count_inport[3][2] = ctrl_mem__prologue_count_outport_routing_crossbar[3][2];
  assign routing_crossbar__prologue_count_inport[3][3] = ctrl_mem__prologue_count_outport_routing_crossbar[3][3];
  assign routing_crossbar__prologue_count_inport[3][4] = ctrl_mem__prologue_count_outport_routing_crossbar[3][4];
  assign routing_crossbar__prologue_count_inport[3][5] = ctrl_mem__prologue_count_outport_routing_crossbar[3][5];
  assign routing_crossbar__prologue_count_inport[3][6] = ctrl_mem__prologue_count_outport_routing_crossbar[3][6];
  assign routing_crossbar__prologue_count_inport[3][7] = ctrl_mem__prologue_count_outport_routing_crossbar[3][7];
  assign fu_crossbar__prologue_count_inport[3][0] = ctrl_mem__prologue_count_outport_fu_crossbar[3][0];
  assign fu_crossbar__prologue_count_inport[3][1] = ctrl_mem__prologue_count_outport_fu_crossbar[3][1];
  assign routing_crossbar__prologue_count_inport[4][0] = ctrl_mem__prologue_count_outport_routing_crossbar[4][0];
  assign routing_crossbar__prologue_count_inport[4][1] = ctrl_mem__prologue_count_outport_routing_crossbar[4][1];
  assign routing_crossbar__prologue_count_inport[4][2] = ctrl_mem__prologue_count_outport_routing_crossbar[4][2];
  assign routing_crossbar__prologue_count_inport[4][3] = ctrl_mem__prologue_count_outport_routing_crossbar[4][3];
  assign routing_crossbar__prologue_count_inport[4][4] = ctrl_mem__prologue_count_outport_routing_crossbar[4][4];
  assign routing_crossbar__prologue_count_inport[4][5] = ctrl_mem__prologue_count_outport_routing_crossbar[4][5];
  assign routing_crossbar__prologue_count_inport[4][6] = ctrl_mem__prologue_count_outport_routing_crossbar[4][6];
  assign routing_crossbar__prologue_count_inport[4][7] = ctrl_mem__prologue_count_outport_routing_crossbar[4][7];
  assign fu_crossbar__prologue_count_inport[4][0] = ctrl_mem__prologue_count_outport_fu_crossbar[4][0];
  assign fu_crossbar__prologue_count_inport[4][1] = ctrl_mem__prologue_count_outport_fu_crossbar[4][1];
  assign routing_crossbar__prologue_count_inport[5][0] = ctrl_mem__prologue_count_outport_routing_crossbar[5][0];
  assign routing_crossbar__prologue_count_inport[5][1] = ctrl_mem__prologue_count_outport_routing_crossbar[5][1];
  assign routing_crossbar__prologue_count_inport[5][2] = ctrl_mem__prologue_count_outport_routing_crossbar[5][2];
  assign routing_crossbar__prologue_count_inport[5][3] = ctrl_mem__prologue_count_outport_routing_crossbar[5][3];
  assign routing_crossbar__prologue_count_inport[5][4] = ctrl_mem__prologue_count_outport_routing_crossbar[5][4];
  assign routing_crossbar__prologue_count_inport[5][5] = ctrl_mem__prologue_count_outport_routing_crossbar[5][5];
  assign routing_crossbar__prologue_count_inport[5][6] = ctrl_mem__prologue_count_outport_routing_crossbar[5][6];
  assign routing_crossbar__prologue_count_inport[5][7] = ctrl_mem__prologue_count_outport_routing_crossbar[5][7];
  assign fu_crossbar__prologue_count_inport[5][0] = ctrl_mem__prologue_count_outport_fu_crossbar[5][0];
  assign fu_crossbar__prologue_count_inport[5][1] = ctrl_mem__prologue_count_outport_fu_crossbar[5][1];
  assign routing_crossbar__prologue_count_inport[6][0] = ctrl_mem__prologue_count_outport_routing_crossbar[6][0];
  assign routing_crossbar__prologue_count_inport[6][1] = ctrl_mem__prologue_count_outport_routing_crossbar[6][1];
  assign routing_crossbar__prologue_count_inport[6][2] = ctrl_mem__prologue_count_outport_routing_crossbar[6][2];
  assign routing_crossbar__prologue_count_inport[6][3] = ctrl_mem__prologue_count_outport_routing_crossbar[6][3];
  assign routing_crossbar__prologue_count_inport[6][4] = ctrl_mem__prologue_count_outport_routing_crossbar[6][4];
  assign routing_crossbar__prologue_count_inport[6][5] = ctrl_mem__prologue_count_outport_routing_crossbar[6][5];
  assign routing_crossbar__prologue_count_inport[6][6] = ctrl_mem__prologue_count_outport_routing_crossbar[6][6];
  assign routing_crossbar__prologue_count_inport[6][7] = ctrl_mem__prologue_count_outport_routing_crossbar[6][7];
  assign fu_crossbar__prologue_count_inport[6][0] = ctrl_mem__prologue_count_outport_fu_crossbar[6][0];
  assign fu_crossbar__prologue_count_inport[6][1] = ctrl_mem__prologue_count_outport_fu_crossbar[6][1];
  assign routing_crossbar__prologue_count_inport[7][0] = ctrl_mem__prologue_count_outport_routing_crossbar[7][0];
  assign routing_crossbar__prologue_count_inport[7][1] = ctrl_mem__prologue_count_outport_routing_crossbar[7][1];
  assign routing_crossbar__prologue_count_inport[7][2] = ctrl_mem__prologue_count_outport_routing_crossbar[7][2];
  assign routing_crossbar__prologue_count_inport[7][3] = ctrl_mem__prologue_count_outport_routing_crossbar[7][3];
  assign routing_crossbar__prologue_count_inport[7][4] = ctrl_mem__prologue_count_outport_routing_crossbar[7][4];
  assign routing_crossbar__prologue_count_inport[7][5] = ctrl_mem__prologue_count_outport_routing_crossbar[7][5];
  assign routing_crossbar__prologue_count_inport[7][6] = ctrl_mem__prologue_count_outport_routing_crossbar[7][6];
  assign routing_crossbar__prologue_count_inport[7][7] = ctrl_mem__prologue_count_outport_routing_crossbar[7][7];
  assign fu_crossbar__prologue_count_inport[7][0] = ctrl_mem__prologue_count_outport_fu_crossbar[7][0];
  assign fu_crossbar__prologue_count_inport[7][1] = ctrl_mem__prologue_count_outport_fu_crossbar[7][1];
  assign element__to_mem_raddr__rdy[0] = 1'd0;
  assign element__from_mem_rdata__val[0] = 1'd0;
  assign element__from_mem_rdata__msg[0] = { 32'd0, 1'd0, 1'd0, 1'd0 };
  assign element__to_mem_waddr__rdy[0] = 1'd0;
  assign element__to_mem_wdata__rdy[0] = 1'd0;
  assign element__to_mem_raddr__rdy[1] = 1'd0;
  assign element__from_mem_rdata__val[1] = 1'd0;
  assign element__from_mem_rdata__msg[1] = { 32'd0, 1'd0, 1'd0, 1'd0 };
  assign element__to_mem_waddr__rdy[1] = 1'd0;
  assign element__to_mem_wdata__rdy[1] = 1'd0;
  assign element__to_mem_raddr__rdy[2] = 1'd0;
  assign element__from_mem_rdata__val[2] = 1'd0;
  assign element__from_mem_rdata__msg[2] = { 32'd0, 1'd0, 1'd0, 1'd0 };
  assign element__to_mem_waddr__rdy[2] = 1'd0;
  assign element__to_mem_wdata__rdy[2] = 1'd0;
  assign element__to_mem_raddr__rdy[3] = 1'd0;
  assign element__from_mem_rdata__val[3] = 1'd0;
  assign element__from_mem_rdata__msg[3] = { 32'd0, 1'd0, 1'd0, 1'd0 };
  assign element__to_mem_waddr__rdy[3] = 1'd0;
  assign element__to_mem_wdata__rdy[3] = 1'd0;
  assign element__to_mem_raddr__rdy[4] = 1'd0;
  assign element__from_mem_rdata__val[4] = 1'd0;
  assign element__from_mem_rdata__msg[4] = { 32'd0, 1'd0, 1'd0, 1'd0 };
  assign element__to_mem_waddr__rdy[4] = 1'd0;
  assign element__to_mem_wdata__rdy[4] = 1'd0;
  assign element__to_mem_raddr__rdy[5] = 1'd0;
  assign element__from_mem_rdata__val[5] = 1'd0;
  assign element__from_mem_rdata__msg[5] = { 32'd0, 1'd0, 1'd0, 1'd0 };
  assign element__to_mem_waddr__rdy[5] = 1'd0;
  assign element__to_mem_wdata__rdy[5] = 1'd0;
  assign element__to_mem_raddr__rdy[6] = 1'd0;
  assign element__from_mem_rdata__val[6] = 1'd0;
  assign element__from_mem_rdata__msg[6] = { 32'd0, 1'd0, 1'd0, 1'd0 };
  assign element__to_mem_waddr__rdy[6] = 1'd0;
  assign element__to_mem_wdata__rdy[6] = 1'd0;
  assign to_mem_raddr__msg = element__to_mem_raddr__msg[7];
  assign element__to_mem_raddr__rdy[7] = to_mem_raddr__rdy;
  assign to_mem_raddr__val = element__to_mem_raddr__val[7];
  assign element__from_mem_rdata__msg[7] = from_mem_rdata__msg;
  assign from_mem_rdata__rdy = element__from_mem_rdata__rdy[7];
  assign element__from_mem_rdata__val[7] = from_mem_rdata__val;
  assign to_mem_waddr__msg = element__to_mem_waddr__msg[7];
  assign element__to_mem_waddr__rdy[7] = to_mem_waddr__rdy;
  assign to_mem_waddr__val = element__to_mem_waddr__val[7];
  assign to_mem_wdata__msg = element__to_mem_wdata__msg[7];
  assign element__to_mem_wdata__rdy[7] = to_mem_wdata__rdy;
  assign to_mem_wdata__val = element__to_mem_wdata__val[7];
  assign element__to_mem_raddr__rdy[8] = 1'd0;
  assign element__from_mem_rdata__val[8] = 1'd0;
  assign element__from_mem_rdata__msg[8] = { 32'd0, 1'd0, 1'd0, 1'd0 };
  assign element__to_mem_waddr__rdy[8] = 1'd0;
  assign element__to_mem_wdata__rdy[8] = 1'd0;
  assign element__to_mem_raddr__rdy[9] = 1'd0;
  assign element__from_mem_rdata__val[9] = 1'd0;
  assign element__from_mem_rdata__msg[9] = { 32'd0, 1'd0, 1'd0, 1'd0 };
  assign element__to_mem_waddr__rdy[9] = 1'd0;
  assign element__to_mem_wdata__rdy[9] = 1'd0;
  assign element__to_mem_raddr__rdy[10] = 1'd0;
  assign element__from_mem_rdata__val[10] = 1'd0;
  assign element__from_mem_rdata__msg[10] = { 32'd0, 1'd0, 1'd0, 1'd0 };
  assign element__to_mem_waddr__rdy[10] = 1'd0;
  assign element__to_mem_wdata__rdy[10] = 1'd0;
  assign element__to_mem_raddr__rdy[11] = 1'd0;
  assign element__from_mem_rdata__val[11] = 1'd0;
  assign element__from_mem_rdata__msg[11] = { 32'd0, 1'd0, 1'd0, 1'd0 };
  assign element__to_mem_waddr__rdy[11] = 1'd0;
  assign element__to_mem_wdata__rdy[11] = 1'd0;
  assign element__to_mem_raddr__rdy[12] = 1'd0;
  assign element__from_mem_rdata__val[12] = 1'd0;
  assign element__from_mem_rdata__msg[12] = { 32'd0, 1'd0, 1'd0, 1'd0 };
  assign element__to_mem_waddr__rdy[12] = 1'd0;
  assign element__to_mem_wdata__rdy[12] = 1'd0;
  assign element__to_mem_raddr__rdy[13] = 1'd0;
  assign element__from_mem_rdata__val[13] = 1'd0;
  assign element__from_mem_rdata__msg[13] = { 32'd0, 1'd0, 1'd0, 1'd0 };
  assign element__to_mem_waddr__rdy[13] = 1'd0;
  assign element__to_mem_wdata__rdy[13] = 1'd0;
  assign element__to_mem_raddr__rdy[14] = 1'd0;
  assign element__from_mem_rdata__val[14] = 1'd0;
  assign element__from_mem_rdata__msg[14] = { 32'd0, 1'd0, 1'd0, 1'd0 };
  assign element__to_mem_waddr__rdy[14] = 1'd0;
  assign element__to_mem_wdata__rdy[14] = 1'd0;
  assign element__to_mem_raddr__rdy[15] = 1'd0;
  assign element__from_mem_rdata__val[15] = 1'd0;
  assign element__from_mem_rdata__msg[15] = { 32'd0, 1'd0, 1'd0, 1'd0 };
  assign element__to_mem_waddr__rdy[15] = 1'd0;
  assign element__to_mem_wdata__rdy[15] = 1'd0;
  assign tile_in_channel__recv__msg[0] = recv_data__msg[0];
  assign recv_data__rdy[0] = tile_in_channel__recv__rdy[0];
  assign tile_in_channel__recv__val[0] = recv_data__val[0];
  assign routing_crossbar__recv_data__msg[0] = tile_in_channel__send__msg[0];
  assign tile_in_channel__send__rdy[0] = routing_crossbar__recv_data__rdy[0];
  assign routing_crossbar__recv_data__val[0] = tile_in_channel__send__val[0];
  assign tile_in_channel__recv__msg[1] = recv_data__msg[1];
  assign recv_data__rdy[1] = tile_in_channel__recv__rdy[1];
  assign tile_in_channel__recv__val[1] = recv_data__val[1];
  assign routing_crossbar__recv_data__msg[1] = tile_in_channel__send__msg[1];
  assign tile_in_channel__send__rdy[1] = routing_crossbar__recv_data__rdy[1];
  assign routing_crossbar__recv_data__val[1] = tile_in_channel__send__val[1];
  assign tile_in_channel__recv__msg[2] = recv_data__msg[2];
  assign recv_data__rdy[2] = tile_in_channel__recv__rdy[2];
  assign tile_in_channel__recv__val[2] = recv_data__val[2];
  assign routing_crossbar__recv_data__msg[2] = tile_in_channel__send__msg[2];
  assign tile_in_channel__send__rdy[2] = routing_crossbar__recv_data__rdy[2];
  assign routing_crossbar__recv_data__val[2] = tile_in_channel__send__val[2];
  assign tile_in_channel__recv__msg[3] = recv_data__msg[3];
  assign recv_data__rdy[3] = tile_in_channel__recv__rdy[3];
  assign tile_in_channel__recv__val[3] = recv_data__val[3];
  assign routing_crossbar__recv_data__msg[3] = tile_in_channel__send__msg[3];
  assign tile_in_channel__send__rdy[3] = routing_crossbar__recv_data__rdy[3];
  assign routing_crossbar__recv_data__val[3] = tile_in_channel__send__val[3];
  assign tile_in_channel__recv__msg[4] = recv_data__msg[4];
  assign recv_data__rdy[4] = tile_in_channel__recv__rdy[4];
  assign tile_in_channel__recv__val[4] = recv_data__val[4];
  assign routing_crossbar__recv_data__msg[4] = tile_in_channel__send__msg[4];
  assign tile_in_channel__send__rdy[4] = routing_crossbar__recv_data__rdy[4];
  assign routing_crossbar__recv_data__val[4] = tile_in_channel__send__val[4];
  assign tile_in_channel__recv__msg[5] = recv_data__msg[5];
  assign recv_data__rdy[5] = tile_in_channel__recv__rdy[5];
  assign tile_in_channel__recv__val[5] = recv_data__val[5];
  assign routing_crossbar__recv_data__msg[5] = tile_in_channel__send__msg[5];
  assign tile_in_channel__send__rdy[5] = routing_crossbar__recv_data__rdy[5];
  assign routing_crossbar__recv_data__val[5] = tile_in_channel__send__val[5];
  assign tile_in_channel__recv__msg[6] = recv_data__msg[6];
  assign recv_data__rdy[6] = tile_in_channel__recv__rdy[6];
  assign tile_in_channel__recv__val[6] = recv_data__val[6];
  assign routing_crossbar__recv_data__msg[6] = tile_in_channel__send__msg[6];
  assign tile_in_channel__send__rdy[6] = routing_crossbar__recv_data__rdy[6];
  assign routing_crossbar__recv_data__val[6] = tile_in_channel__send__val[6];
  assign tile_in_channel__recv__msg[7] = recv_data__msg[7];
  assign recv_data__rdy[7] = tile_in_channel__recv__rdy[7];
  assign tile_in_channel__recv__val[7] = recv_data__val[7];
  assign routing_crossbar__recv_data__msg[7] = tile_in_channel__send__msg[7];
  assign tile_in_channel__send__rdy[7] = routing_crossbar__recv_data__rdy[7];
  assign routing_crossbar__recv_data__val[7] = tile_in_channel__send__val[7];
  assign routing_crossbar__crossbar_outport[0] = ctrl_mem__send_ctrl__msg.routing_xbar_outport[0];
  assign fu_crossbar__crossbar_outport[0] = ctrl_mem__send_ctrl__msg.fu_xbar_outport[0];
  assign routing_crossbar__crossbar_outport[1] = ctrl_mem__send_ctrl__msg.routing_xbar_outport[1];
  assign fu_crossbar__crossbar_outport[1] = ctrl_mem__send_ctrl__msg.fu_xbar_outport[1];
  assign routing_crossbar__crossbar_outport[2] = ctrl_mem__send_ctrl__msg.routing_xbar_outport[2];
  assign fu_crossbar__crossbar_outport[2] = ctrl_mem__send_ctrl__msg.fu_xbar_outport[2];
  assign routing_crossbar__crossbar_outport[3] = ctrl_mem__send_ctrl__msg.routing_xbar_outport[3];
  assign fu_crossbar__crossbar_outport[3] = ctrl_mem__send_ctrl__msg.fu_xbar_outport[3];
  assign routing_crossbar__crossbar_outport[4] = ctrl_mem__send_ctrl__msg.routing_xbar_outport[4];
  assign fu_crossbar__crossbar_outport[4] = ctrl_mem__send_ctrl__msg.fu_xbar_outport[4];
  assign routing_crossbar__crossbar_outport[5] = ctrl_mem__send_ctrl__msg.routing_xbar_outport[5];
  assign fu_crossbar__crossbar_outport[5] = ctrl_mem__send_ctrl__msg.fu_xbar_outport[5];
  assign routing_crossbar__crossbar_outport[6] = ctrl_mem__send_ctrl__msg.routing_xbar_outport[6];
  assign fu_crossbar__crossbar_outport[6] = ctrl_mem__send_ctrl__msg.fu_xbar_outport[6];
  assign routing_crossbar__crossbar_outport[7] = ctrl_mem__send_ctrl__msg.routing_xbar_outport[7];
  assign fu_crossbar__crossbar_outport[7] = ctrl_mem__send_ctrl__msg.fu_xbar_outport[7];
  assign routing_crossbar__crossbar_outport[8] = ctrl_mem__send_ctrl__msg.routing_xbar_outport[8];
  assign fu_crossbar__crossbar_outport[8] = ctrl_mem__send_ctrl__msg.fu_xbar_outport[8];
  assign routing_crossbar__crossbar_outport[9] = ctrl_mem__send_ctrl__msg.routing_xbar_outport[9];
  assign fu_crossbar__crossbar_outport[9] = ctrl_mem__send_ctrl__msg.fu_xbar_outport[9];
  assign routing_crossbar__crossbar_outport[10] = ctrl_mem__send_ctrl__msg.routing_xbar_outport[10];
  assign fu_crossbar__crossbar_outport[10] = ctrl_mem__send_ctrl__msg.fu_xbar_outport[10];
  assign routing_crossbar__crossbar_outport[11] = ctrl_mem__send_ctrl__msg.routing_xbar_outport[11];
  assign fu_crossbar__crossbar_outport[11] = ctrl_mem__send_ctrl__msg.fu_xbar_outport[11];
  assign fu_crossbar__recv_data__msg[0] = element__send_out__msg[0];
  assign element__send_out__rdy[0] = fu_crossbar__recv_data__rdy[0];
  assign fu_crossbar__recv_data__val[0] = element__send_out__val[0];
  assign fu_crossbar__recv_data__msg[1] = element__send_out__msg[1];
  assign element__send_out__rdy[1] = fu_crossbar__recv_data__rdy[1];
  assign fu_crossbar__recv_data__val[1] = element__send_out__val[1];
  assign tile_out_or_link__recv_fu__msg[0] = fu_crossbar__send_data__msg[0];
  assign fu_crossbar__send_data__rdy[0] = tile_out_or_link__recv_fu__rdy[0];
  assign tile_out_or_link__recv_fu__val[0] = fu_crossbar__send_data__val[0];
  assign tile_out_or_link__recv_xbar__msg[0] = routing_crossbar__send_data__msg[0];
  assign routing_crossbar__send_data__rdy[0] = tile_out_or_link__recv_xbar__rdy[0];
  assign tile_out_or_link__recv_xbar__val[0] = routing_crossbar__send_data__val[0];
  assign send_data__msg[0] = tile_out_or_link__send__msg[0];
  assign tile_out_or_link__send__rdy[0] = send_data__rdy[0];
  assign send_data__val[0] = tile_out_or_link__send__val[0];
  assign tile_out_or_link__recv_fu__msg[1] = fu_crossbar__send_data__msg[1];
  assign fu_crossbar__send_data__rdy[1] = tile_out_or_link__recv_fu__rdy[1];
  assign tile_out_or_link__recv_fu__val[1] = fu_crossbar__send_data__val[1];
  assign tile_out_or_link__recv_xbar__msg[1] = routing_crossbar__send_data__msg[1];
  assign routing_crossbar__send_data__rdy[1] = tile_out_or_link__recv_xbar__rdy[1];
  assign tile_out_or_link__recv_xbar__val[1] = routing_crossbar__send_data__val[1];
  assign send_data__msg[1] = tile_out_or_link__send__msg[1];
  assign tile_out_or_link__send__rdy[1] = send_data__rdy[1];
  assign send_data__val[1] = tile_out_or_link__send__val[1];
  assign tile_out_or_link__recv_fu__msg[2] = fu_crossbar__send_data__msg[2];
  assign fu_crossbar__send_data__rdy[2] = tile_out_or_link__recv_fu__rdy[2];
  assign tile_out_or_link__recv_fu__val[2] = fu_crossbar__send_data__val[2];
  assign tile_out_or_link__recv_xbar__msg[2] = routing_crossbar__send_data__msg[2];
  assign routing_crossbar__send_data__rdy[2] = tile_out_or_link__recv_xbar__rdy[2];
  assign tile_out_or_link__recv_xbar__val[2] = routing_crossbar__send_data__val[2];
  assign send_data__msg[2] = tile_out_or_link__send__msg[2];
  assign tile_out_or_link__send__rdy[2] = send_data__rdy[2];
  assign send_data__val[2] = tile_out_or_link__send__val[2];
  assign tile_out_or_link__recv_fu__msg[3] = fu_crossbar__send_data__msg[3];
  assign fu_crossbar__send_data__rdy[3] = tile_out_or_link__recv_fu__rdy[3];
  assign tile_out_or_link__recv_fu__val[3] = fu_crossbar__send_data__val[3];
  assign tile_out_or_link__recv_xbar__msg[3] = routing_crossbar__send_data__msg[3];
  assign routing_crossbar__send_data__rdy[3] = tile_out_or_link__recv_xbar__rdy[3];
  assign tile_out_or_link__recv_xbar__val[3] = routing_crossbar__send_data__val[3];
  assign send_data__msg[3] = tile_out_or_link__send__msg[3];
  assign tile_out_or_link__send__rdy[3] = send_data__rdy[3];
  assign send_data__val[3] = tile_out_or_link__send__val[3];
  assign tile_out_or_link__recv_fu__msg[4] = fu_crossbar__send_data__msg[4];
  assign fu_crossbar__send_data__rdy[4] = tile_out_or_link__recv_fu__rdy[4];
  assign tile_out_or_link__recv_fu__val[4] = fu_crossbar__send_data__val[4];
  assign tile_out_or_link__recv_xbar__msg[4] = routing_crossbar__send_data__msg[4];
  assign routing_crossbar__send_data__rdy[4] = tile_out_or_link__recv_xbar__rdy[4];
  assign tile_out_or_link__recv_xbar__val[4] = routing_crossbar__send_data__val[4];
  assign send_data__msg[4] = tile_out_or_link__send__msg[4];
  assign tile_out_or_link__send__rdy[4] = send_data__rdy[4];
  assign send_data__val[4] = tile_out_or_link__send__val[4];
  assign tile_out_or_link__recv_fu__msg[5] = fu_crossbar__send_data__msg[5];
  assign fu_crossbar__send_data__rdy[5] = tile_out_or_link__recv_fu__rdy[5];
  assign tile_out_or_link__recv_fu__val[5] = fu_crossbar__send_data__val[5];
  assign tile_out_or_link__recv_xbar__msg[5] = routing_crossbar__send_data__msg[5];
  assign routing_crossbar__send_data__rdy[5] = tile_out_or_link__recv_xbar__rdy[5];
  assign tile_out_or_link__recv_xbar__val[5] = routing_crossbar__send_data__val[5];
  assign send_data__msg[5] = tile_out_or_link__send__msg[5];
  assign tile_out_or_link__send__rdy[5] = send_data__rdy[5];
  assign send_data__val[5] = tile_out_or_link__send__val[5];
  assign tile_out_or_link__recv_fu__msg[6] = fu_crossbar__send_data__msg[6];
  assign fu_crossbar__send_data__rdy[6] = tile_out_or_link__recv_fu__rdy[6];
  assign tile_out_or_link__recv_fu__val[6] = fu_crossbar__send_data__val[6];
  assign tile_out_or_link__recv_xbar__msg[6] = routing_crossbar__send_data__msg[6];
  assign routing_crossbar__send_data__rdy[6] = tile_out_or_link__recv_xbar__rdy[6];
  assign tile_out_or_link__recv_xbar__val[6] = routing_crossbar__send_data__val[6];
  assign send_data__msg[6] = tile_out_or_link__send__msg[6];
  assign tile_out_or_link__send__rdy[6] = send_data__rdy[6];
  assign send_data__val[6] = tile_out_or_link__send__val[6];
  assign tile_out_or_link__recv_fu__msg[7] = fu_crossbar__send_data__msg[7];
  assign fu_crossbar__send_data__rdy[7] = tile_out_or_link__recv_fu__rdy[7];
  assign tile_out_or_link__recv_fu__val[7] = fu_crossbar__send_data__val[7];
  assign tile_out_or_link__recv_xbar__msg[7] = routing_crossbar__send_data__msg[7];
  assign routing_crossbar__send_data__rdy[7] = tile_out_or_link__recv_xbar__rdy[7];
  assign tile_out_or_link__recv_xbar__val[7] = routing_crossbar__send_data__val[7];
  assign send_data__msg[7] = tile_out_or_link__send__msg[7];
  assign tile_out_or_link__send__rdy[7] = send_data__rdy[7];
  assign send_data__val[7] = tile_out_or_link__send__val[7];
  assign register_cluster__recv_data_from_routing_crossbar__msg[0] = routing_crossbar__send_data__msg[8];
  assign routing_crossbar__send_data__rdy[8] = register_cluster__recv_data_from_routing_crossbar__rdy[0];
  assign register_cluster__recv_data_from_routing_crossbar__val[0] = routing_crossbar__send_data__val[8];
  assign register_cluster__recv_data_from_fu_crossbar__msg[0] = fu_crossbar__send_data__msg[8];
  assign fu_crossbar__send_data__rdy[8] = register_cluster__recv_data_from_fu_crossbar__rdy[0];
  assign register_cluster__recv_data_from_fu_crossbar__val[0] = fu_crossbar__send_data__val[8];
  assign register_cluster__recv_data_from_const__msg[0] = { 32'd0, 1'd0, 1'd0, 1'd0 };
  assign register_cluster__recv_data_from_const__val[0] = 1'd0;
  assign element__recv_in__msg[0] = register_cluster__send_data_to_fu__msg[0];
  assign register_cluster__send_data_to_fu__rdy[0] = element__recv_in__rdy[0];
  assign element__recv_in__val[0] = register_cluster__send_data_to_fu__val[0];
  assign register_cluster__inport_opt = ctrl_mem__send_ctrl__msg;
  assign register_cluster__recv_data_from_routing_crossbar__msg[1] = routing_crossbar__send_data__msg[9];
  assign routing_crossbar__send_data__rdy[9] = register_cluster__recv_data_from_routing_crossbar__rdy[1];
  assign register_cluster__recv_data_from_routing_crossbar__val[1] = routing_crossbar__send_data__val[9];
  assign register_cluster__recv_data_from_fu_crossbar__msg[1] = fu_crossbar__send_data__msg[9];
  assign fu_crossbar__send_data__rdy[9] = register_cluster__recv_data_from_fu_crossbar__rdy[1];
  assign register_cluster__recv_data_from_fu_crossbar__val[1] = fu_crossbar__send_data__val[9];
  assign register_cluster__recv_data_from_const__msg[1] = { 32'd0, 1'd0, 1'd0, 1'd0 };
  assign register_cluster__recv_data_from_const__val[1] = 1'd0;
  assign element__recv_in__msg[1] = register_cluster__send_data_to_fu__msg[1];
  assign register_cluster__send_data_to_fu__rdy[1] = element__recv_in__rdy[1];
  assign element__recv_in__val[1] = register_cluster__send_data_to_fu__val[1];
  assign register_cluster__recv_data_from_routing_crossbar__msg[2] = routing_crossbar__send_data__msg[10];
  assign routing_crossbar__send_data__rdy[10] = register_cluster__recv_data_from_routing_crossbar__rdy[2];
  assign register_cluster__recv_data_from_routing_crossbar__val[2] = routing_crossbar__send_data__val[10];
  assign register_cluster__recv_data_from_fu_crossbar__msg[2] = fu_crossbar__send_data__msg[10];
  assign fu_crossbar__send_data__rdy[10] = register_cluster__recv_data_from_fu_crossbar__rdy[2];
  assign register_cluster__recv_data_from_fu_crossbar__val[2] = fu_crossbar__send_data__val[10];
  assign register_cluster__recv_data_from_const__msg[2] = { 32'd0, 1'd0, 1'd0, 1'd0 };
  assign register_cluster__recv_data_from_const__val[2] = 1'd0;
  assign element__recv_in__msg[2] = register_cluster__send_data_to_fu__msg[2];
  assign register_cluster__send_data_to_fu__rdy[2] = element__recv_in__rdy[2];
  assign element__recv_in__val[2] = register_cluster__send_data_to_fu__val[2];
  assign register_cluster__recv_data_from_routing_crossbar__msg[3] = routing_crossbar__send_data__msg[11];
  assign routing_crossbar__send_data__rdy[11] = register_cluster__recv_data_from_routing_crossbar__rdy[3];
  assign register_cluster__recv_data_from_routing_crossbar__val[3] = routing_crossbar__send_data__val[11];
  assign register_cluster__recv_data_from_fu_crossbar__msg[3] = fu_crossbar__send_data__msg[11];
  assign fu_crossbar__send_data__rdy[11] = register_cluster__recv_data_from_fu_crossbar__rdy[3];
  assign register_cluster__recv_data_from_fu_crossbar__val[3] = fu_crossbar__send_data__val[11];
  assign register_cluster__recv_data_from_const__msg[3] = { 32'd0, 1'd0, 1'd0, 1'd0 };
  assign register_cluster__recv_data_from_const__val[3] = 1'd0;
  assign element__recv_in__msg[3] = register_cluster__send_data_to_fu__msg[3];
  assign register_cluster__send_data_to_fu__rdy[3] = element__recv_in__rdy[3];
  assign element__recv_in__val[3] = register_cluster__send_data_to_fu__val[3];
  assign element__clear[0] = 1'd0;
  assign element__clear[1] = 1'd0;
  assign element__clear[2] = 1'd0;
  assign element__clear[3] = 1'd0;
  assign element__clear[4] = 1'd0;
  assign element__clear[5] = 1'd0;
  assign element__clear[6] = 1'd0;
  assign element__clear[7] = 1'd0;
  assign element__clear[8] = 1'd0;
  assign element__clear[9] = 1'd0;
  assign element__clear[10] = 1'd0;
  assign element__clear[11] = 1'd0;
  assign element__clear[12] = 1'd0;
  assign element__clear[13] = 1'd0;
  assign element__clear[14] = 1'd0;
  assign element__clear[15] = 1'd0;
  assign fu_crossbar__clear = 1'd0;
  assign routing_crossbar__clear = 1'd0;

endmodule


// PyMTL Component CgraTemplateRTL Definition
// Full name: CgraTemplateRTL__CgraPayloadType_MultiCgraPayload_Cmd_Data_DataAddr_Ctrl_CtrlAddr__a0427cd98cfcae6f__multi_cgra_rows_1__multi_cgra_columns_4__per_cgra_rows_2__per_cgra_columns_2__ctrl_mem_size_8__data_mem_size_global_512__data_mem_size_per_bank_32__num_banks_per_cgra_2__num_registers_per_reg_bank_16__num_ctrl_8__total_steps_8__mem_access_is_combinational_False__FunctionUnit_FlexibleFuRTL__FuList_[<class 'VectorCGRA.fu.single.PhiRTL.PhiRTL'>, <class 'VectorCGRA.fu.single.AdderRTL.AdderRTL'>, <class 'VectorCGRA.fu.single.ShifterRTL.ShifterRTL'>, <class 'VectorCGRA.fu.single.MemUnitRTL.MemUnitRTL'>, <class 'VectorCGRA.fu.single.SelRTL.SelRTL'>, <class 'VectorCGRA.fu.single.CompRTL.CompRTL'>, <class 'VectorCGRA.fu.double.SeqMulAdderRTL.SeqMulAdderRTL'>, <class 'VectorCGRA.fu.single.RetRTL.RetRTL'>, <class 'VectorCGRA.fu.single.MulRTL.MulRTL'>, <class 'VectorCGRA.fu.single.LogicRTL.LogicRTL'>, <class 'VectorCGRA.fu.single.GrantRTL.GrantRTL'>, <class 'VectorCGRA.fu.single.ExclusiveDivRTL.ExclusiveDivRTL'>]__TileList_[<VectorCGRA.lib.util.cgra.Tile.Tile object at 0x78fd0f991610>, <VectorCGRA.lib.util.cgra.Tile.Tile object at 0x78fd0fb13bc0>, <VectorCGRA.lib.util.cgra.Tile.Tile object at 0x78fd0ea75fd0>, <VectorCGRA.lib.util.cgra.Tile.Tile object at 0x78fd0ea75e50>]__LinkList_[<VectorCGRA.lib.util.cgra.Link.Link object at 0x78fd0fa42270>, <VectorCGRA.lib.util.cgra.Link.Link object at 0x78fd0fb37230>, <VectorCGRA.lib.util.cgra.Link.Link object at 0x78fd0f0148c0>, <VectorCGRA.lib.util.cgra.Link.Link object at 0x78fd0f014800>, <VectorCGRA.lib.util.cgra.Link.Link object at 0x78fd0fa422d0>, <VectorCGRA.lib.util.cgra.Link.Link object at 0x78fd0ea75f10>, <VectorCGRA.lib.util.cgra.Link.Link object at 0x78fd0ea75fa0>, <VectorCGRA.lib.util.cgra.Link.Link object at 0x78fd0ea760f0>, <VectorCGRA.lib.util.cgra.Link.Link object at 0x78fd0ea76120>, <VectorCGRA.lib.util.cgra.Link.Link object at 0x78fd0ea764e0>, <VectorCGRA.lib.util.cgra.Link.Link object at 0x78fd0ea75f40>, <VectorCGRA.lib.util.cgra.Link.Link object at 0x78fd0ea762a0>, <VectorCGRA.lib.util.cgra.Link.Link object at 0x78fd0ea76210>, <VectorCGRA.lib.util.cgra.Link.Link object at 0x78fd0ea76150>, <VectorCGRA.lib.util.cgra.Link.Link object at 0x78fd0ea761b0>, <VectorCGRA.lib.util.cgra.Link.Link object at 0x78fd0ea76270>, <VectorCGRA.lib.util.cgra.Link.Link object at 0x78fd0ea76060>, <VectorCGRA.lib.util.cgra.Link.Link object at 0x78fd0ea763c0>]__dataSPM_<VectorCGRA.lib.util.cgra.DataSPM.DataSPM object at 0x78fd0ebfef30>__controller2addr_map_{0: [0, 3], 1: [4, 7], 2: [8, 11], 3: [12, 15]}__idTo2d_map_{0: [0, 0], 1: [1, 0], 2: [2, 0], 3: [3, 0]}__is_multi_cgra_False__cgra_id_0
// At /cgra/VectorCGRA/cgra/CgraTemplateRTL.py

module CgraTemplateRTL
(
  input  logic [8:0] address_lower ,
  input  logic [8:0] address_upper ,
  input  logic [1:0] cgra_id ,
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input IntraCgraPacket_4_4x1_4_8_2_CgraPayload__11cd3f8c0d91825c recv_from_cpu_pkt__msg  ,
  output logic [0:0] recv_from_cpu_pkt__rdy  ,
  input logic [0:0] recv_from_cpu_pkt__val  ,
  input InterCgraPacket_4_4x1_4_8_4_CgraPayload__9d404f857a1e94ff recv_from_inter_cgra_noc__msg  ,
  output logic [0:0] recv_from_inter_cgra_noc__rdy  ,
  input logic [0:0] recv_from_inter_cgra_noc__val  ,
  output IntraCgraPacket_4_4x1_4_8_2_CgraPayload__11cd3f8c0d91825c send_to_cpu_pkt__msg  ,
  input logic [0:0] send_to_cpu_pkt__rdy  ,
  output logic [0:0] send_to_cpu_pkt__val  ,
  output InterCgraPacket_4_4x1_4_8_4_CgraPayload__9d404f857a1e94ff send_to_inter_cgra_noc__msg  ,
  input logic [0:0] send_to_inter_cgra_noc__rdy  ,
  output logic [0:0] send_to_inter_cgra_noc__val  
);
  //-------------------------------------------------------------
  // Component bypass_queue
  //-------------------------------------------------------------

  logic [0:0] bypass_queue__clk;
  logic [0:0] bypass_queue__count;
  logic [0:0] bypass_queue__reset;
  InterCgraPacket_4_4x1_4_8_4_CgraPayload__9d404f857a1e94ff bypass_queue__recv__msg;
  logic [0:0] bypass_queue__recv__rdy;
  logic [0:0] bypass_queue__recv__val;
  InterCgraPacket_4_4x1_4_8_4_CgraPayload__9d404f857a1e94ff bypass_queue__send__msg;
  logic [0:0] bypass_queue__send__rdy;
  logic [0:0] bypass_queue__send__val;

  BypassQueueRTL__525283e7a6a59a35 bypass_queue
  (
    .clk( bypass_queue__clk ),
    .count( bypass_queue__count ),
    .reset( bypass_queue__reset ),
    .recv__msg( bypass_queue__recv__msg ),
    .recv__rdy( bypass_queue__recv__rdy ),
    .recv__val( bypass_queue__recv__val ),
    .send__msg( bypass_queue__send__msg ),
    .send__rdy( bypass_queue__send__rdy ),
    .send__val( bypass_queue__send__val )
  );

  //-------------------------------------------------------------
  // End of component bypass_queue
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component controller
  //-------------------------------------------------------------

  logic [1:0] controller__cgra_id;
  logic [0:0] controller__clk;
  logic [0:0] controller__reset;
  IntraCgraPacket_4_4x1_4_8_2_CgraPayload__11cd3f8c0d91825c controller__recv_from_cpu_pkt__msg;
  logic [0:0] controller__recv_from_cpu_pkt__rdy;
  logic [0:0] controller__recv_from_cpu_pkt__val;
  IntraCgraPacket_4_4x1_4_8_2_CgraPayload__11cd3f8c0d91825c controller__recv_from_ctrl_ring_pkt__msg;
  logic [0:0] controller__recv_from_ctrl_ring_pkt__rdy;
  logic [0:0] controller__recv_from_ctrl_ring_pkt__val;
  InterCgraPacket_4_4x1_4_8_4_CgraPayload__9d404f857a1e94ff controller__recv_from_inter_cgra_noc__msg;
  logic [0:0] controller__recv_from_inter_cgra_noc__rdy;
  logic [0:0] controller__recv_from_inter_cgra_noc__val;
  InterCgraPacket_4_4x1_4_8_4_CgraPayload__9d404f857a1e94ff controller__recv_from_tile_load_request_pkt__msg;
  logic [0:0] controller__recv_from_tile_load_request_pkt__rdy;
  logic [0:0] controller__recv_from_tile_load_request_pkt__val;
  InterCgraPacket_4_4x1_4_8_4_CgraPayload__9d404f857a1e94ff controller__recv_from_tile_load_response_pkt__msg;
  logic [0:0] controller__recv_from_tile_load_response_pkt__rdy;
  logic [0:0] controller__recv_from_tile_load_response_pkt__val;
  InterCgraPacket_4_4x1_4_8_4_CgraPayload__9d404f857a1e94ff controller__recv_from_tile_store_request_pkt__msg;
  logic [0:0] controller__recv_from_tile_store_request_pkt__rdy;
  logic [0:0] controller__recv_from_tile_store_request_pkt__val;
  IntraCgraPacket_4_4x1_4_8_2_CgraPayload__11cd3f8c0d91825c controller__send_to_cpu_pkt__msg;
  logic [0:0] controller__send_to_cpu_pkt__rdy;
  logic [0:0] controller__send_to_cpu_pkt__val;
  IntraCgraPacket_4_4x1_4_8_2_CgraPayload__11cd3f8c0d91825c controller__send_to_ctrl_ring_pkt__msg;
  logic [0:0] controller__send_to_ctrl_ring_pkt__rdy;
  logic [0:0] controller__send_to_ctrl_ring_pkt__val;
  InterCgraPacket_4_4x1_4_8_4_CgraPayload__9d404f857a1e94ff controller__send_to_inter_cgra_noc__msg;
  logic [0:0] controller__send_to_inter_cgra_noc__rdy;
  logic [0:0] controller__send_to_inter_cgra_noc__val;
  InterCgraPacket_4_4x1_4_8_4_CgraPayload__9d404f857a1e94ff controller__send_to_mem_load_request__msg;
  logic [0:0] controller__send_to_mem_load_request__rdy;
  logic [0:0] controller__send_to_mem_load_request__val;
  InterCgraPacket_4_4x1_4_8_4_CgraPayload__9d404f857a1e94ff controller__send_to_mem_store_request__msg;
  logic [0:0] controller__send_to_mem_store_request__rdy;
  logic [0:0] controller__send_to_mem_store_request__val;
  InterCgraPacket_4_4x1_4_8_4_CgraPayload__9d404f857a1e94ff controller__send_to_tile_load_response__msg;
  logic [0:0] controller__send_to_tile_load_response__rdy;
  logic [0:0] controller__send_to_tile_load_response__val;

  ControllerRTL__fa3c5e20158080fd controller
  (
    .cgra_id( controller__cgra_id ),
    .clk( controller__clk ),
    .reset( controller__reset ),
    .recv_from_cpu_pkt__msg( controller__recv_from_cpu_pkt__msg ),
    .recv_from_cpu_pkt__rdy( controller__recv_from_cpu_pkt__rdy ),
    .recv_from_cpu_pkt__val( controller__recv_from_cpu_pkt__val ),
    .recv_from_ctrl_ring_pkt__msg( controller__recv_from_ctrl_ring_pkt__msg ),
    .recv_from_ctrl_ring_pkt__rdy( controller__recv_from_ctrl_ring_pkt__rdy ),
    .recv_from_ctrl_ring_pkt__val( controller__recv_from_ctrl_ring_pkt__val ),
    .recv_from_inter_cgra_noc__msg( controller__recv_from_inter_cgra_noc__msg ),
    .recv_from_inter_cgra_noc__rdy( controller__recv_from_inter_cgra_noc__rdy ),
    .recv_from_inter_cgra_noc__val( controller__recv_from_inter_cgra_noc__val ),
    .recv_from_tile_load_request_pkt__msg( controller__recv_from_tile_load_request_pkt__msg ),
    .recv_from_tile_load_request_pkt__rdy( controller__recv_from_tile_load_request_pkt__rdy ),
    .recv_from_tile_load_request_pkt__val( controller__recv_from_tile_load_request_pkt__val ),
    .recv_from_tile_load_response_pkt__msg( controller__recv_from_tile_load_response_pkt__msg ),
    .recv_from_tile_load_response_pkt__rdy( controller__recv_from_tile_load_response_pkt__rdy ),
    .recv_from_tile_load_response_pkt__val( controller__recv_from_tile_load_response_pkt__val ),
    .recv_from_tile_store_request_pkt__msg( controller__recv_from_tile_store_request_pkt__msg ),
    .recv_from_tile_store_request_pkt__rdy( controller__recv_from_tile_store_request_pkt__rdy ),
    .recv_from_tile_store_request_pkt__val( controller__recv_from_tile_store_request_pkt__val ),
    .send_to_cpu_pkt__msg( controller__send_to_cpu_pkt__msg ),
    .send_to_cpu_pkt__rdy( controller__send_to_cpu_pkt__rdy ),
    .send_to_cpu_pkt__val( controller__send_to_cpu_pkt__val ),
    .send_to_ctrl_ring_pkt__msg( controller__send_to_ctrl_ring_pkt__msg ),
    .send_to_ctrl_ring_pkt__rdy( controller__send_to_ctrl_ring_pkt__rdy ),
    .send_to_ctrl_ring_pkt__val( controller__send_to_ctrl_ring_pkt__val ),
    .send_to_inter_cgra_noc__msg( controller__send_to_inter_cgra_noc__msg ),
    .send_to_inter_cgra_noc__rdy( controller__send_to_inter_cgra_noc__rdy ),
    .send_to_inter_cgra_noc__val( controller__send_to_inter_cgra_noc__val ),
    .send_to_mem_load_request__msg( controller__send_to_mem_load_request__msg ),
    .send_to_mem_load_request__rdy( controller__send_to_mem_load_request__rdy ),
    .send_to_mem_load_request__val( controller__send_to_mem_load_request__val ),
    .send_to_mem_store_request__msg( controller__send_to_mem_store_request__msg ),
    .send_to_mem_store_request__rdy( controller__send_to_mem_store_request__rdy ),
    .send_to_mem_store_request__val( controller__send_to_mem_store_request__val ),
    .send_to_tile_load_response__msg( controller__send_to_tile_load_response__msg ),
    .send_to_tile_load_response__rdy( controller__send_to_tile_load_response__rdy ),
    .send_to_tile_load_response__val( controller__send_to_tile_load_response__val )
  );

  //-------------------------------------------------------------
  // End of component controller
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component ctrl_ring
  //-------------------------------------------------------------

  logic [0:0] ctrl_ring__clk;
  logic [0:0] ctrl_ring__reset;
  IntraCgraPacket_4_4x1_4_8_2_CgraPayload__11cd3f8c0d91825c ctrl_ring__recv__msg [0:4];
  logic [0:0] ctrl_ring__recv__rdy [0:4];
  logic [0:0] ctrl_ring__recv__val [0:4];
  IntraCgraPacket_4_4x1_4_8_2_CgraPayload__11cd3f8c0d91825c ctrl_ring__send__msg [0:4];
  logic [0:0] ctrl_ring__send__rdy [0:4];
  logic [0:0] ctrl_ring__send__val [0:4];

  RingNetworkRTL__344ed987b950e64f ctrl_ring
  (
    .clk( ctrl_ring__clk ),
    .reset( ctrl_ring__reset ),
    .recv__msg( ctrl_ring__recv__msg ),
    .recv__rdy( ctrl_ring__recv__rdy ),
    .recv__val( ctrl_ring__recv__val ),
    .send__msg( ctrl_ring__send__msg ),
    .send__rdy( ctrl_ring__send__rdy ),
    .send__val( ctrl_ring__send__val )
  );

  //-------------------------------------------------------------
  // End of component ctrl_ring
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component data_mem
  //-------------------------------------------------------------

  logic [8:0] data_mem__address_lower;
  logic [8:0] data_mem__address_upper;
  logic [1:0] data_mem__cgra_id;
  logic [0:0] data_mem__clk;
  logic [0:0] data_mem__reset;
  InterCgraPacket_4_4x1_4_8_4_CgraPayload__9d404f857a1e94ff data_mem__recv_from_noc_load_request__msg;
  logic [0:0] data_mem__recv_from_noc_load_request__rdy;
  logic [0:0] data_mem__recv_from_noc_load_request__val;
  InterCgraPacket_4_4x1_4_8_4_CgraPayload__9d404f857a1e94ff data_mem__recv_from_noc_load_response_pkt__msg;
  logic [0:0] data_mem__recv_from_noc_load_response_pkt__rdy;
  logic [0:0] data_mem__recv_from_noc_load_response_pkt__val;
  InterCgraPacket_4_4x1_4_8_4_CgraPayload__9d404f857a1e94ff data_mem__recv_from_noc_store_request__msg;
  logic [0:0] data_mem__recv_from_noc_store_request__rdy;
  logic [0:0] data_mem__recv_from_noc_store_request__val;
  logic [8:0] data_mem__recv_raddr__msg [0:2];
  logic [0:0] data_mem__recv_raddr__rdy [0:2];
  logic [0:0] data_mem__recv_raddr__val [0:2];
  logic [8:0] data_mem__recv_waddr__msg [0:2];
  logic [0:0] data_mem__recv_waddr__rdy [0:2];
  logic [0:0] data_mem__recv_waddr__val [0:2];
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 data_mem__recv_wdata__msg [0:2];
  logic [0:0] data_mem__recv_wdata__rdy [0:2];
  logic [0:0] data_mem__recv_wdata__val [0:2];
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 data_mem__send_rdata__msg [0:2];
  logic [0:0] data_mem__send_rdata__rdy [0:2];
  logic [0:0] data_mem__send_rdata__val [0:2];
  InterCgraPacket_4_4x1_4_8_4_CgraPayload__9d404f857a1e94ff data_mem__send_to_noc_load_request_pkt__msg;
  logic [0:0] data_mem__send_to_noc_load_request_pkt__rdy;
  logic [0:0] data_mem__send_to_noc_load_request_pkt__val;
  InterCgraPacket_4_4x1_4_8_4_CgraPayload__9d404f857a1e94ff data_mem__send_to_noc_load_response_pkt__msg;
  logic [0:0] data_mem__send_to_noc_load_response_pkt__rdy;
  logic [0:0] data_mem__send_to_noc_load_response_pkt__val;
  InterCgraPacket_4_4x1_4_8_4_CgraPayload__9d404f857a1e94ff data_mem__send_to_noc_store_pkt__msg;
  logic [0:0] data_mem__send_to_noc_store_pkt__rdy;
  logic [0:0] data_mem__send_to_noc_store_pkt__val;

  DataMemControllerRTL__ff601aaa934406d0 data_mem
  (
    .address_lower( data_mem__address_lower ),
    .address_upper( data_mem__address_upper ),
    .cgra_id( data_mem__cgra_id ),
    .clk( data_mem__clk ),
    .reset( data_mem__reset ),
    .recv_from_noc_load_request__msg( data_mem__recv_from_noc_load_request__msg ),
    .recv_from_noc_load_request__rdy( data_mem__recv_from_noc_load_request__rdy ),
    .recv_from_noc_load_request__val( data_mem__recv_from_noc_load_request__val ),
    .recv_from_noc_load_response_pkt__msg( data_mem__recv_from_noc_load_response_pkt__msg ),
    .recv_from_noc_load_response_pkt__rdy( data_mem__recv_from_noc_load_response_pkt__rdy ),
    .recv_from_noc_load_response_pkt__val( data_mem__recv_from_noc_load_response_pkt__val ),
    .recv_from_noc_store_request__msg( data_mem__recv_from_noc_store_request__msg ),
    .recv_from_noc_store_request__rdy( data_mem__recv_from_noc_store_request__rdy ),
    .recv_from_noc_store_request__val( data_mem__recv_from_noc_store_request__val ),
    .recv_raddr__msg( data_mem__recv_raddr__msg ),
    .recv_raddr__rdy( data_mem__recv_raddr__rdy ),
    .recv_raddr__val( data_mem__recv_raddr__val ),
    .recv_waddr__msg( data_mem__recv_waddr__msg ),
    .recv_waddr__rdy( data_mem__recv_waddr__rdy ),
    .recv_waddr__val( data_mem__recv_waddr__val ),
    .recv_wdata__msg( data_mem__recv_wdata__msg ),
    .recv_wdata__rdy( data_mem__recv_wdata__rdy ),
    .recv_wdata__val( data_mem__recv_wdata__val ),
    .send_rdata__msg( data_mem__send_rdata__msg ),
    .send_rdata__rdy( data_mem__send_rdata__rdy ),
    .send_rdata__val( data_mem__send_rdata__val ),
    .send_to_noc_load_request_pkt__msg( data_mem__send_to_noc_load_request_pkt__msg ),
    .send_to_noc_load_request_pkt__rdy( data_mem__send_to_noc_load_request_pkt__rdy ),
    .send_to_noc_load_request_pkt__val( data_mem__send_to_noc_load_request_pkt__val ),
    .send_to_noc_load_response_pkt__msg( data_mem__send_to_noc_load_response_pkt__msg ),
    .send_to_noc_load_response_pkt__rdy( data_mem__send_to_noc_load_response_pkt__rdy ),
    .send_to_noc_load_response_pkt__val( data_mem__send_to_noc_load_response_pkt__val ),
    .send_to_noc_store_pkt__msg( data_mem__send_to_noc_store_pkt__msg ),
    .send_to_noc_store_pkt__rdy( data_mem__send_to_noc_store_pkt__rdy ),
    .send_to_noc_store_pkt__val( data_mem__send_to_noc_store_pkt__val )
  );

  //-------------------------------------------------------------
  // End of component data_mem
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component tile[0:3]
  //-------------------------------------------------------------

  logic [1:0] tile__cgra_id [0:3];
  logic [0:0] tile__clk [0:3];
  logic [0:0] tile__reset [0:3];
  logic [2:0] tile__tile_id [0:3];
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 tile__from_mem_rdata__msg [0:3];
  logic [0:0] tile__from_mem_rdata__rdy [0:3];
  logic [0:0] tile__from_mem_rdata__val [0:3];
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 tile__recv_data__msg [0:3][0:7];
  logic [0:0] tile__recv_data__rdy [0:3][0:7];
  logic [0:0] tile__recv_data__val [0:3][0:7];
  IntraCgraPacket_4_4x1_4_8_2_CgraPayload__11cd3f8c0d91825c tile__recv_from_controller_pkt__msg [0:3];
  logic [0:0] tile__recv_from_controller_pkt__rdy [0:3];
  logic [0:0] tile__recv_from_controller_pkt__val [0:3];
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 tile__send_data__msg [0:3][0:7];
  logic [0:0] tile__send_data__rdy [0:3][0:7];
  logic [0:0] tile__send_data__val [0:3][0:7];
  IntraCgraPacket_4_4x1_4_8_2_CgraPayload__11cd3f8c0d91825c tile__send_to_controller_pkt__msg [0:3];
  logic [0:0] tile__send_to_controller_pkt__rdy [0:3];
  logic [0:0] tile__send_to_controller_pkt__val [0:3];
  logic [8:0] tile__to_mem_raddr__msg [0:3];
  logic [0:0] tile__to_mem_raddr__rdy [0:3];
  logic [0:0] tile__to_mem_raddr__val [0:3];
  logic [8:0] tile__to_mem_waddr__msg [0:3];
  logic [0:0] tile__to_mem_waddr__rdy [0:3];
  logic [0:0] tile__to_mem_waddr__val [0:3];
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 tile__to_mem_wdata__msg [0:3];
  logic [0:0] tile__to_mem_wdata__rdy [0:3];
  logic [0:0] tile__to_mem_wdata__val [0:3];

  TileRTL__526e2eb7b6177797 tile__0
  (
    .cgra_id( tile__cgra_id[0] ),
    .clk( tile__clk[0] ),
    .reset( tile__reset[0] ),
    .tile_id( tile__tile_id[0] ),
    .from_mem_rdata__msg( tile__from_mem_rdata__msg[0] ),
    .from_mem_rdata__rdy( tile__from_mem_rdata__rdy[0] ),
    .from_mem_rdata__val( tile__from_mem_rdata__val[0] ),
    .recv_data__msg( tile__recv_data__msg[0] ),
    .recv_data__rdy( tile__recv_data__rdy[0] ),
    .recv_data__val( tile__recv_data__val[0] ),
    .recv_from_controller_pkt__msg( tile__recv_from_controller_pkt__msg[0] ),
    .recv_from_controller_pkt__rdy( tile__recv_from_controller_pkt__rdy[0] ),
    .recv_from_controller_pkt__val( tile__recv_from_controller_pkt__val[0] ),
    .send_data__msg( tile__send_data__msg[0] ),
    .send_data__rdy( tile__send_data__rdy[0] ),
    .send_data__val( tile__send_data__val[0] ),
    .send_to_controller_pkt__msg( tile__send_to_controller_pkt__msg[0] ),
    .send_to_controller_pkt__rdy( tile__send_to_controller_pkt__rdy[0] ),
    .send_to_controller_pkt__val( tile__send_to_controller_pkt__val[0] ),
    .to_mem_raddr__msg( tile__to_mem_raddr__msg[0] ),
    .to_mem_raddr__rdy( tile__to_mem_raddr__rdy[0] ),
    .to_mem_raddr__val( tile__to_mem_raddr__val[0] ),
    .to_mem_waddr__msg( tile__to_mem_waddr__msg[0] ),
    .to_mem_waddr__rdy( tile__to_mem_waddr__rdy[0] ),
    .to_mem_waddr__val( tile__to_mem_waddr__val[0] ),
    .to_mem_wdata__msg( tile__to_mem_wdata__msg[0] ),
    .to_mem_wdata__rdy( tile__to_mem_wdata__rdy[0] ),
    .to_mem_wdata__val( tile__to_mem_wdata__val[0] )
  );

  TileRTL__526e2eb7b6177797 tile__1
  (
    .cgra_id( tile__cgra_id[1] ),
    .clk( tile__clk[1] ),
    .reset( tile__reset[1] ),
    .tile_id( tile__tile_id[1] ),
    .from_mem_rdata__msg( tile__from_mem_rdata__msg[1] ),
    .from_mem_rdata__rdy( tile__from_mem_rdata__rdy[1] ),
    .from_mem_rdata__val( tile__from_mem_rdata__val[1] ),
    .recv_data__msg( tile__recv_data__msg[1] ),
    .recv_data__rdy( tile__recv_data__rdy[1] ),
    .recv_data__val( tile__recv_data__val[1] ),
    .recv_from_controller_pkt__msg( tile__recv_from_controller_pkt__msg[1] ),
    .recv_from_controller_pkt__rdy( tile__recv_from_controller_pkt__rdy[1] ),
    .recv_from_controller_pkt__val( tile__recv_from_controller_pkt__val[1] ),
    .send_data__msg( tile__send_data__msg[1] ),
    .send_data__rdy( tile__send_data__rdy[1] ),
    .send_data__val( tile__send_data__val[1] ),
    .send_to_controller_pkt__msg( tile__send_to_controller_pkt__msg[1] ),
    .send_to_controller_pkt__rdy( tile__send_to_controller_pkt__rdy[1] ),
    .send_to_controller_pkt__val( tile__send_to_controller_pkt__val[1] ),
    .to_mem_raddr__msg( tile__to_mem_raddr__msg[1] ),
    .to_mem_raddr__rdy( tile__to_mem_raddr__rdy[1] ),
    .to_mem_raddr__val( tile__to_mem_raddr__val[1] ),
    .to_mem_waddr__msg( tile__to_mem_waddr__msg[1] ),
    .to_mem_waddr__rdy( tile__to_mem_waddr__rdy[1] ),
    .to_mem_waddr__val( tile__to_mem_waddr__val[1] ),
    .to_mem_wdata__msg( tile__to_mem_wdata__msg[1] ),
    .to_mem_wdata__rdy( tile__to_mem_wdata__rdy[1] ),
    .to_mem_wdata__val( tile__to_mem_wdata__val[1] )
  );

  TileRTL__526e2eb7b6177797 tile__2
  (
    .cgra_id( tile__cgra_id[2] ),
    .clk( tile__clk[2] ),
    .reset( tile__reset[2] ),
    .tile_id( tile__tile_id[2] ),
    .from_mem_rdata__msg( tile__from_mem_rdata__msg[2] ),
    .from_mem_rdata__rdy( tile__from_mem_rdata__rdy[2] ),
    .from_mem_rdata__val( tile__from_mem_rdata__val[2] ),
    .recv_data__msg( tile__recv_data__msg[2] ),
    .recv_data__rdy( tile__recv_data__rdy[2] ),
    .recv_data__val( tile__recv_data__val[2] ),
    .recv_from_controller_pkt__msg( tile__recv_from_controller_pkt__msg[2] ),
    .recv_from_controller_pkt__rdy( tile__recv_from_controller_pkt__rdy[2] ),
    .recv_from_controller_pkt__val( tile__recv_from_controller_pkt__val[2] ),
    .send_data__msg( tile__send_data__msg[2] ),
    .send_data__rdy( tile__send_data__rdy[2] ),
    .send_data__val( tile__send_data__val[2] ),
    .send_to_controller_pkt__msg( tile__send_to_controller_pkt__msg[2] ),
    .send_to_controller_pkt__rdy( tile__send_to_controller_pkt__rdy[2] ),
    .send_to_controller_pkt__val( tile__send_to_controller_pkt__val[2] ),
    .to_mem_raddr__msg( tile__to_mem_raddr__msg[2] ),
    .to_mem_raddr__rdy( tile__to_mem_raddr__rdy[2] ),
    .to_mem_raddr__val( tile__to_mem_raddr__val[2] ),
    .to_mem_waddr__msg( tile__to_mem_waddr__msg[2] ),
    .to_mem_waddr__rdy( tile__to_mem_waddr__rdy[2] ),
    .to_mem_waddr__val( tile__to_mem_waddr__val[2] ),
    .to_mem_wdata__msg( tile__to_mem_wdata__msg[2] ),
    .to_mem_wdata__rdy( tile__to_mem_wdata__rdy[2] ),
    .to_mem_wdata__val( tile__to_mem_wdata__val[2] )
  );

  TileRTL__526e2eb7b6177797 tile__3
  (
    .cgra_id( tile__cgra_id[3] ),
    .clk( tile__clk[3] ),
    .reset( tile__reset[3] ),
    .tile_id( tile__tile_id[3] ),
    .from_mem_rdata__msg( tile__from_mem_rdata__msg[3] ),
    .from_mem_rdata__rdy( tile__from_mem_rdata__rdy[3] ),
    .from_mem_rdata__val( tile__from_mem_rdata__val[3] ),
    .recv_data__msg( tile__recv_data__msg[3] ),
    .recv_data__rdy( tile__recv_data__rdy[3] ),
    .recv_data__val( tile__recv_data__val[3] ),
    .recv_from_controller_pkt__msg( tile__recv_from_controller_pkt__msg[3] ),
    .recv_from_controller_pkt__rdy( tile__recv_from_controller_pkt__rdy[3] ),
    .recv_from_controller_pkt__val( tile__recv_from_controller_pkt__val[3] ),
    .send_data__msg( tile__send_data__msg[3] ),
    .send_data__rdy( tile__send_data__rdy[3] ),
    .send_data__val( tile__send_data__val[3] ),
    .send_to_controller_pkt__msg( tile__send_to_controller_pkt__msg[3] ),
    .send_to_controller_pkt__rdy( tile__send_to_controller_pkt__rdy[3] ),
    .send_to_controller_pkt__val( tile__send_to_controller_pkt__val[3] ),
    .to_mem_raddr__msg( tile__to_mem_raddr__msg[3] ),
    .to_mem_raddr__rdy( tile__to_mem_raddr__rdy[3] ),
    .to_mem_raddr__val( tile__to_mem_raddr__val[3] ),
    .to_mem_waddr__msg( tile__to_mem_waddr__msg[3] ),
    .to_mem_waddr__rdy( tile__to_mem_waddr__rdy[3] ),
    .to_mem_waddr__val( tile__to_mem_waddr__val[3] ),
    .to_mem_wdata__msg( tile__to_mem_wdata__msg[3] ),
    .to_mem_wdata__rdy( tile__to_mem_wdata__rdy[3] ),
    .to_mem_wdata__val( tile__to_mem_wdata__val[3] )
  );

  //-------------------------------------------------------------
  // End of component tile[0:3]
  //-------------------------------------------------------------

  assign tile__clk[0] = clk;
  assign tile__reset[0] = reset;
  assign tile__clk[1] = clk;
  assign tile__reset[1] = reset;
  assign tile__clk[2] = clk;
  assign tile__reset[2] = reset;
  assign tile__clk[3] = clk;
  assign tile__reset[3] = reset;
  assign data_mem__clk = clk;
  assign data_mem__reset = reset;
  assign controller__clk = clk;
  assign controller__reset = reset;
  assign controller__cgra_id = cgra_id;
  assign ctrl_ring__clk = clk;
  assign ctrl_ring__reset = reset;
  assign data_mem__cgra_id = cgra_id;
  assign data_mem__address_lower = address_lower;
  assign data_mem__address_upper = address_upper;
  assign data_mem__recv_from_noc_load_request__msg = controller__send_to_mem_load_request__msg;
  assign controller__send_to_mem_load_request__rdy = data_mem__recv_from_noc_load_request__rdy;
  assign data_mem__recv_from_noc_load_request__val = controller__send_to_mem_load_request__val;
  assign data_mem__recv_from_noc_store_request__msg = controller__send_to_mem_store_request__msg;
  assign controller__send_to_mem_store_request__rdy = data_mem__recv_from_noc_store_request__rdy;
  assign data_mem__recv_from_noc_store_request__val = controller__send_to_mem_store_request__val;
  assign data_mem__recv_from_noc_load_response_pkt__msg = controller__send_to_tile_load_response__msg;
  assign controller__send_to_tile_load_response__rdy = data_mem__recv_from_noc_load_response_pkt__rdy;
  assign data_mem__recv_from_noc_load_response_pkt__val = controller__send_to_tile_load_response__val;
  assign controller__recv_from_tile_load_request_pkt__msg = data_mem__send_to_noc_load_request_pkt__msg;
  assign data_mem__send_to_noc_load_request_pkt__rdy = controller__recv_from_tile_load_request_pkt__rdy;
  assign controller__recv_from_tile_load_request_pkt__val = data_mem__send_to_noc_load_request_pkt__val;
  assign controller__recv_from_tile_load_response_pkt__msg = data_mem__send_to_noc_load_response_pkt__msg;
  assign data_mem__send_to_noc_load_response_pkt__rdy = controller__recv_from_tile_load_response_pkt__rdy;
  assign controller__recv_from_tile_load_response_pkt__val = data_mem__send_to_noc_load_response_pkt__val;
  assign controller__recv_from_tile_store_request_pkt__msg = data_mem__send_to_noc_store_pkt__msg;
  assign data_mem__send_to_noc_store_pkt__rdy = controller__recv_from_tile_store_request_pkt__rdy;
  assign controller__recv_from_tile_store_request_pkt__val = data_mem__send_to_noc_store_pkt__val;
  assign bypass_queue__clk = clk;
  assign bypass_queue__reset = reset;
  assign controller__recv_from_inter_cgra_noc__msg = bypass_queue__send__msg;
  assign bypass_queue__send__rdy = controller__recv_from_inter_cgra_noc__rdy;
  assign controller__recv_from_inter_cgra_noc__val = bypass_queue__send__val;
  assign bypass_queue__recv__msg = controller__send_to_inter_cgra_noc__msg;
  assign controller__send_to_inter_cgra_noc__rdy = bypass_queue__recv__rdy;
  assign bypass_queue__recv__val = controller__send_to_inter_cgra_noc__val;
  assign controller__recv_from_cpu_pkt__msg = recv_from_cpu_pkt__msg;
  assign recv_from_cpu_pkt__rdy = controller__recv_from_cpu_pkt__rdy;
  assign controller__recv_from_cpu_pkt__val = recv_from_cpu_pkt__val;
  assign send_to_cpu_pkt__msg = controller__send_to_cpu_pkt__msg;
  assign controller__send_to_cpu_pkt__rdy = send_to_cpu_pkt__rdy;
  assign send_to_cpu_pkt__val = controller__send_to_cpu_pkt__val;
  assign tile__cgra_id[0] = cgra_id;
  assign tile__tile_id[0] = 3'd0;
  assign tile__cgra_id[1] = cgra_id;
  assign tile__tile_id[1] = 3'd1;
  assign tile__cgra_id[2] = cgra_id;
  assign tile__tile_id[2] = 3'd2;
  assign tile__cgra_id[3] = cgra_id;
  assign tile__tile_id[3] = 3'd3;
  assign tile__recv_from_controller_pkt__msg[0] = ctrl_ring__send__msg[0];
  assign ctrl_ring__send__rdy[0] = tile__recv_from_controller_pkt__rdy[0];
  assign tile__recv_from_controller_pkt__val[0] = ctrl_ring__send__val[0];
  assign tile__recv_from_controller_pkt__msg[1] = ctrl_ring__send__msg[1];
  assign ctrl_ring__send__rdy[1] = tile__recv_from_controller_pkt__rdy[1];
  assign tile__recv_from_controller_pkt__val[1] = ctrl_ring__send__val[1];
  assign tile__recv_from_controller_pkt__msg[2] = ctrl_ring__send__msg[2];
  assign ctrl_ring__send__rdy[2] = tile__recv_from_controller_pkt__rdy[2];
  assign tile__recv_from_controller_pkt__val[2] = ctrl_ring__send__val[2];
  assign tile__recv_from_controller_pkt__msg[3] = ctrl_ring__send__msg[3];
  assign ctrl_ring__send__rdy[3] = tile__recv_from_controller_pkt__rdy[3];
  assign tile__recv_from_controller_pkt__val[3] = ctrl_ring__send__val[3];
  assign ctrl_ring__recv__msg[0] = tile__send_to_controller_pkt__msg[0];
  assign tile__send_to_controller_pkt__rdy[0] = ctrl_ring__recv__rdy[0];
  assign ctrl_ring__recv__val[0] = tile__send_to_controller_pkt__val[0];
  assign ctrl_ring__recv__msg[1] = tile__send_to_controller_pkt__msg[1];
  assign tile__send_to_controller_pkt__rdy[1] = ctrl_ring__recv__rdy[1];
  assign ctrl_ring__recv__val[1] = tile__send_to_controller_pkt__val[1];
  assign ctrl_ring__recv__msg[2] = tile__send_to_controller_pkt__msg[2];
  assign tile__send_to_controller_pkt__rdy[2] = ctrl_ring__recv__rdy[2];
  assign ctrl_ring__recv__val[2] = tile__send_to_controller_pkt__val[2];
  assign ctrl_ring__recv__msg[3] = tile__send_to_controller_pkt__msg[3];
  assign tile__send_to_controller_pkt__rdy[3] = ctrl_ring__recv__rdy[3];
  assign ctrl_ring__recv__val[3] = tile__send_to_controller_pkt__val[3];
  assign ctrl_ring__recv__msg[4] = controller__send_to_ctrl_ring_pkt__msg;
  assign controller__send_to_ctrl_ring_pkt__rdy = ctrl_ring__recv__rdy[4];
  assign ctrl_ring__recv__val[4] = controller__send_to_ctrl_ring_pkt__val;
  assign controller__recv_from_ctrl_ring_pkt__msg = ctrl_ring__send__msg[4];
  assign ctrl_ring__send__rdy[4] = controller__recv_from_ctrl_ring_pkt__rdy;
  assign controller__recv_from_ctrl_ring_pkt__val = ctrl_ring__send__val[4];
  assign data_mem__recv_raddr__msg[0] = tile__to_mem_raddr__msg[0];
  assign tile__to_mem_raddr__rdy[0] = data_mem__recv_raddr__rdy[0];
  assign data_mem__recv_raddr__val[0] = tile__to_mem_raddr__val[0];
  assign tile__from_mem_rdata__msg[0] = data_mem__send_rdata__msg[0];
  assign data_mem__send_rdata__rdy[0] = tile__from_mem_rdata__rdy[0];
  assign tile__from_mem_rdata__val[0] = data_mem__send_rdata__val[0];
  assign tile__recv_data__val[0][2] = 1'd0;
  assign tile__recv_data__msg[0][2] = { 32'd0, 1'd0, 1'd0, 1'd0 };
  assign data_mem__recv_waddr__msg[0] = tile__to_mem_waddr__msg[0];
  assign tile__to_mem_waddr__rdy[0] = data_mem__recv_waddr__rdy[0];
  assign data_mem__recv_waddr__val[0] = tile__to_mem_waddr__val[0];
  assign data_mem__recv_wdata__msg[0] = tile__to_mem_wdata__msg[0];
  assign tile__to_mem_wdata__rdy[0] = data_mem__recv_wdata__rdy[0];
  assign data_mem__recv_wdata__val[0] = tile__to_mem_wdata__val[0];
  assign tile__send_data__rdy[0][2] = 1'd0;
  assign data_mem__recv_raddr__msg[1] = tile__to_mem_raddr__msg[2];
  assign tile__to_mem_raddr__rdy[2] = data_mem__recv_raddr__rdy[1];
  assign data_mem__recv_raddr__val[1] = tile__to_mem_raddr__val[2];
  assign tile__from_mem_rdata__msg[2] = data_mem__send_rdata__msg[1];
  assign data_mem__send_rdata__rdy[1] = tile__from_mem_rdata__rdy[2];
  assign tile__from_mem_rdata__val[2] = data_mem__send_rdata__val[1];
  assign tile__recv_data__val[2][2] = 1'd0;
  assign tile__recv_data__msg[2][2] = { 32'd0, 1'd0, 1'd0, 1'd0 };
  assign data_mem__recv_waddr__msg[1] = tile__to_mem_waddr__msg[2];
  assign tile__to_mem_waddr__rdy[2] = data_mem__recv_waddr__rdy[1];
  assign data_mem__recv_waddr__val[1] = tile__to_mem_waddr__val[2];
  assign data_mem__recv_wdata__msg[1] = tile__to_mem_wdata__msg[2];
  assign tile__to_mem_wdata__rdy[2] = data_mem__recv_wdata__rdy[1];
  assign data_mem__recv_wdata__val[1] = tile__to_mem_wdata__val[2];
  assign tile__send_data__rdy[2][2] = 1'd0;
  assign data_mem__recv_raddr__msg[2] = tile__to_mem_raddr__msg[1];
  assign tile__to_mem_raddr__rdy[1] = data_mem__recv_raddr__rdy[2];
  assign data_mem__recv_raddr__val[2] = tile__to_mem_raddr__val[1];
  assign tile__from_mem_rdata__msg[1] = data_mem__send_rdata__msg[2];
  assign data_mem__send_rdata__rdy[2] = tile__from_mem_rdata__rdy[1];
  assign tile__from_mem_rdata__val[1] = data_mem__send_rdata__val[2];
  assign tile__recv_data__val[1][1] = 1'd0;
  assign tile__recv_data__msg[1][1] = { 32'd0, 1'd0, 1'd0, 1'd0 };
  assign data_mem__recv_waddr__msg[2] = tile__to_mem_waddr__msg[1];
  assign tile__to_mem_waddr__rdy[1] = data_mem__recv_waddr__rdy[2];
  assign data_mem__recv_waddr__val[2] = tile__to_mem_waddr__val[1];
  assign data_mem__recv_wdata__msg[2] = tile__to_mem_wdata__msg[1];
  assign tile__to_mem_wdata__rdy[1] = data_mem__recv_wdata__rdy[2];
  assign data_mem__recv_wdata__val[2] = tile__to_mem_wdata__val[1];
  assign tile__send_data__rdy[1][1] = 1'd0;
  assign tile__recv_data__msg[1][2] = tile__send_data__msg[0][3];
  assign tile__send_data__rdy[0][3] = tile__recv_data__rdy[1][2];
  assign tile__recv_data__val[1][2] = tile__send_data__val[0][3];
  assign tile__recv_data__msg[0][3] = tile__send_data__msg[1][2];
  assign tile__send_data__rdy[1][2] = tile__recv_data__rdy[0][3];
  assign tile__recv_data__val[0][3] = tile__send_data__val[1][2];
  assign tile__recv_data__msg[3][2] = tile__send_data__msg[2][3];
  assign tile__send_data__rdy[2][3] = tile__recv_data__rdy[3][2];
  assign tile__recv_data__val[3][2] = tile__send_data__val[2][3];
  assign tile__recv_data__msg[2][3] = tile__send_data__msg[3][2];
  assign tile__send_data__rdy[3][2] = tile__recv_data__rdy[2][3];
  assign tile__recv_data__val[2][3] = tile__send_data__val[3][2];
  assign tile__recv_data__msg[2][1] = tile__send_data__msg[0][0];
  assign tile__send_data__rdy[0][0] = tile__recv_data__rdy[2][1];
  assign tile__recv_data__val[2][1] = tile__send_data__val[0][0];
  assign tile__recv_data__msg[0][0] = tile__send_data__msg[2][1];
  assign tile__send_data__rdy[2][1] = tile__recv_data__rdy[0][0];
  assign tile__recv_data__val[0][0] = tile__send_data__val[2][1];
  assign tile__recv_data__msg[3][1] = tile__send_data__msg[1][0];
  assign tile__send_data__rdy[1][0] = tile__recv_data__rdy[3][1];
  assign tile__recv_data__val[3][1] = tile__send_data__val[1][0];
  assign tile__recv_data__msg[1][0] = tile__send_data__msg[3][1];
  assign tile__send_data__rdy[3][1] = tile__recv_data__rdy[1][0];
  assign tile__recv_data__val[1][0] = tile__send_data__val[3][1];
  assign tile__recv_data__msg[3][7] = tile__send_data__msg[0][5];
  assign tile__send_data__rdy[0][5] = tile__recv_data__rdy[3][7];
  assign tile__recv_data__val[3][7] = tile__send_data__val[0][5];
  assign tile__recv_data__msg[0][5] = tile__send_data__msg[3][7];
  assign tile__send_data__rdy[3][7] = tile__recv_data__rdy[0][5];
  assign tile__recv_data__val[0][5] = tile__send_data__val[3][7];
  assign tile__recv_data__msg[2][6] = tile__send_data__msg[1][4];
  assign tile__send_data__rdy[1][4] = tile__recv_data__rdy[2][6];
  assign tile__recv_data__val[2][6] = tile__send_data__val[1][4];
  assign tile__recv_data__msg[1][4] = tile__send_data__msg[2][6];
  assign tile__send_data__rdy[2][6] = tile__recv_data__rdy[1][4];
  assign tile__recv_data__val[1][4] = tile__send_data__val[2][6];
  assign tile__recv_data__val[0][1] = 1'd0;
  assign tile__recv_data__msg[0][1] = { 32'd0, 1'd0, 1'd0, 1'd0 };
  assign tile__recv_data__val[0][4] = 1'd0;
  assign tile__recv_data__msg[0][4] = { 32'd0, 1'd0, 1'd0, 1'd0 };
  assign tile__recv_data__val[0][6] = 1'd0;
  assign tile__recv_data__msg[0][6] = { 32'd0, 1'd0, 1'd0, 1'd0 };
  assign tile__recv_data__val[0][7] = 1'd0;
  assign tile__recv_data__msg[0][7] = { 32'd0, 1'd0, 1'd0, 1'd0 };
  assign tile__send_data__rdy[0][1] = 1'd0;
  assign tile__send_data__rdy[0][4] = 1'd0;
  assign tile__send_data__rdy[0][6] = 1'd0;
  assign tile__send_data__rdy[0][7] = 1'd0;
  assign tile__recv_data__val[1][3] = 1'd0;
  assign tile__recv_data__msg[1][3] = { 32'd0, 1'd0, 1'd0, 1'd0 };
  assign tile__recv_data__val[1][5] = 1'd0;
  assign tile__recv_data__msg[1][5] = { 32'd0, 1'd0, 1'd0, 1'd0 };
  assign tile__recv_data__val[1][6] = 1'd0;
  assign tile__recv_data__msg[1][6] = { 32'd0, 1'd0, 1'd0, 1'd0 };
  assign tile__recv_data__val[1][7] = 1'd0;
  assign tile__recv_data__msg[1][7] = { 32'd0, 1'd0, 1'd0, 1'd0 };
  assign tile__send_data__rdy[1][3] = 1'd0;
  assign tile__send_data__rdy[1][5] = 1'd0;
  assign tile__send_data__rdy[1][6] = 1'd0;
  assign tile__send_data__rdy[1][7] = 1'd0;
  assign tile__recv_data__val[2][0] = 1'd0;
  assign tile__recv_data__msg[2][0] = { 32'd0, 1'd0, 1'd0, 1'd0 };
  assign tile__recv_data__val[2][4] = 1'd0;
  assign tile__recv_data__msg[2][4] = { 32'd0, 1'd0, 1'd0, 1'd0 };
  assign tile__recv_data__val[2][5] = 1'd0;
  assign tile__recv_data__msg[2][5] = { 32'd0, 1'd0, 1'd0, 1'd0 };
  assign tile__recv_data__val[2][7] = 1'd0;
  assign tile__recv_data__msg[2][7] = { 32'd0, 1'd0, 1'd0, 1'd0 };
  assign tile__send_data__rdy[2][0] = 1'd0;
  assign tile__send_data__rdy[2][4] = 1'd0;
  assign tile__send_data__rdy[2][5] = 1'd0;
  assign tile__send_data__rdy[2][7] = 1'd0;
  assign tile__recv_data__val[3][0] = 1'd0;
  assign tile__recv_data__msg[3][0] = { 32'd0, 1'd0, 1'd0, 1'd0 };
  assign tile__recv_data__val[3][3] = 1'd0;
  assign tile__recv_data__msg[3][3] = { 32'd0, 1'd0, 1'd0, 1'd0 };
  assign tile__recv_data__val[3][4] = 1'd0;
  assign tile__recv_data__msg[3][4] = { 32'd0, 1'd0, 1'd0, 1'd0 };
  assign tile__recv_data__val[3][5] = 1'd0;
  assign tile__recv_data__msg[3][5] = { 32'd0, 1'd0, 1'd0, 1'd0 };
  assign tile__recv_data__val[3][6] = 1'd0;
  assign tile__recv_data__msg[3][6] = { 32'd0, 1'd0, 1'd0, 1'd0 };
  assign tile__send_data__rdy[3][0] = 1'd0;
  assign tile__send_data__rdy[3][3] = 1'd0;
  assign tile__send_data__rdy[3][4] = 1'd0;
  assign tile__send_data__rdy[3][5] = 1'd0;
  assign tile__send_data__rdy[3][6] = 1'd0;
  assign tile__to_mem_raddr__rdy[3] = 1'd0;
  assign tile__from_mem_rdata__val[3] = 1'd0;
  assign tile__from_mem_rdata__msg[3] = { 32'd0, 1'd0, 1'd0, 1'd0 };
  assign tile__to_mem_waddr__rdy[3] = 1'd0;
  assign tile__to_mem_wdata__rdy[3] = 1'd0;

endmodule
